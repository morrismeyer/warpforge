// Generated by jextract

package io.surfworks.warpforge.io.ffi.ucc;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ucc_coll_args {
 *     uint64_t mask;
 *     ucc_coll_type_t coll_type;
 *     union {
 *         ucc_coll_buffer_info_t info;
 *         ucc_coll_buffer_info_v_t info_v;
 *     } src;
 *     union {
 *         ucc_coll_buffer_info_t info;
 *         ucc_coll_buffer_info_v_t info_v;
 *     } dst;
 *     ucc_reduction_op_t op;
 *     uint64_t flags;
 *     uint64_t root;
 *     ucc_error_type_t error_type;
 *     ucc_coll_id_t tag;
 *     void *global_work_buffer;
 *     ucc_coll_callback_t cb;
 *     double timeout;
 *     struct {
 *         uint64_t start;
 *         int64_t stride;
 *         uint64_t size;
 *     } active_set;
 *     union {
 *         ucc_mem_map_mem_h local_memh;
 *         ucc_mem_map_mem_h *global_memh;
 *     } src_memh;
 *     union {
 *         ucc_mem_map_mem_h local_memh;
 *         ucc_mem_map_mem_h *global_memh;
 *     } dst_memh;
 * }
 * }
 */
public class ucc_coll_args {

    ucc_coll_args() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        Ucc.C_LONG.withName("mask"),
        Ucc.C_INT.withName("coll_type"),
        MemoryLayout.paddingLayout(4),
        ucc_coll_args.src.layout().withName("src"),
        ucc_coll_args.dst.layout().withName("dst"),
        Ucc.C_INT.withName("op"),
        MemoryLayout.paddingLayout(4),
        Ucc.C_LONG.withName("flags"),
        Ucc.C_LONG.withName("root"),
        Ucc.C_INT.withName("error_type"),
        Ucc.C_SHORT.withName("tag"),
        MemoryLayout.paddingLayout(2),
        Ucc.C_POINTER.withName("global_work_buffer"),
        ucc_coll_callback.layout().withName("cb"),
        Ucc.C_DOUBLE.withName("timeout"),
        ucc_coll_args.active_set.layout().withName("active_set"),
        ucc_coll_args.src_memh.layout().withName("src_memh"),
        ucc_coll_args.dst_memh.layout().withName("dst_memh")
    ).withName("ucc_coll_args");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfLong mask$LAYOUT = (OfLong)$LAYOUT.select(groupElement("mask"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t mask
     * }
     */
    public static final OfLong mask$layout() {
        return mask$LAYOUT;
    }

    private static final long mask$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t mask
     * }
     */
    public static final long mask$offset() {
        return mask$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t mask
     * }
     */
    public static long mask(MemorySegment struct) {
        return struct.get(mask$LAYOUT, mask$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t mask
     * }
     */
    public static void mask(MemorySegment struct, long fieldValue) {
        struct.set(mask$LAYOUT, mask$OFFSET, fieldValue);
    }

    private static final OfInt coll_type$LAYOUT = (OfInt)$LAYOUT.select(groupElement("coll_type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ucc_coll_type_t coll_type
     * }
     */
    public static final OfInt coll_type$layout() {
        return coll_type$LAYOUT;
    }

    private static final long coll_type$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ucc_coll_type_t coll_type
     * }
     */
    public static final long coll_type$offset() {
        return coll_type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ucc_coll_type_t coll_type
     * }
     */
    public static int coll_type(MemorySegment struct) {
        return struct.get(coll_type$LAYOUT, coll_type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ucc_coll_type_t coll_type
     * }
     */
    public static void coll_type(MemorySegment struct, int fieldValue) {
        struct.set(coll_type$LAYOUT, coll_type$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * union {
     *     ucc_coll_buffer_info_t info;
     *     ucc_coll_buffer_info_v_t info_v;
     * }
     * }
     */
    public static class src {

        src() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
            ucc_coll_buffer_info.layout().withName("info"),
            ucc_coll_buffer_info_v.layout().withName("info_v")
        ).withName("$anon$1859:5");

        /**
         * The layout of this union
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout info$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("info"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_t info
         * }
         */
        public static final GroupLayout info$layout() {
            return info$LAYOUT;
        }

        private static final long info$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_t info
         * }
         */
        public static final long info$offset() {
            return info$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_t info
         * }
         */
        public static MemorySegment info(MemorySegment union) {
            return union.asSlice(info$OFFSET, info$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_t info
         * }
         */
        public static void info(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, info$OFFSET, info$LAYOUT.byteSize());
        }

        private static final GroupLayout info_v$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("info_v"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_v_t info_v
         * }
         */
        public static final GroupLayout info_v$layout() {
            return info_v$LAYOUT;
        }

        private static final long info_v$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_v_t info_v
         * }
         */
        public static final long info_v$offset() {
            return info_v$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_v_t info_v
         * }
         */
        public static MemorySegment info_v(MemorySegment union) {
            return union.asSlice(info_v$OFFSET, info_v$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_v_t info_v
         * }
         */
        public static void info_v(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, info_v$OFFSET, info_v$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this union
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout src$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("src"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * union {
     *     ucc_coll_buffer_info_t info;
     *     ucc_coll_buffer_info_v_t info_v;
     * } src
     * }
     */
    public static final GroupLayout src$layout() {
        return src$LAYOUT;
    }

    private static final long src$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * union {
     *     ucc_coll_buffer_info_t info;
     *     ucc_coll_buffer_info_v_t info_v;
     * } src
     * }
     */
    public static final long src$offset() {
        return src$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * union {
     *     ucc_coll_buffer_info_t info;
     *     ucc_coll_buffer_info_v_t info_v;
     * } src
     * }
     */
    public static MemorySegment src(MemorySegment struct) {
        return struct.asSlice(src$OFFSET, src$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * union {
     *     ucc_coll_buffer_info_t info;
     *     ucc_coll_buffer_info_v_t info_v;
     * } src
     * }
     */
    public static void src(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, src$OFFSET, src$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * union {
     *     ucc_coll_buffer_info_t info;
     *     ucc_coll_buffer_info_v_t info_v;
     * }
     * }
     */
    public static class dst {

        dst() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
            ucc_coll_buffer_info.layout().withName("info"),
            ucc_coll_buffer_info_v.layout().withName("info_v")
        ).withName("$anon$1863:5");

        /**
         * The layout of this union
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final GroupLayout info$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("info"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_t info
         * }
         */
        public static final GroupLayout info$layout() {
            return info$LAYOUT;
        }

        private static final long info$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_t info
         * }
         */
        public static final long info$offset() {
            return info$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_t info
         * }
         */
        public static MemorySegment info(MemorySegment union) {
            return union.asSlice(info$OFFSET, info$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_t info
         * }
         */
        public static void info(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, info$OFFSET, info$LAYOUT.byteSize());
        }

        private static final GroupLayout info_v$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("info_v"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_v_t info_v
         * }
         */
        public static final GroupLayout info_v$layout() {
            return info_v$LAYOUT;
        }

        private static final long info_v$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_v_t info_v
         * }
         */
        public static final long info_v$offset() {
            return info_v$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_v_t info_v
         * }
         */
        public static MemorySegment info_v(MemorySegment union) {
            return union.asSlice(info_v$OFFSET, info_v$LAYOUT.byteSize());
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ucc_coll_buffer_info_v_t info_v
         * }
         */
        public static void info_v(MemorySegment union, MemorySegment fieldValue) {
            MemorySegment.copy(fieldValue, 0L, union, info_v$OFFSET, info_v$LAYOUT.byteSize());
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this union
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout dst$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("dst"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * union {
     *     ucc_coll_buffer_info_t info;
     *     ucc_coll_buffer_info_v_t info_v;
     * } dst
     * }
     */
    public static final GroupLayout dst$layout() {
        return dst$LAYOUT;
    }

    private static final long dst$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * union {
     *     ucc_coll_buffer_info_t info;
     *     ucc_coll_buffer_info_v_t info_v;
     * } dst
     * }
     */
    public static final long dst$offset() {
        return dst$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * union {
     *     ucc_coll_buffer_info_t info;
     *     ucc_coll_buffer_info_v_t info_v;
     * } dst
     * }
     */
    public static MemorySegment dst(MemorySegment struct) {
        return struct.asSlice(dst$OFFSET, dst$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * union {
     *     ucc_coll_buffer_info_t info;
     *     ucc_coll_buffer_info_v_t info_v;
     * } dst
     * }
     */
    public static void dst(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, dst$OFFSET, dst$LAYOUT.byteSize());
    }

    private static final OfInt op$LAYOUT = (OfInt)$LAYOUT.select(groupElement("op"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ucc_reduction_op_t op
     * }
     */
    public static final OfInt op$layout() {
        return op$LAYOUT;
    }

    private static final long op$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ucc_reduction_op_t op
     * }
     */
    public static final long op$offset() {
        return op$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ucc_reduction_op_t op
     * }
     */
    public static int op(MemorySegment struct) {
        return struct.get(op$LAYOUT, op$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ucc_reduction_op_t op
     * }
     */
    public static void op(MemorySegment struct, int fieldValue) {
        struct.set(op$LAYOUT, op$OFFSET, fieldValue);
    }

    private static final OfLong flags$LAYOUT = (OfLong)$LAYOUT.select(groupElement("flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t flags
     * }
     */
    public static final OfLong flags$layout() {
        return flags$LAYOUT;
    }

    private static final long flags$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t flags
     * }
     */
    public static final long flags$offset() {
        return flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t flags
     * }
     */
    public static long flags(MemorySegment struct) {
        return struct.get(flags$LAYOUT, flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t flags
     * }
     */
    public static void flags(MemorySegment struct, long fieldValue) {
        struct.set(flags$LAYOUT, flags$OFFSET, fieldValue);
    }

    private static final OfLong root$LAYOUT = (OfLong)$LAYOUT.select(groupElement("root"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t root
     * }
     */
    public static final OfLong root$layout() {
        return root$LAYOUT;
    }

    private static final long root$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t root
     * }
     */
    public static final long root$offset() {
        return root$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t root
     * }
     */
    public static long root(MemorySegment struct) {
        return struct.get(root$LAYOUT, root$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t root
     * }
     */
    public static void root(MemorySegment struct, long fieldValue) {
        struct.set(root$LAYOUT, root$OFFSET, fieldValue);
    }

    private static final OfInt error_type$LAYOUT = (OfInt)$LAYOUT.select(groupElement("error_type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ucc_error_type_t error_type
     * }
     */
    public static final OfInt error_type$layout() {
        return error_type$LAYOUT;
    }

    private static final long error_type$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ucc_error_type_t error_type
     * }
     */
    public static final long error_type$offset() {
        return error_type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ucc_error_type_t error_type
     * }
     */
    public static int error_type(MemorySegment struct) {
        return struct.get(error_type$LAYOUT, error_type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ucc_error_type_t error_type
     * }
     */
    public static void error_type(MemorySegment struct, int fieldValue) {
        struct.set(error_type$LAYOUT, error_type$OFFSET, fieldValue);
    }

    private static final OfShort tag$LAYOUT = (OfShort)$LAYOUT.select(groupElement("tag"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ucc_coll_id_t tag
     * }
     */
    public static final OfShort tag$layout() {
        return tag$LAYOUT;
    }

    private static final long tag$OFFSET = 124;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ucc_coll_id_t tag
     * }
     */
    public static final long tag$offset() {
        return tag$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ucc_coll_id_t tag
     * }
     */
    public static short tag(MemorySegment struct) {
        return struct.get(tag$LAYOUT, tag$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ucc_coll_id_t tag
     * }
     */
    public static void tag(MemorySegment struct, short fieldValue) {
        struct.set(tag$LAYOUT, tag$OFFSET, fieldValue);
    }

    private static final AddressLayout global_work_buffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("global_work_buffer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *global_work_buffer
     * }
     */
    public static final AddressLayout global_work_buffer$layout() {
        return global_work_buffer$LAYOUT;
    }

    private static final long global_work_buffer$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *global_work_buffer
     * }
     */
    public static final long global_work_buffer$offset() {
        return global_work_buffer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *global_work_buffer
     * }
     */
    public static MemorySegment global_work_buffer(MemorySegment struct) {
        return struct.get(global_work_buffer$LAYOUT, global_work_buffer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *global_work_buffer
     * }
     */
    public static void global_work_buffer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(global_work_buffer$LAYOUT, global_work_buffer$OFFSET, fieldValue);
    }

    private static final GroupLayout cb$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("cb"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ucc_coll_callback_t cb
     * }
     */
    public static final GroupLayout cb$layout() {
        return cb$LAYOUT;
    }

    private static final long cb$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ucc_coll_callback_t cb
     * }
     */
    public static final long cb$offset() {
        return cb$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ucc_coll_callback_t cb
     * }
     */
    public static MemorySegment cb(MemorySegment struct) {
        return struct.asSlice(cb$OFFSET, cb$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ucc_coll_callback_t cb
     * }
     */
    public static void cb(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, cb$OFFSET, cb$LAYOUT.byteSize());
    }

    private static final OfDouble timeout$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("timeout"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double timeout
     * }
     */
    public static final OfDouble timeout$layout() {
        return timeout$LAYOUT;
    }

    private static final long timeout$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double timeout
     * }
     */
    public static final long timeout$offset() {
        return timeout$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double timeout
     * }
     */
    public static double timeout(MemorySegment struct) {
        return struct.get(timeout$LAYOUT, timeout$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double timeout
     * }
     */
    public static void timeout(MemorySegment struct, double fieldValue) {
        struct.set(timeout$LAYOUT, timeout$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     uint64_t start;
     *     int64_t stride;
     *     uint64_t size;
     * }
     * }
     */
    public static class active_set {

        active_set() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            Ucc.C_LONG.withName("start"),
            Ucc.C_LONG.withName("stride"),
            Ucc.C_LONG.withName("size")
        ).withName("$anon$1890:5");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfLong start$LAYOUT = (OfLong)$LAYOUT.select(groupElement("start"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * uint64_t start
         * }
         */
        public static final OfLong start$layout() {
            return start$LAYOUT;
        }

        private static final long start$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * uint64_t start
         * }
         */
        public static final long start$offset() {
            return start$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * uint64_t start
         * }
         */
        public static long start(MemorySegment struct) {
            return struct.get(start$LAYOUT, start$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * uint64_t start
         * }
         */
        public static void start(MemorySegment struct, long fieldValue) {
            struct.set(start$LAYOUT, start$OFFSET, fieldValue);
        }

        private static final OfLong stride$LAYOUT = (OfLong)$LAYOUT.select(groupElement("stride"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * int64_t stride
         * }
         */
        public static final OfLong stride$layout() {
            return stride$LAYOUT;
        }

        private static final long stride$OFFSET = 8;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * int64_t stride
         * }
         */
        public static final long stride$offset() {
            return stride$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * int64_t stride
         * }
         */
        public static long stride(MemorySegment struct) {
            return struct.get(stride$LAYOUT, stride$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * int64_t stride
         * }
         */
        public static void stride(MemorySegment struct, long fieldValue) {
            struct.set(stride$LAYOUT, stride$OFFSET, fieldValue);
        }

        private static final OfLong size$LAYOUT = (OfLong)$LAYOUT.select(groupElement("size"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * uint64_t size
         * }
         */
        public static final OfLong size$layout() {
            return size$LAYOUT;
        }

        private static final long size$OFFSET = 16;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * uint64_t size
         * }
         */
        public static final long size$offset() {
            return size$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * uint64_t size
         * }
         */
        public static long size(MemorySegment struct) {
            return struct.get(size$LAYOUT, size$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * uint64_t size
         * }
         */
        public static void size(MemorySegment struct, long fieldValue) {
            struct.set(size$LAYOUT, size$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout active_set$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("active_set"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     uint64_t start;
     *     int64_t stride;
     *     uint64_t size;
     * } active_set
     * }
     */
    public static final GroupLayout active_set$layout() {
        return active_set$LAYOUT;
    }

    private static final long active_set$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     uint64_t start;
     *     int64_t stride;
     *     uint64_t size;
     * } active_set
     * }
     */
    public static final long active_set$offset() {
        return active_set$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     uint64_t start;
     *     int64_t stride;
     *     uint64_t size;
     * } active_set
     * }
     */
    public static MemorySegment active_set(MemorySegment struct) {
        return struct.asSlice(active_set$OFFSET, active_set$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     uint64_t start;
     *     int64_t stride;
     *     uint64_t size;
     * } active_set
     * }
     */
    public static void active_set(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, active_set$OFFSET, active_set$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * union {
     *     ucc_mem_map_mem_h local_memh;
     *     ucc_mem_map_mem_h *global_memh;
     * }
     * }
     */
    public static class src_memh {

        src_memh() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
            Ucc.C_POINTER.withName("local_memh"),
            Ucc.C_POINTER.withName("global_memh")
        ).withName("$anon$1895:5");

        /**
         * The layout of this union
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final AddressLayout local_memh$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("local_memh"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h local_memh
         * }
         */
        public static final AddressLayout local_memh$layout() {
            return local_memh$LAYOUT;
        }

        private static final long local_memh$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h local_memh
         * }
         */
        public static final long local_memh$offset() {
            return local_memh$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h local_memh
         * }
         */
        public static MemorySegment local_memh(MemorySegment union) {
            return union.get(local_memh$LAYOUT, local_memh$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h local_memh
         * }
         */
        public static void local_memh(MemorySegment union, MemorySegment fieldValue) {
            union.set(local_memh$LAYOUT, local_memh$OFFSET, fieldValue);
        }

        private static final AddressLayout global_memh$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("global_memh"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h *global_memh
         * }
         */
        public static final AddressLayout global_memh$layout() {
            return global_memh$LAYOUT;
        }

        private static final long global_memh$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h *global_memh
         * }
         */
        public static final long global_memh$offset() {
            return global_memh$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h *global_memh
         * }
         */
        public static MemorySegment global_memh(MemorySegment union) {
            return union.get(global_memh$LAYOUT, global_memh$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h *global_memh
         * }
         */
        public static void global_memh(MemorySegment union, MemorySegment fieldValue) {
            union.set(global_memh$LAYOUT, global_memh$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this union
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout src_memh$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("src_memh"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * union {
     *     ucc_mem_map_mem_h local_memh;
     *     ucc_mem_map_mem_h *global_memh;
     * } src_memh
     * }
     */
    public static final GroupLayout src_memh$layout() {
        return src_memh$LAYOUT;
    }

    private static final long src_memh$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * union {
     *     ucc_mem_map_mem_h local_memh;
     *     ucc_mem_map_mem_h *global_memh;
     * } src_memh
     * }
     */
    public static final long src_memh$offset() {
        return src_memh$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * union {
     *     ucc_mem_map_mem_h local_memh;
     *     ucc_mem_map_mem_h *global_memh;
     * } src_memh
     * }
     */
    public static MemorySegment src_memh(MemorySegment struct) {
        return struct.asSlice(src_memh$OFFSET, src_memh$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * union {
     *     ucc_mem_map_mem_h local_memh;
     *     ucc_mem_map_mem_h *global_memh;
     * } src_memh
     * }
     */
    public static void src_memh(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, src_memh$OFFSET, src_memh$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * union {
     *     ucc_mem_map_mem_h local_memh;
     *     ucc_mem_map_mem_h *global_memh;
     * }
     * }
     */
    public static class dst_memh {

        dst_memh() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.unionLayout(
            Ucc.C_POINTER.withName("local_memh"),
            Ucc.C_POINTER.withName("global_memh")
        ).withName("$anon$1905:5");

        /**
         * The layout of this union
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final AddressLayout local_memh$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("local_memh"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h local_memh
         * }
         */
        public static final AddressLayout local_memh$layout() {
            return local_memh$LAYOUT;
        }

        private static final long local_memh$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h local_memh
         * }
         */
        public static final long local_memh$offset() {
            return local_memh$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h local_memh
         * }
         */
        public static MemorySegment local_memh(MemorySegment union) {
            return union.get(local_memh$LAYOUT, local_memh$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h local_memh
         * }
         */
        public static void local_memh(MemorySegment union, MemorySegment fieldValue) {
            union.set(local_memh$LAYOUT, local_memh$OFFSET, fieldValue);
        }

        private static final AddressLayout global_memh$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("global_memh"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h *global_memh
         * }
         */
        public static final AddressLayout global_memh$layout() {
            return global_memh$LAYOUT;
        }

        private static final long global_memh$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h *global_memh
         * }
         */
        public static final long global_memh$offset() {
            return global_memh$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h *global_memh
         * }
         */
        public static MemorySegment global_memh(MemorySegment union) {
            return union.get(global_memh$LAYOUT, global_memh$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * ucc_mem_map_mem_h *global_memh
         * }
         */
        public static void global_memh(MemorySegment union, MemorySegment fieldValue) {
            union.set(global_memh$LAYOUT, global_memh$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this union
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout dst_memh$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("dst_memh"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * union {
     *     ucc_mem_map_mem_h local_memh;
     *     ucc_mem_map_mem_h *global_memh;
     * } dst_memh
     * }
     */
    public static final GroupLayout dst_memh$layout() {
        return dst_memh$LAYOUT;
    }

    private static final long dst_memh$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * union {
     *     ucc_mem_map_mem_h local_memh;
     *     ucc_mem_map_mem_h *global_memh;
     * } dst_memh
     * }
     */
    public static final long dst_memh$offset() {
        return dst_memh$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * union {
     *     ucc_mem_map_mem_h local_memh;
     *     ucc_mem_map_mem_h *global_memh;
     * } dst_memh
     * }
     */
    public static MemorySegment dst_memh(MemorySegment struct) {
        return struct.asSlice(dst_memh$OFFSET, dst_memh$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * union {
     *     ucc_mem_map_mem_h local_memh;
     *     ucc_mem_map_mem_h *global_memh;
     * } dst_memh
     * }
     */
    public static void dst_memh(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, dst_memh$OFFSET, dst_memh$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

