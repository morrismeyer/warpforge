// Generated by jextract

package io.surfworks.warpforge.io.ffi.ibverbs;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Ibverbs_1 {

    Ibverbs_1() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("ibverbs"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int _STDINT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDINT_H 1
     * }
     */
    public static int _STDINT_H() {
        return _STDINT_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)35L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 35
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int _BITS_WCHAR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_WCHAR_H 1
     * }
     */
    public static int _BITS_WCHAR_H() {
        return _BITS_WCHAR_H;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int _BITS_STDINT_UINTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_UINTN_H 1
     * }
     */
    public static int _BITS_STDINT_UINTN_H() {
        return _BITS_STDINT_UINTN_H;
    }
    private static final int _PTHREAD_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_H 1
     * }
     */
    public static int _PTHREAD_H() {
        return _PTHREAD_H;
    }
    private static final int _SCHED_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SCHED_H 1
     * }
     */
    public static int _SCHED_H() {
        return _SCHED_H;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_SCHED_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_SCHED_H 1
     * }
     */
    public static int _BITS_SCHED_H() {
        return _BITS_SCHED_H;
    }
    private static final int SCHED_OTHER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SCHED_OTHER 0
     * }
     */
    public static int SCHED_OTHER() {
        return SCHED_OTHER;
    }
    private static final int SCHED_FIFO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SCHED_FIFO 1
     * }
     */
    public static int SCHED_FIFO() {
        return SCHED_FIFO;
    }
    private static final int SCHED_RR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SCHED_RR 2
     * }
     */
    public static int SCHED_RR() {
        return SCHED_RR;
    }
    private static final int _BITS_TYPES_STRUCT_SCHED_PARAM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_STRUCT_SCHED_PARAM 1
     * }
     */
    public static int _BITS_TYPES_STRUCT_SCHED_PARAM() {
        return _BITS_TYPES_STRUCT_SCHED_PARAM;
    }
    private static final int _BITS_CPU_SET_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_CPU_SET_H 1
     * }
     */
    public static int _BITS_CPU_SET_H() {
        return _BITS_CPU_SET_H;
    }
    private static final int __CPU_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __CPU_SETSIZE 1024
     * }
     */
    public static int __CPU_SETSIZE() {
        return __CPU_SETSIZE;
    }
    private static final int _TIME_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _TIME_H 1
     * }
     */
    public static int _TIME_H() {
        return _TIME_H;
    }
    private static final int _BITS_TIME_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME_H 1
     * }
     */
    public static int _BITS_TIME_H() {
        return _BITS_TIME_H;
    }
    private static final int CLOCK_REALTIME = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME 0
     * }
     */
    public static int CLOCK_REALTIME() {
        return CLOCK_REALTIME;
    }
    private static final int CLOCK_MONOTONIC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC 1
     * }
     */
    public static int CLOCK_MONOTONIC() {
        return CLOCK_MONOTONIC;
    }
    private static final int CLOCK_PROCESS_CPUTIME_ID = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_PROCESS_CPUTIME_ID 2
     * }
     */
    public static int CLOCK_PROCESS_CPUTIME_ID() {
        return CLOCK_PROCESS_CPUTIME_ID;
    }
    private static final int CLOCK_THREAD_CPUTIME_ID = (int)3L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_THREAD_CPUTIME_ID 3
     * }
     */
    public static int CLOCK_THREAD_CPUTIME_ID() {
        return CLOCK_THREAD_CPUTIME_ID;
    }
    private static final int CLOCK_MONOTONIC_RAW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_RAW 4
     * }
     */
    public static int CLOCK_MONOTONIC_RAW() {
        return CLOCK_MONOTONIC_RAW;
    }
    private static final int CLOCK_REALTIME_COARSE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME_COARSE 5
     * }
     */
    public static int CLOCK_REALTIME_COARSE() {
        return CLOCK_REALTIME_COARSE;
    }
    private static final int CLOCK_MONOTONIC_COARSE = (int)6L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_COARSE 6
     * }
     */
    public static int CLOCK_MONOTONIC_COARSE() {
        return CLOCK_MONOTONIC_COARSE;
    }
    private static final int CLOCK_BOOTTIME = (int)7L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_BOOTTIME 7
     * }
     */
    public static int CLOCK_BOOTTIME() {
        return CLOCK_BOOTTIME;
    }
    private static final int CLOCK_REALTIME_ALARM = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME_ALARM 8
     * }
     */
    public static int CLOCK_REALTIME_ALARM() {
        return CLOCK_REALTIME_ALARM;
    }
    private static final int CLOCK_BOOTTIME_ALARM = (int)9L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_BOOTTIME_ALARM 9
     * }
     */
    public static int CLOCK_BOOTTIME_ALARM() {
        return CLOCK_BOOTTIME_ALARM;
    }
    private static final int CLOCK_TAI = (int)11L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_TAI 11
     * }
     */
    public static int CLOCK_TAI() {
        return CLOCK_TAI;
    }
    private static final int TIMER_ABSTIME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIMER_ABSTIME 1
     * }
     */
    public static int TIMER_ABSTIME() {
        return TIMER_ABSTIME;
    }
    private static final int __clock_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clock_t_defined 1
     * }
     */
    public static int __clock_t_defined() {
        return __clock_t_defined;
    }
    private static final int __struct_tm_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_tm_defined 1
     * }
     */
    public static int __struct_tm_defined() {
        return __struct_tm_defined;
    }
    private static final int __clockid_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clockid_t_defined 1
     * }
     */
    public static int __clockid_t_defined() {
        return __clockid_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int __itimerspec_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __itimerspec_defined 1
     * }
     */
    public static int __itimerspec_defined() {
        return __itimerspec_defined;
    }
    private static final int _BITS_TYPES_LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES_LOCALE_T_H() {
        return _BITS_TYPES_LOCALE_T_H;
    }
    private static final int _BITS_TYPES___LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES___LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES___LOCALE_T_H() {
        return _BITS_TYPES___LOCALE_T_H;
    }
    private static final int TIME_UTC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIME_UTC 1
     * }
     */
    public static int TIME_UTC() {
        return TIME_UTC;
    }
    private static final int _BITS_PTHREADTYPES_COMMON_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_COMMON_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return _BITS_PTHREADTYPES_COMMON_H;
    }
    private static final int _THREAD_SHARED_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_SHARED_TYPES_H 1
     * }
     */
    public static int _THREAD_SHARED_TYPES_H() {
        return _THREAD_SHARED_TYPES_H;
    }
    private static final int _BITS_PTHREADTYPES_ARCH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_ARCH_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return _BITS_PTHREADTYPES_ARCH_H;
    }
    private static final int __SIZEOF_PTHREAD_MUTEX_T = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEX_T 40
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return __SIZEOF_PTHREAD_MUTEX_T;
    }
    private static final int __SIZEOF_PTHREAD_ATTR_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_ATTR_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return __SIZEOF_PTHREAD_ATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCK_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCK_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return __SIZEOF_PTHREAD_RWLOCK_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIER_T = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIER_T 32
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return __SIZEOF_PTHREAD_BARRIER_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEXATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEXATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return __SIZEOF_PTHREAD_MUTEXATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_COND_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_COND_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_COND_T() {
        return __SIZEOF_PTHREAD_COND_T;
    }
    private static final int __SIZEOF_PTHREAD_CONDATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_CONDATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return __SIZEOF_PTHREAD_CONDATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCKATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return __SIZEOF_PTHREAD_RWLOCKATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIERATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIERATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return __SIZEOF_PTHREAD_BARRIERATTR_T;
    }
    private static final int _THREAD_MUTEX_INTERNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_MUTEX_INTERNAL_H 1
     * }
     */
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return _THREAD_MUTEX_INTERNAL_H;
    }
    private static final int __PTHREAD_MUTEX_HAVE_PREV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_HAVE_PREV 1
     * }
     */
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return __PTHREAD_MUTEX_HAVE_PREV;
    }
    private static final int __have_pthread_attr_t = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __have_pthread_attr_t 1
     * }
     */
    public static int __have_pthread_attr_t() {
        return __have_pthread_attr_t;
    }
    private static final int _BITS_SETJMP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_SETJMP_H 1
     * }
     */
    public static int _BITS_SETJMP_H() {
        return _BITS_SETJMP_H;
    }
    private static final int __jmp_buf_tag_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __jmp_buf_tag_defined 1
     * }
     */
    public static int __jmp_buf_tag_defined() {
        return __jmp_buf_tag_defined;
    }
    private static final int PTHREAD_STACK_MIN = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_STACK_MIN 16384
     * }
     */
    public static int PTHREAD_STACK_MIN() {
        return PTHREAD_STACK_MIN;
    }
    private static final int PTHREAD_ONCE_INIT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_ONCE_INIT 0
     * }
     */
    public static int PTHREAD_ONCE_INIT() {
        return PTHREAD_ONCE_INIT;
    }
    private static final int _ERRNO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ERRNO_H 1
     * }
     */
    public static int _ERRNO_H() {
        return _ERRNO_H;
    }
    private static final int _BITS_ERRNO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ERRNO_H 1
     * }
     */
    public static int _BITS_ERRNO_H() {
        return _BITS_ERRNO_H;
    }
    private static final int EPERM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EPERM 1
     * }
     */
    public static int EPERM() {
        return EPERM;
    }
    private static final int ENOENT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ENOENT 2
     * }
     */
    public static int ENOENT() {
        return ENOENT;
    }
    private static final int ESRCH = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ESRCH 3
     * }
     */
    public static int ESRCH() {
        return ESRCH;
    }
    private static final int EINTR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EINTR 4
     * }
     */
    public static int EINTR() {
        return EINTR;
    }
    private static final int EIO = (int)5L;
    /**
     * {@snippet lang=c :
     * #define EIO 5
     * }
     */
    public static int EIO() {
        return EIO;
    }
    private static final int ENXIO = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ENXIO 6
     * }
     */
    public static int ENXIO() {
        return ENXIO;
    }
    private static final int E2BIG = (int)7L;
    /**
     * {@snippet lang=c :
     * #define E2BIG 7
     * }
     */
    public static int E2BIG() {
        return E2BIG;
    }
    private static final int ENOEXEC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ENOEXEC 8
     * }
     */
    public static int ENOEXEC() {
        return ENOEXEC;
    }
    private static final int EBADF = (int)9L;
    /**
     * {@snippet lang=c :
     * #define EBADF 9
     * }
     */
    public static int EBADF() {
        return EBADF;
    }
    private static final int ECHILD = (int)10L;
    /**
     * {@snippet lang=c :
     * #define ECHILD 10
     * }
     */
    public static int ECHILD() {
        return ECHILD;
    }
    private static final int EAGAIN = (int)11L;
    /**
     * {@snippet lang=c :
     * #define EAGAIN 11
     * }
     */
    public static int EAGAIN() {
        return EAGAIN;
    }
    private static final int ENOMEM = (int)12L;
    /**
     * {@snippet lang=c :
     * #define ENOMEM 12
     * }
     */
    public static int ENOMEM() {
        return ENOMEM;
    }
    private static final int EACCES = (int)13L;
    /**
     * {@snippet lang=c :
     * #define EACCES 13
     * }
     */
    public static int EACCES() {
        return EACCES;
    }
    private static final int EFAULT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define EFAULT 14
     * }
     */
    public static int EFAULT() {
        return EFAULT;
    }
    private static final int ENOTBLK = (int)15L;
    /**
     * {@snippet lang=c :
     * #define ENOTBLK 15
     * }
     */
    public static int ENOTBLK() {
        return ENOTBLK;
    }
    private static final int EBUSY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EBUSY 16
     * }
     */
    public static int EBUSY() {
        return EBUSY;
    }
    private static final int EEXIST = (int)17L;
    /**
     * {@snippet lang=c :
     * #define EEXIST 17
     * }
     */
    public static int EEXIST() {
        return EEXIST;
    }
    private static final int EXDEV = (int)18L;
    /**
     * {@snippet lang=c :
     * #define EXDEV 18
     * }
     */
    public static int EXDEV() {
        return EXDEV;
    }
    private static final int ENODEV = (int)19L;
    /**
     * {@snippet lang=c :
     * #define ENODEV 19
     * }
     */
    public static int ENODEV() {
        return ENODEV;
    }
    private static final int ENOTDIR = (int)20L;
    /**
     * {@snippet lang=c :
     * #define ENOTDIR 20
     * }
     */
    public static int ENOTDIR() {
        return ENOTDIR;
    }
    private static final int EISDIR = (int)21L;
    /**
     * {@snippet lang=c :
     * #define EISDIR 21
     * }
     */
    public static int EISDIR() {
        return EISDIR;
    }
    private static final int EINVAL = (int)22L;
    /**
     * {@snippet lang=c :
     * #define EINVAL 22
     * }
     */
    public static int EINVAL() {
        return EINVAL;
    }
    private static final int ENFILE = (int)23L;
    /**
     * {@snippet lang=c :
     * #define ENFILE 23
     * }
     */
    public static int ENFILE() {
        return ENFILE;
    }
    private static final int EMFILE = (int)24L;
    /**
     * {@snippet lang=c :
     * #define EMFILE 24
     * }
     */
    public static int EMFILE() {
        return EMFILE;
    }
    private static final int ENOTTY = (int)25L;
    /**
     * {@snippet lang=c :
     * #define ENOTTY 25
     * }
     */
    public static int ENOTTY() {
        return ENOTTY;
    }
    private static final int ETXTBSY = (int)26L;
    /**
     * {@snippet lang=c :
     * #define ETXTBSY 26
     * }
     */
    public static int ETXTBSY() {
        return ETXTBSY;
    }
    private static final int EFBIG = (int)27L;
    /**
     * {@snippet lang=c :
     * #define EFBIG 27
     * }
     */
    public static int EFBIG() {
        return EFBIG;
    }
    private static final int ENOSPC = (int)28L;
    /**
     * {@snippet lang=c :
     * #define ENOSPC 28
     * }
     */
    public static int ENOSPC() {
        return ENOSPC;
    }
    private static final int ESPIPE = (int)29L;
    /**
     * {@snippet lang=c :
     * #define ESPIPE 29
     * }
     */
    public static int ESPIPE() {
        return ESPIPE;
    }
    private static final int EROFS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define EROFS 30
     * }
     */
    public static int EROFS() {
        return EROFS;
    }
    private static final int EMLINK = (int)31L;
    /**
     * {@snippet lang=c :
     * #define EMLINK 31
     * }
     */
    public static int EMLINK() {
        return EMLINK;
    }
    private static final int EPIPE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EPIPE 32
     * }
     */
    public static int EPIPE() {
        return EPIPE;
    }
    private static final int EDOM = (int)33L;
    /**
     * {@snippet lang=c :
     * #define EDOM 33
     * }
     */
    public static int EDOM() {
        return EDOM;
    }
    private static final int ERANGE = (int)34L;
    /**
     * {@snippet lang=c :
     * #define ERANGE 34
     * }
     */
    public static int ERANGE() {
        return ERANGE;
    }
    private static final int EDEADLK = (int)35L;
    /**
     * {@snippet lang=c :
     * #define EDEADLK 35
     * }
     */
    public static int EDEADLK() {
        return EDEADLK;
    }
    private static final int ENAMETOOLONG = (int)36L;
    /**
     * {@snippet lang=c :
     * #define ENAMETOOLONG 36
     * }
     */
    public static int ENAMETOOLONG() {
        return ENAMETOOLONG;
    }
    private static final int ENOLCK = (int)37L;
    /**
     * {@snippet lang=c :
     * #define ENOLCK 37
     * }
     */
    public static int ENOLCK() {
        return ENOLCK;
    }
    private static final int ENOSYS = (int)38L;
    /**
     * {@snippet lang=c :
     * #define ENOSYS 38
     * }
     */
    public static int ENOSYS() {
        return ENOSYS;
    }
    private static final int ENOTEMPTY = (int)39L;
    /**
     * {@snippet lang=c :
     * #define ENOTEMPTY 39
     * }
     */
    public static int ENOTEMPTY() {
        return ENOTEMPTY;
    }
    private static final int ELOOP = (int)40L;
    /**
     * {@snippet lang=c :
     * #define ELOOP 40
     * }
     */
    public static int ELOOP() {
        return ELOOP;
    }
    private static final int ENOMSG = (int)42L;
    /**
     * {@snippet lang=c :
     * #define ENOMSG 42
     * }
     */
    public static int ENOMSG() {
        return ENOMSG;
    }
    private static final int EIDRM = (int)43L;
    /**
     * {@snippet lang=c :
     * #define EIDRM 43
     * }
     */
    public static int EIDRM() {
        return EIDRM;
    }
    private static final int ECHRNG = (int)44L;
    /**
     * {@snippet lang=c :
     * #define ECHRNG 44
     * }
     */
    public static int ECHRNG() {
        return ECHRNG;
    }
    private static final int EL2NSYNC = (int)45L;
    /**
     * {@snippet lang=c :
     * #define EL2NSYNC 45
     * }
     */
    public static int EL2NSYNC() {
        return EL2NSYNC;
    }
    private static final int EL3HLT = (int)46L;
    /**
     * {@snippet lang=c :
     * #define EL3HLT 46
     * }
     */
    public static int EL3HLT() {
        return EL3HLT;
    }
    private static final int EL3RST = (int)47L;
    /**
     * {@snippet lang=c :
     * #define EL3RST 47
     * }
     */
    public static int EL3RST() {
        return EL3RST;
    }
    private static final int ELNRNG = (int)48L;
    /**
     * {@snippet lang=c :
     * #define ELNRNG 48
     * }
     */
    public static int ELNRNG() {
        return ELNRNG;
    }
    private static final int EUNATCH = (int)49L;
    /**
     * {@snippet lang=c :
     * #define EUNATCH 49
     * }
     */
    public static int EUNATCH() {
        return EUNATCH;
    }
    private static final int ENOCSI = (int)50L;
    /**
     * {@snippet lang=c :
     * #define ENOCSI 50
     * }
     */
    public static int ENOCSI() {
        return ENOCSI;
    }
    private static final int EL2HLT = (int)51L;
    /**
     * {@snippet lang=c :
     * #define EL2HLT 51
     * }
     */
    public static int EL2HLT() {
        return EL2HLT;
    }
    private static final int EBADE = (int)52L;
    /**
     * {@snippet lang=c :
     * #define EBADE 52
     * }
     */
    public static int EBADE() {
        return EBADE;
    }
    private static final int EBADR = (int)53L;
    /**
     * {@snippet lang=c :
     * #define EBADR 53
     * }
     */
    public static int EBADR() {
        return EBADR;
    }
    private static final int EXFULL = (int)54L;
    /**
     * {@snippet lang=c :
     * #define EXFULL 54
     * }
     */
    public static int EXFULL() {
        return EXFULL;
    }
    private static final int ENOANO = (int)55L;
    /**
     * {@snippet lang=c :
     * #define ENOANO 55
     * }
     */
    public static int ENOANO() {
        return ENOANO;
    }
    private static final int EBADRQC = (int)56L;
    /**
     * {@snippet lang=c :
     * #define EBADRQC 56
     * }
     */
    public static int EBADRQC() {
        return EBADRQC;
    }
    private static final int EBADSLT = (int)57L;
    /**
     * {@snippet lang=c :
     * #define EBADSLT 57
     * }
     */
    public static int EBADSLT() {
        return EBADSLT;
    }
    private static final int EBFONT = (int)59L;
    /**
     * {@snippet lang=c :
     * #define EBFONT 59
     * }
     */
    public static int EBFONT() {
        return EBFONT;
    }
    private static final int ENOSTR = (int)60L;
    /**
     * {@snippet lang=c :
     * #define ENOSTR 60
     * }
     */
    public static int ENOSTR() {
        return ENOSTR;
    }
    private static final int ENODATA = (int)61L;
    /**
     * {@snippet lang=c :
     * #define ENODATA 61
     * }
     */
    public static int ENODATA() {
        return ENODATA;
    }
    private static final int ETIME = (int)62L;
    /**
     * {@snippet lang=c :
     * #define ETIME 62
     * }
     */
    public static int ETIME() {
        return ETIME;
    }
    private static final int ENOSR = (int)63L;
    /**
     * {@snippet lang=c :
     * #define ENOSR 63
     * }
     */
    public static int ENOSR() {
        return ENOSR;
    }
    private static final int ENONET = (int)64L;
    /**
     * {@snippet lang=c :
     * #define ENONET 64
     * }
     */
    public static int ENONET() {
        return ENONET;
    }
    private static final int ENOPKG = (int)65L;
    /**
     * {@snippet lang=c :
     * #define ENOPKG 65
     * }
     */
    public static int ENOPKG() {
        return ENOPKG;
    }
    private static final int EREMOTE = (int)66L;
    /**
     * {@snippet lang=c :
     * #define EREMOTE 66
     * }
     */
    public static int EREMOTE() {
        return EREMOTE;
    }
    private static final int ENOLINK = (int)67L;
    /**
     * {@snippet lang=c :
     * #define ENOLINK 67
     * }
     */
    public static int ENOLINK() {
        return ENOLINK;
    }
    private static final int EADV = (int)68L;
    /**
     * {@snippet lang=c :
     * #define EADV 68
     * }
     */
    public static int EADV() {
        return EADV;
    }
    private static final int ESRMNT = (int)69L;
    /**
     * {@snippet lang=c :
     * #define ESRMNT 69
     * }
     */
    public static int ESRMNT() {
        return ESRMNT;
    }
    private static final int ECOMM = (int)70L;
    /**
     * {@snippet lang=c :
     * #define ECOMM 70
     * }
     */
    public static int ECOMM() {
        return ECOMM;
    }
    private static final int EPROTO = (int)71L;
    /**
     * {@snippet lang=c :
     * #define EPROTO 71
     * }
     */
    public static int EPROTO() {
        return EPROTO;
    }
    private static final int EMULTIHOP = (int)72L;
    /**
     * {@snippet lang=c :
     * #define EMULTIHOP 72
     * }
     */
    public static int EMULTIHOP() {
        return EMULTIHOP;
    }
    private static final int EDOTDOT = (int)73L;
    /**
     * {@snippet lang=c :
     * #define EDOTDOT 73
     * }
     */
    public static int EDOTDOT() {
        return EDOTDOT;
    }
    private static final int EBADMSG = (int)74L;
    /**
     * {@snippet lang=c :
     * #define EBADMSG 74
     * }
     */
    public static int EBADMSG() {
        return EBADMSG;
    }
    private static final int EOVERFLOW = (int)75L;
    /**
     * {@snippet lang=c :
     * #define EOVERFLOW 75
     * }
     */
    public static int EOVERFLOW() {
        return EOVERFLOW;
    }
    private static final int ENOTUNIQ = (int)76L;
    /**
     * {@snippet lang=c :
     * #define ENOTUNIQ 76
     * }
     */
    public static int ENOTUNIQ() {
        return ENOTUNIQ;
    }
    private static final int EBADFD = (int)77L;
    /**
     * {@snippet lang=c :
     * #define EBADFD 77
     * }
     */
    public static int EBADFD() {
        return EBADFD;
    }
    private static final int EREMCHG = (int)78L;
    /**
     * {@snippet lang=c :
     * #define EREMCHG 78
     * }
     */
    public static int EREMCHG() {
        return EREMCHG;
    }
    private static final int ELIBACC = (int)79L;
    /**
     * {@snippet lang=c :
     * #define ELIBACC 79
     * }
     */
    public static int ELIBACC() {
        return ELIBACC;
    }
    private static final int ELIBBAD = (int)80L;
    /**
     * {@snippet lang=c :
     * #define ELIBBAD 80
     * }
     */
    public static int ELIBBAD() {
        return ELIBBAD;
    }
    private static final int ELIBSCN = (int)81L;
    /**
     * {@snippet lang=c :
     * #define ELIBSCN 81
     * }
     */
    public static int ELIBSCN() {
        return ELIBSCN;
    }
    private static final int ELIBMAX = (int)82L;
    /**
     * {@snippet lang=c :
     * #define ELIBMAX 82
     * }
     */
    public static int ELIBMAX() {
        return ELIBMAX;
    }
    private static final int ELIBEXEC = (int)83L;
    /**
     * {@snippet lang=c :
     * #define ELIBEXEC 83
     * }
     */
    public static int ELIBEXEC() {
        return ELIBEXEC;
    }
    private static final int EILSEQ = (int)84L;
    /**
     * {@snippet lang=c :
     * #define EILSEQ 84
     * }
     */
    public static int EILSEQ() {
        return EILSEQ;
    }
    private static final int ERESTART = (int)85L;
    /**
     * {@snippet lang=c :
     * #define ERESTART 85
     * }
     */
    public static int ERESTART() {
        return ERESTART;
    }
    private static final int ESTRPIPE = (int)86L;
    /**
     * {@snippet lang=c :
     * #define ESTRPIPE 86
     * }
     */
    public static int ESTRPIPE() {
        return ESTRPIPE;
    }
    private static final int EUSERS = (int)87L;
    /**
     * {@snippet lang=c :
     * #define EUSERS 87
     * }
     */
    public static int EUSERS() {
        return EUSERS;
    }
    private static final int ENOTSOCK = (int)88L;
    /**
     * {@snippet lang=c :
     * #define ENOTSOCK 88
     * }
     */
    public static int ENOTSOCK() {
        return ENOTSOCK;
    }
    private static final int EDESTADDRREQ = (int)89L;
    /**
     * {@snippet lang=c :
     * #define EDESTADDRREQ 89
     * }
     */
    public static int EDESTADDRREQ() {
        return EDESTADDRREQ;
    }
    private static final int EMSGSIZE = (int)90L;
    /**
     * {@snippet lang=c :
     * #define EMSGSIZE 90
     * }
     */
    public static int EMSGSIZE() {
        return EMSGSIZE;
    }
    private static final int EPROTOTYPE = (int)91L;
    /**
     * {@snippet lang=c :
     * #define EPROTOTYPE 91
     * }
     */
    public static int EPROTOTYPE() {
        return EPROTOTYPE;
    }
    private static final int ENOPROTOOPT = (int)92L;
    /**
     * {@snippet lang=c :
     * #define ENOPROTOOPT 92
     * }
     */
    public static int ENOPROTOOPT() {
        return ENOPROTOOPT;
    }
    private static final int EPROTONOSUPPORT = (int)93L;
    /**
     * {@snippet lang=c :
     * #define EPROTONOSUPPORT 93
     * }
     */
    public static int EPROTONOSUPPORT() {
        return EPROTONOSUPPORT;
    }
    private static final int ESOCKTNOSUPPORT = (int)94L;
    /**
     * {@snippet lang=c :
     * #define ESOCKTNOSUPPORT 94
     * }
     */
    public static int ESOCKTNOSUPPORT() {
        return ESOCKTNOSUPPORT;
    }
    private static final int EOPNOTSUPP = (int)95L;
    /**
     * {@snippet lang=c :
     * #define EOPNOTSUPP 95
     * }
     */
    public static int EOPNOTSUPP() {
        return EOPNOTSUPP;
    }
    private static final int EPFNOSUPPORT = (int)96L;
    /**
     * {@snippet lang=c :
     * #define EPFNOSUPPORT 96
     * }
     */
    public static int EPFNOSUPPORT() {
        return EPFNOSUPPORT;
    }
    private static final int EAFNOSUPPORT = (int)97L;
    /**
     * {@snippet lang=c :
     * #define EAFNOSUPPORT 97
     * }
     */
    public static int EAFNOSUPPORT() {
        return EAFNOSUPPORT;
    }
    private static final int EADDRINUSE = (int)98L;
    /**
     * {@snippet lang=c :
     * #define EADDRINUSE 98
     * }
     */
    public static int EADDRINUSE() {
        return EADDRINUSE;
    }
    private static final int EADDRNOTAVAIL = (int)99L;
    /**
     * {@snippet lang=c :
     * #define EADDRNOTAVAIL 99
     * }
     */
    public static int EADDRNOTAVAIL() {
        return EADDRNOTAVAIL;
    }
    private static final int ENETDOWN = (int)100L;
    /**
     * {@snippet lang=c :
     * #define ENETDOWN 100
     * }
     */
    public static int ENETDOWN() {
        return ENETDOWN;
    }
    private static final int ENETUNREACH = (int)101L;
    /**
     * {@snippet lang=c :
     * #define ENETUNREACH 101
     * }
     */
    public static int ENETUNREACH() {
        return ENETUNREACH;
    }
    private static final int ENETRESET = (int)102L;
    /**
     * {@snippet lang=c :
     * #define ENETRESET 102
     * }
     */
    public static int ENETRESET() {
        return ENETRESET;
    }
    private static final int ECONNABORTED = (int)103L;
    /**
     * {@snippet lang=c :
     * #define ECONNABORTED 103
     * }
     */
    public static int ECONNABORTED() {
        return ECONNABORTED;
    }
    private static final int ECONNRESET = (int)104L;
    /**
     * {@snippet lang=c :
     * #define ECONNRESET 104
     * }
     */
    public static int ECONNRESET() {
        return ECONNRESET;
    }
    private static final int ENOBUFS = (int)105L;
    /**
     * {@snippet lang=c :
     * #define ENOBUFS 105
     * }
     */
    public static int ENOBUFS() {
        return ENOBUFS;
    }
    private static final int EISCONN = (int)106L;
    /**
     * {@snippet lang=c :
     * #define EISCONN 106
     * }
     */
    public static int EISCONN() {
        return EISCONN;
    }
    private static final int ENOTCONN = (int)107L;
    /**
     * {@snippet lang=c :
     * #define ENOTCONN 107
     * }
     */
    public static int ENOTCONN() {
        return ENOTCONN;
    }
    private static final int ESHUTDOWN = (int)108L;
    /**
     * {@snippet lang=c :
     * #define ESHUTDOWN 108
     * }
     */
    public static int ESHUTDOWN() {
        return ESHUTDOWN;
    }
    private static final int ETOOMANYREFS = (int)109L;
    /**
     * {@snippet lang=c :
     * #define ETOOMANYREFS 109
     * }
     */
    public static int ETOOMANYREFS() {
        return ETOOMANYREFS;
    }
    private static final int ETIMEDOUT = (int)110L;
    /**
     * {@snippet lang=c :
     * #define ETIMEDOUT 110
     * }
     */
    public static int ETIMEDOUT() {
        return ETIMEDOUT;
    }
    private static final int ECONNREFUSED = (int)111L;
    /**
     * {@snippet lang=c :
     * #define ECONNREFUSED 111
     * }
     */
    public static int ECONNREFUSED() {
        return ECONNREFUSED;
    }
    private static final int EHOSTDOWN = (int)112L;
    /**
     * {@snippet lang=c :
     * #define EHOSTDOWN 112
     * }
     */
    public static int EHOSTDOWN() {
        return EHOSTDOWN;
    }
    private static final int EHOSTUNREACH = (int)113L;
    /**
     * {@snippet lang=c :
     * #define EHOSTUNREACH 113
     * }
     */
    public static int EHOSTUNREACH() {
        return EHOSTUNREACH;
    }
    private static final int EALREADY = (int)114L;
    /**
     * {@snippet lang=c :
     * #define EALREADY 114
     * }
     */
    public static int EALREADY() {
        return EALREADY;
    }
    private static final int EINPROGRESS = (int)115L;
    /**
     * {@snippet lang=c :
     * #define EINPROGRESS 115
     * }
     */
    public static int EINPROGRESS() {
        return EINPROGRESS;
    }
    private static final int ESTALE = (int)116L;
    /**
     * {@snippet lang=c :
     * #define ESTALE 116
     * }
     */
    public static int ESTALE() {
        return ESTALE;
    }
    private static final int EUCLEAN = (int)117L;
    /**
     * {@snippet lang=c :
     * #define EUCLEAN 117
     * }
     */
    public static int EUCLEAN() {
        return EUCLEAN;
    }
    private static final int ENOTNAM = (int)118L;
    /**
     * {@snippet lang=c :
     * #define ENOTNAM 118
     * }
     */
    public static int ENOTNAM() {
        return ENOTNAM;
    }
    private static final int ENAVAIL = (int)119L;
    /**
     * {@snippet lang=c :
     * #define ENAVAIL 119
     * }
     */
    public static int ENAVAIL() {
        return ENAVAIL;
    }
    private static final int EISNAM = (int)120L;
    /**
     * {@snippet lang=c :
     * #define EISNAM 120
     * }
     */
    public static int EISNAM() {
        return EISNAM;
    }
    private static final int EREMOTEIO = (int)121L;
    /**
     * {@snippet lang=c :
     * #define EREMOTEIO 121
     * }
     */
    public static int EREMOTEIO() {
        return EREMOTEIO;
    }
    private static final int EDQUOT = (int)122L;
    /**
     * {@snippet lang=c :
     * #define EDQUOT 122
     * }
     */
    public static int EDQUOT() {
        return EDQUOT;
    }
    private static final int ENOMEDIUM = (int)123L;
    /**
     * {@snippet lang=c :
     * #define ENOMEDIUM 123
     * }
     */
    public static int ENOMEDIUM() {
        return ENOMEDIUM;
    }
    private static final int EMEDIUMTYPE = (int)124L;
    /**
     * {@snippet lang=c :
     * #define EMEDIUMTYPE 124
     * }
     */
    public static int EMEDIUMTYPE() {
        return EMEDIUMTYPE;
    }
    private static final int ECANCELED = (int)125L;
    /**
     * {@snippet lang=c :
     * #define ECANCELED 125
     * }
     */
    public static int ECANCELED() {
        return ECANCELED;
    }
    private static final int ENOKEY = (int)126L;
    /**
     * {@snippet lang=c :
     * #define ENOKEY 126
     * }
     */
    public static int ENOKEY() {
        return ENOKEY;
    }
    private static final int EKEYEXPIRED = (int)127L;
    /**
     * {@snippet lang=c :
     * #define EKEYEXPIRED 127
     * }
     */
    public static int EKEYEXPIRED() {
        return EKEYEXPIRED;
    }
    private static final int EKEYREVOKED = (int)128L;
    /**
     * {@snippet lang=c :
     * #define EKEYREVOKED 128
     * }
     */
    public static int EKEYREVOKED() {
        return EKEYREVOKED;
    }
    private static final int EKEYREJECTED = (int)129L;
    /**
     * {@snippet lang=c :
     * #define EKEYREJECTED 129
     * }
     */
    public static int EKEYREJECTED() {
        return EKEYREJECTED;
    }
    private static final int EOWNERDEAD = (int)130L;
    /**
     * {@snippet lang=c :
     * #define EOWNERDEAD 130
     * }
     */
    public static int EOWNERDEAD() {
        return EOWNERDEAD;
    }
    private static final int ENOTRECOVERABLE = (int)131L;
    /**
     * {@snippet lang=c :
     * #define ENOTRECOVERABLE 131
     * }
     */
    public static int ENOTRECOVERABLE() {
        return ENOTRECOVERABLE;
    }
    private static final int ERFKILL = (int)132L;
    /**
     * {@snippet lang=c :
     * #define ERFKILL 132
     * }
     */
    public static int ERFKILL() {
        return ERFKILL;
    }
    private static final int EHWPOISON = (int)133L;
    /**
     * {@snippet lang=c :
     * #define EHWPOISON 133
     * }
     */
    public static int EHWPOISON() {
        return EHWPOISON;
    }
    private static final int _STRING_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRING_H 1
     * }
     */
    public static int _STRING_H() {
        return _STRING_H;
    }
    private static final int _STRINGS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRINGS_H 1
     * }
     */
    public static int _STRINGS_H() {
        return _STRINGS_H;
    }
    private static final int __BITS_PER_LONG = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __BITS_PER_LONG 64
     * }
     */
    public static int __BITS_PER_LONG() {
        return __BITS_PER_LONG;
    }
    private static final int _SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_TYPES_H 1
     * }
     */
    public static int _SYS_TYPES_H() {
        return _SYS_TYPES_H;
    }
    private static final int __BIT_TYPES_DEFINED__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __BIT_TYPES_DEFINED__ 1
     * }
     */
    public static int __BIT_TYPES_DEFINED__() {
        return __BIT_TYPES_DEFINED__;
    }
    private static final int _ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ENDIAN_H 1
     * }
     */
    public static int _ENDIAN_H() {
        return _ENDIAN_H;
    }
    private static final int _BITS_BYTESWAP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_BYTESWAP_H 1
     * }
     */
    public static int _BITS_BYTESWAP_H() {
        return _BITS_BYTESWAP_H;
    }
    private static final int _BITS_UINTN_IDENTITY_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_UINTN_IDENTITY_H 1
     * }
     */
    public static int _BITS_UINTN_IDENTITY_H() {
        return _BITS_UINTN_IDENTITY_H;
    }
    private static final int _SYS_SELECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SELECT_H 1
     * }
     */
    public static int _SYS_SELECT_H() {
        return _SYS_SELECT_H;
    }
    private static final int __sigset_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __sigset_t_defined 1
     * }
     */
    public static int __sigset_t_defined() {
        return __sigset_t_defined;
    }
    private static final int __timeval_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timeval_defined 1
     * }
     */
    public static int __timeval_defined() {
        return __timeval_defined;
    }
    private static final int IB_USER_VERBS_ABI_VERSION = (int)6L;
    /**
     * {@snippet lang=c :
     * #define IB_USER_VERBS_ABI_VERSION 6
     * }
     */
    public static int IB_USER_VERBS_ABI_VERSION() {
        return IB_USER_VERBS_ABI_VERSION;
    }
    private static final int IB_USER_VERBS_CMD_THRESHOLD = (int)50L;
    /**
     * {@snippet lang=c :
     * #define IB_USER_VERBS_CMD_THRESHOLD 50
     * }
     */
    public static int IB_USER_VERBS_CMD_THRESHOLD() {
        return IB_USER_VERBS_CMD_THRESHOLD;
    }
    private static final int IB_USER_VERBS_CMD_COMMAND_MASK = (int)255L;
    /**
     * {@snippet lang=c :
     * #define IB_USER_VERBS_CMD_COMMAND_MASK 255
     * }
     */
    public static int IB_USER_VERBS_CMD_COMMAND_MASK() {
        return IB_USER_VERBS_CMD_COMMAND_MASK;
    }
    private static final int IB_USER_VERBS_MAX_LOG_IND_TBL_SIZE = (int)13L;
    /**
     * {@snippet lang=c :
     * #define IB_USER_VERBS_MAX_LOG_IND_TBL_SIZE 13
     * }
     */
    public static int IB_USER_VERBS_MAX_LOG_IND_TBL_SIZE() {
        return IB_USER_VERBS_MAX_LOG_IND_TBL_SIZE;
    }
    private static final int IB_DEVICE_NAME_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define IB_DEVICE_NAME_MAX 64
     * }
     */
    public static int IB_DEVICE_NAME_MAX() {
        return IB_DEVICE_NAME_MAX;
    }
    private static final int ETHERNET_LL_SIZE = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ETHERNET_LL_SIZE 6
     * }
     */
    public static int ETHERNET_LL_SIZE() {
        return ETHERNET_LL_SIZE;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = Ibverbs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = Ibverbs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = Ibverbs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = Ibverbs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = Ibverbs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = Ibverbs.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = Ibverbs.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = Ibverbs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = Ibverbs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = Ibverbs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = Ibverbs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = Ibverbs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = Ibverbs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __cpu_mask
     * }
     */
    public static final OfLong __cpu_mask = Ibverbs.C_LONG;

    private static class __sched_cpucount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("__sched_cpucount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static FunctionDescriptor __sched_cpucount$descriptor() {
        return __sched_cpucount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static MethodHandle __sched_cpucount$handle() {
        return __sched_cpucount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static MemorySegment __sched_cpucount$address() {
        return __sched_cpucount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static int __sched_cpucount(long __setsize, MemorySegment __setp) {
        var mh$ = __sched_cpucount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpucount", __setsize, __setp);
            }
            return (int)mh$.invokeExact(__setsize, __setp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sched_cpualloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("__sched_cpualloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static FunctionDescriptor __sched_cpualloc$descriptor() {
        return __sched_cpualloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MethodHandle __sched_cpualloc$handle() {
        return __sched_cpualloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MemorySegment __sched_cpualloc$address() {
        return __sched_cpualloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MemorySegment __sched_cpualloc(long __count) {
        var mh$ = __sched_cpualloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpualloc", __count);
            }
            return (MemorySegment)mh$.invokeExact(__count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sched_cpufree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("__sched_cpufree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static FunctionDescriptor __sched_cpufree$descriptor() {
        return __sched_cpufree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static MethodHandle __sched_cpufree$handle() {
        return __sched_cpufree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static MemorySegment __sched_cpufree$address() {
        return __sched_cpufree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static void __sched_cpufree(MemorySegment __set) {
        var mh$ = __sched_cpufree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpufree", __set);
            }
            mh$.invokeExact(__set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_setparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("sched_setparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_setparam$descriptor() {
        return sched_setparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_setparam$handle() {
        return sched_setparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_setparam$address() {
        return sched_setparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static int sched_setparam(int __pid, MemorySegment __param) {
        var mh$ = sched_setparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_setparam", __pid, __param);
            }
            return (int)mh$.invokeExact(__pid, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_getparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("sched_getparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_getparam$descriptor() {
        return sched_getparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_getparam$handle() {
        return sched_getparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_getparam$address() {
        return sched_getparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static int sched_getparam(int __pid, MemorySegment __param) {
        var mh$ = sched_getparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_getparam", __pid, __param);
            }
            return (int)mh$.invokeExact(__pid, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_setscheduler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("sched_setscheduler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_setscheduler$descriptor() {
        return sched_setscheduler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_setscheduler$handle() {
        return sched_setscheduler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_setscheduler$address() {
        return sched_setscheduler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static int sched_setscheduler(int __pid, int __policy, MemorySegment __param) {
        var mh$ = sched_setscheduler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_setscheduler", __pid, __policy, __param);
            }
            return (int)mh$.invokeExact(__pid, __policy, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_getscheduler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("sched_getscheduler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static FunctionDescriptor sched_getscheduler$descriptor() {
        return sched_getscheduler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static MethodHandle sched_getscheduler$handle() {
        return sched_getscheduler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static MemorySegment sched_getscheduler$address() {
        return sched_getscheduler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static int sched_getscheduler(int __pid) {
        var mh$ = sched_getscheduler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_getscheduler", __pid);
            }
            return (int)mh$.invokeExact(__pid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_yield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT    );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("sched_yield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static FunctionDescriptor sched_yield$descriptor() {
        return sched_yield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MethodHandle sched_yield$handle() {
        return sched_yield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MemorySegment sched_yield$address() {
        return sched_yield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static int sched_yield() {
        var mh$ = sched_yield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_yield");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("sched_get_priority_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static FunctionDescriptor sched_get_priority_max$descriptor() {
        return sched_get_priority_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static MethodHandle sched_get_priority_max$handle() {
        return sched_get_priority_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static MemorySegment sched_get_priority_max$address() {
        return sched_get_priority_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static int sched_get_priority_max(int __algorithm) {
        var mh$ = sched_get_priority_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_max", __algorithm);
            }
            return (int)mh$.invokeExact(__algorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("sched_get_priority_min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static FunctionDescriptor sched_get_priority_min$descriptor() {
        return sched_get_priority_min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static MethodHandle sched_get_priority_min$handle() {
        return sched_get_priority_min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static MemorySegment sched_get_priority_min$address() {
        return sched_get_priority_min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static int sched_get_priority_min(int __algorithm) {
        var mh$ = sched_get_priority_min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_min", __algorithm);
            }
            return (int)mh$.invokeExact(__algorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_rr_get_interval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("sched_rr_get_interval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static FunctionDescriptor sched_rr_get_interval$descriptor() {
        return sched_rr_get_interval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static MethodHandle sched_rr_get_interval$handle() {
        return sched_rr_get_interval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static MemorySegment sched_rr_get_interval$address() {
        return sched_rr_get_interval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static int sched_rr_get_interval(int __pid, MemorySegment __t) {
        var mh$ = sched_rr_get_interval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_rr_get_interval", __pid, __t);
            }
            return (int)mh$.invokeExact(__pid, __t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = Ibverbs.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = Ibverbs.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = Ibverbs.C_POINTER;

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_LONG    );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static long time(MemorySegment __timer) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", __timer);
            }
            return (long)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_DOUBLE,
            Ibverbs.C_LONG,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static double difftime(long __time1, long __time0) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", __time1, __time0);
            }
            return (double)mh$.invokeExact(__time1, __time0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static long mktime(MemorySegment __tp) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static long strftime(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", __s, __maxsize, __format, __tp);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strftime_l$descriptor() {
        return strftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MethodHandle strftime_l$handle() {
        return strftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MemorySegment strftime_l$address() {
        return strftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static long strftime_l(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp, MemorySegment __loc) {
        var mh$ = strftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime_l", __s, __maxsize, __format, __tp, __loc);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime(MemorySegment __timer) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime(MemorySegment __timer) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime(MemorySegment __tp) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", __tp);
            }
            return (MemorySegment)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime(MemorySegment __timer) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment __tp, MemorySegment __buf) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", __tp, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__tp, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment __timer, MemorySegment __buf) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", __timer, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, Ibverbs.C_POINTER);
        public static final MemorySegment SEGMENT = Ibverbs.findOrThrow("__tzname").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static SequenceLayout __tzname$layout() {
        return __tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static long[] __tzname$dimensions() {
        return __tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname() {
        return __tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, __tzname$constants.SEGMENT, 0L, __tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname(long index0) {
        return (MemorySegment)__tzname$constants.HANDLE.get(__tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(long index0, MemorySegment varValue) {
        __tzname$constants.HANDLE.set(__tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class __daylight$constants {
        public static final OfInt LAYOUT = Ibverbs.C_INT;
        public static final MemorySegment SEGMENT = Ibverbs.findOrThrow("__daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static OfInt __daylight$layout() {
        return __daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static MemorySegment __daylight$segment() {
        return __daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static int __daylight() {
        return __daylight$constants.SEGMENT.get(__daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static void __daylight(int varValue) {
        __daylight$constants.SEGMENT.set(__daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class __timezone$constants {
        public static final OfLong LAYOUT = Ibverbs.C_LONG;
        public static final MemorySegment SEGMENT = Ibverbs.findOrThrow("__timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static OfLong __timezone$layout() {
        return __timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static MemorySegment __timezone$segment() {
        return __timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static long __timezone() {
        return __timezone$constants.SEGMENT.get(__timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static void __timezone(long varValue) {
        __timezone$constants.SEGMENT.set(__timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, Ibverbs.C_POINTER);
        public static final MemorySegment SEGMENT = Ibverbs.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname(long index0) {
        return (MemorySegment)tzname$constants.HANDLE.get(tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(long index0, MemorySegment varValue) {
        tzname$constants.HANDLE.set(tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = Ibverbs.C_INT;
        public static final MemorySegment SEGMENT = Ibverbs.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = Ibverbs.C_LONG;
        public static final MemorySegment SEGMENT = Ibverbs.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static long timegm(MemorySegment __tp) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static long timelocal(MemorySegment __tp) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dysize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("dysize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static FunctionDescriptor dysize$descriptor() {
        return dysize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MethodHandle dysize$handle() {
        return dysize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MemorySegment dysize$address() {
        return dysize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static int dysize(int __year) {
        var mh$ = dysize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dysize", __year);
            }
            return (int)mh$.invokeExact(__year);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static int nanosleep(MemorySegment __requested_time, MemorySegment __remaining) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __requested_time, __remaining);
            }
            return (int)mh$.invokeExact(__requested_time, __remaining);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int)mh$.invokeExact(__clock_id, __res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("clock_nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static FunctionDescriptor clock_nanosleep$descriptor() {
        return clock_nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MethodHandle clock_nanosleep$handle() {
        return clock_nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MemorySegment clock_nanosleep$address() {
        return clock_nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static int clock_nanosleep(int __clock_id, int __flags, MemorySegment __req, MemorySegment __rem) {
        var mh$ = clock_nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_nanosleep", __clock_id, __flags, __req, __rem);
            }
            return (int)mh$.invokeExact(__clock_id, __flags, __req, __rem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getcpuclockid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("clock_getcpuclockid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static FunctionDescriptor clock_getcpuclockid$descriptor() {
        return clock_getcpuclockid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MethodHandle clock_getcpuclockid$handle() {
        return clock_getcpuclockid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MemorySegment clock_getcpuclockid$address() {
        return clock_getcpuclockid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static int clock_getcpuclockid(int __pid, MemorySegment __clock_id) {
        var mh$ = clock_getcpuclockid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getcpuclockid", __pid, __clock_id);
            }
            return (int)mh$.invokeExact(__pid, __clock_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("timer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static FunctionDescriptor timer_create$descriptor() {
        return timer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MethodHandle timer_create$handle() {
        return timer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MemorySegment timer_create$address() {
        return timer_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static int timer_create(int __clock_id, MemorySegment __evp, MemorySegment __timerid) {
        var mh$ = timer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_create", __clock_id, __evp, __timerid);
            }
            return (int)mh$.invokeExact(__clock_id, __evp, __timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("timer_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_delete$descriptor() {
        return timer_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_delete$handle() {
        return timer_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_delete$address() {
        return timer_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static int timer_delete(MemorySegment __timerid) {
        var mh$ = timer_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_delete", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("timer_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static FunctionDescriptor timer_settime$descriptor() {
        return timer_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MethodHandle timer_settime$handle() {
        return timer_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MemorySegment timer_settime$address() {
        return timer_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static int timer_settime(MemorySegment __timerid, int __flags, MemorySegment __value, MemorySegment __ovalue) {
        var mh$ = timer_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_settime", __timerid, __flags, __value, __ovalue);
            }
            return (int)mh$.invokeExact(__timerid, __flags, __value, __ovalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("timer_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static FunctionDescriptor timer_gettime$descriptor() {
        return timer_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MethodHandle timer_gettime$handle() {
        return timer_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MemorySegment timer_gettime$address() {
        return timer_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static int timer_gettime(MemorySegment __timerid, MemorySegment __value) {
        var mh$ = timer_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_gettime", __timerid, __value);
            }
            return (int)mh$.invokeExact(__timerid, __value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_getoverrun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("timer_getoverrun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_getoverrun$descriptor() {
        return timer_getoverrun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_getoverrun$handle() {
        return timer_getoverrun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_getoverrun$address() {
        return timer_getoverrun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static int timer_getoverrun(MemorySegment __timerid) {
        var mh$ = timer_getoverrun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_getoverrun", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static int timespec_get(MemorySegment __ts, int __base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", __ts, __base);
            }
            return (int)mh$.invokeExact(__ts, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = Ibverbs.C_INT;
    private static final int PTHREAD_CREATE_JOINABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_CREATE_JOINABLE = 0
     * }
     */
    public static int PTHREAD_CREATE_JOINABLE() {
        return PTHREAD_CREATE_JOINABLE;
    }
    private static final int PTHREAD_CREATE_DETACHED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_CREATE_DETACHED = 1
     * }
     */
    public static int PTHREAD_CREATE_DETACHED() {
        return PTHREAD_CREATE_DETACHED;
    }
    private static final int PTHREAD_MUTEX_TIMED_NP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_TIMED_NP = 0
     * }
     */
    public static int PTHREAD_MUTEX_TIMED_NP() {
        return PTHREAD_MUTEX_TIMED_NP;
    }
    private static final int PTHREAD_MUTEX_RECURSIVE_NP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_RECURSIVE_NP = 1
     * }
     */
    public static int PTHREAD_MUTEX_RECURSIVE_NP() {
        return PTHREAD_MUTEX_RECURSIVE_NP;
    }
    private static final int PTHREAD_MUTEX_ERRORCHECK_NP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_ERRORCHECK_NP = 2
     * }
     */
    public static int PTHREAD_MUTEX_ERRORCHECK_NP() {
        return PTHREAD_MUTEX_ERRORCHECK_NP;
    }
    private static final int PTHREAD_MUTEX_ADAPTIVE_NP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_ADAPTIVE_NP = 3
     * }
     */
    public static int PTHREAD_MUTEX_ADAPTIVE_NP() {
        return PTHREAD_MUTEX_ADAPTIVE_NP;
    }
    private static final int PTHREAD_MUTEX_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_NORMAL = 0
     * }
     */
    public static int PTHREAD_MUTEX_NORMAL() {
        return PTHREAD_MUTEX_NORMAL;
    }
    private static final int PTHREAD_MUTEX_RECURSIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_RECURSIVE = 1
     * }
     */
    public static int PTHREAD_MUTEX_RECURSIVE() {
        return PTHREAD_MUTEX_RECURSIVE;
    }
    private static final int PTHREAD_MUTEX_ERRORCHECK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_ERRORCHECK = 2
     * }
     */
    public static int PTHREAD_MUTEX_ERRORCHECK() {
        return PTHREAD_MUTEX_ERRORCHECK;
    }
    private static final int PTHREAD_MUTEX_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_DEFAULT = 0
     * }
     */
    public static int PTHREAD_MUTEX_DEFAULT() {
        return PTHREAD_MUTEX_DEFAULT;
    }
    private static final int PTHREAD_MUTEX_STALLED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_STALLED = 0
     * }
     */
    public static int PTHREAD_MUTEX_STALLED() {
        return PTHREAD_MUTEX_STALLED;
    }
    private static final int PTHREAD_MUTEX_STALLED_NP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_STALLED_NP = 0
     * }
     */
    public static int PTHREAD_MUTEX_STALLED_NP() {
        return PTHREAD_MUTEX_STALLED_NP;
    }
    private static final int PTHREAD_MUTEX_ROBUST = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_ROBUST = 1
     * }
     */
    public static int PTHREAD_MUTEX_ROBUST() {
        return PTHREAD_MUTEX_ROBUST;
    }
    private static final int PTHREAD_MUTEX_ROBUST_NP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_ROBUST_NP = 1
     * }
     */
    public static int PTHREAD_MUTEX_ROBUST_NP() {
        return PTHREAD_MUTEX_ROBUST_NP;
    }
    private static final int PTHREAD_PRIO_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_PRIO_NONE = 0
     * }
     */
    public static int PTHREAD_PRIO_NONE() {
        return PTHREAD_PRIO_NONE;
    }
    private static final int PTHREAD_PRIO_INHERIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_PRIO_INHERIT = 1
     * }
     */
    public static int PTHREAD_PRIO_INHERIT() {
        return PTHREAD_PRIO_INHERIT;
    }
    private static final int PTHREAD_PRIO_PROTECT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_PRIO_PROTECT = 2
     * }
     */
    public static int PTHREAD_PRIO_PROTECT() {
        return PTHREAD_PRIO_PROTECT;
    }
    private static final int PTHREAD_RWLOCK_PREFER_READER_NP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_RWLOCK_PREFER_READER_NP = 0
     * }
     */
    public static int PTHREAD_RWLOCK_PREFER_READER_NP() {
        return PTHREAD_RWLOCK_PREFER_READER_NP;
    }
    private static final int PTHREAD_RWLOCK_PREFER_WRITER_NP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_RWLOCK_PREFER_WRITER_NP = 1
     * }
     */
    public static int PTHREAD_RWLOCK_PREFER_WRITER_NP() {
        return PTHREAD_RWLOCK_PREFER_WRITER_NP;
    }
    private static final int PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2
     * }
     */
    public static int PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP() {
        return PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP;
    }
    private static final int PTHREAD_RWLOCK_DEFAULT_NP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_RWLOCK_DEFAULT_NP = 0
     * }
     */
    public static int PTHREAD_RWLOCK_DEFAULT_NP() {
        return PTHREAD_RWLOCK_DEFAULT_NP;
    }
    private static final int PTHREAD_INHERIT_SCHED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_INHERIT_SCHED = 0
     * }
     */
    public static int PTHREAD_INHERIT_SCHED() {
        return PTHREAD_INHERIT_SCHED;
    }
    private static final int PTHREAD_EXPLICIT_SCHED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_EXPLICIT_SCHED = 1
     * }
     */
    public static int PTHREAD_EXPLICIT_SCHED() {
        return PTHREAD_EXPLICIT_SCHED;
    }
    private static final int PTHREAD_SCOPE_SYSTEM = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_SCOPE_SYSTEM = 0
     * }
     */
    public static int PTHREAD_SCOPE_SYSTEM() {
        return PTHREAD_SCOPE_SYSTEM;
    }
    private static final int PTHREAD_SCOPE_PROCESS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_SCOPE_PROCESS = 1
     * }
     */
    public static int PTHREAD_SCOPE_PROCESS() {
        return PTHREAD_SCOPE_PROCESS;
    }
    private static final int PTHREAD_PROCESS_PRIVATE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_PROCESS_PRIVATE = 0
     * }
     */
    public static int PTHREAD_PROCESS_PRIVATE() {
        return PTHREAD_PROCESS_PRIVATE;
    }
    private static final int PTHREAD_PROCESS_SHARED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_PROCESS_SHARED = 1
     * }
     */
    public static int PTHREAD_PROCESS_SHARED() {
        return PTHREAD_PROCESS_SHARED;
    }
    private static final int PTHREAD_CANCEL_ENABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_CANCEL_ENABLE = 0
     * }
     */
    public static int PTHREAD_CANCEL_ENABLE() {
        return PTHREAD_CANCEL_ENABLE;
    }
    private static final int PTHREAD_CANCEL_DISABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_CANCEL_DISABLE = 1
     * }
     */
    public static int PTHREAD_CANCEL_DISABLE() {
        return PTHREAD_CANCEL_DISABLE;
    }
    private static final int PTHREAD_CANCEL_DEFERRED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_CANCEL_DEFERRED = 0
     * }
     */
    public static int PTHREAD_CANCEL_DEFERRED() {
        return PTHREAD_CANCEL_DEFERRED;
    }
    private static final int PTHREAD_CANCEL_ASYNCHRONOUS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_CANCEL_ASYNCHRONOUS = 1
     * }
     */
    public static int PTHREAD_CANCEL_ASYNCHRONOUS() {
        return PTHREAD_CANCEL_ASYNCHRONOUS;
    }

    private static class pthread_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_create(pthread_t *restrict __newthread, const pthread_attr_t *restrict __attr, void *(*__start_routine)(void *), void *restrict __arg)
     * }
     */
    public static FunctionDescriptor pthread_create$descriptor() {
        return pthread_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_create(pthread_t *restrict __newthread, const pthread_attr_t *restrict __attr, void *(*__start_routine)(void *), void *restrict __arg)
     * }
     */
    public static MethodHandle pthread_create$handle() {
        return pthread_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_create(pthread_t *restrict __newthread, const pthread_attr_t *restrict __attr, void *(*__start_routine)(void *), void *restrict __arg)
     * }
     */
    public static MemorySegment pthread_create$address() {
        return pthread_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_create(pthread_t *restrict __newthread, const pthread_attr_t *restrict __attr, void *(*__start_routine)(void *), void *restrict __arg)
     * }
     */
    public static int pthread_create(MemorySegment __newthread, MemorySegment __attr, MemorySegment __start_routine, MemorySegment __arg) {
        var mh$ = pthread_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_create", __newthread, __attr, __start_routine, __arg);
            }
            return (int)mh$.invokeExact(__newthread, __attr, __start_routine, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void pthread_exit(void *__retval)
     * }
     */
    public static FunctionDescriptor pthread_exit$descriptor() {
        return pthread_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void pthread_exit(void *__retval)
     * }
     */
    public static MethodHandle pthread_exit$handle() {
        return pthread_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void pthread_exit(void *__retval)
     * }
     */
    public static MemorySegment pthread_exit$address() {
        return pthread_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void pthread_exit(void *__retval)
     * }
     */
    public static void pthread_exit(MemorySegment __retval) {
        var mh$ = pthread_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_exit", __retval);
            }
            mh$.invokeExact(__retval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_join(pthread_t __th, void **__thread_return)
     * }
     */
    public static FunctionDescriptor pthread_join$descriptor() {
        return pthread_join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_join(pthread_t __th, void **__thread_return)
     * }
     */
    public static MethodHandle pthread_join$handle() {
        return pthread_join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_join(pthread_t __th, void **__thread_return)
     * }
     */
    public static MemorySegment pthread_join$address() {
        return pthread_join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_join(pthread_t __th, void **__thread_return)
     * }
     */
    public static int pthread_join(long __th, MemorySegment __thread_return) {
        var mh$ = pthread_join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_join", __th, __thread_return);
            }
            return (int)mh$.invokeExact(__th, __thread_return);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_detach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_detach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_detach(pthread_t __th)
     * }
     */
    public static FunctionDescriptor pthread_detach$descriptor() {
        return pthread_detach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_detach(pthread_t __th)
     * }
     */
    public static MethodHandle pthread_detach$handle() {
        return pthread_detach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_detach(pthread_t __th)
     * }
     */
    public static MemorySegment pthread_detach$address() {
        return pthread_detach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_detach(pthread_t __th)
     * }
     */
    public static int pthread_detach(long __th) {
        var mh$ = pthread_detach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_detach", __th);
            }
            return (int)mh$.invokeExact(__th);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_LONG    );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern pthread_t pthread_self()
     * }
     */
    public static FunctionDescriptor pthread_self$descriptor() {
        return pthread_self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern pthread_t pthread_self()
     * }
     */
    public static MethodHandle pthread_self$handle() {
        return pthread_self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern pthread_t pthread_self()
     * }
     */
    public static MemorySegment pthread_self$address() {
        return pthread_self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern pthread_t pthread_self()
     * }
     */
    public static long pthread_self() {
        var mh$ = pthread_self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_self");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_LONG,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_equal(pthread_t __thread1, pthread_t __thread2)
     * }
     */
    public static FunctionDescriptor pthread_equal$descriptor() {
        return pthread_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_equal(pthread_t __thread1, pthread_t __thread2)
     * }
     */
    public static MethodHandle pthread_equal$handle() {
        return pthread_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_equal(pthread_t __thread1, pthread_t __thread2)
     * }
     */
    public static MemorySegment pthread_equal$address() {
        return pthread_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_equal(pthread_t __thread1, pthread_t __thread2)
     * }
     */
    public static int pthread_equal(long __thread1, long __thread2) {
        var mh$ = pthread_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_equal", __thread1, __thread2);
            }
            return (int)mh$.invokeExact(__thread1, __thread2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_init(pthread_attr_t *__attr)
     * }
     */
    public static FunctionDescriptor pthread_attr_init$descriptor() {
        return pthread_attr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_init(pthread_attr_t *__attr)
     * }
     */
    public static MethodHandle pthread_attr_init$handle() {
        return pthread_attr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_init(pthread_attr_t *__attr)
     * }
     */
    public static MemorySegment pthread_attr_init$address() {
        return pthread_attr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_init(pthread_attr_t *__attr)
     * }
     */
    public static int pthread_attr_init(MemorySegment __attr) {
        var mh$ = pthread_attr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_init", __attr);
            }
            return (int)mh$.invokeExact(__attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_destroy(pthread_attr_t *__attr)
     * }
     */
    public static FunctionDescriptor pthread_attr_destroy$descriptor() {
        return pthread_attr_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_destroy(pthread_attr_t *__attr)
     * }
     */
    public static MethodHandle pthread_attr_destroy$handle() {
        return pthread_attr_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_destroy(pthread_attr_t *__attr)
     * }
     */
    public static MemorySegment pthread_attr_destroy$address() {
        return pthread_attr_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_destroy(pthread_attr_t *__attr)
     * }
     */
    public static int pthread_attr_destroy(MemorySegment __attr) {
        var mh$ = pthread_attr_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_destroy", __attr);
            }
            return (int)mh$.invokeExact(__attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getdetachstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_getdetachstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr, int *__detachstate)
     * }
     */
    public static FunctionDescriptor pthread_attr_getdetachstate$descriptor() {
        return pthread_attr_getdetachstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr, int *__detachstate)
     * }
     */
    public static MethodHandle pthread_attr_getdetachstate$handle() {
        return pthread_attr_getdetachstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr, int *__detachstate)
     * }
     */
    public static MemorySegment pthread_attr_getdetachstate$address() {
        return pthread_attr_getdetachstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr, int *__detachstate)
     * }
     */
    public static int pthread_attr_getdetachstate(MemorySegment __attr, MemorySegment __detachstate) {
        var mh$ = pthread_attr_getdetachstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getdetachstate", __attr, __detachstate);
            }
            return (int)mh$.invokeExact(__attr, __detachstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setdetachstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_setdetachstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setdetachstate(pthread_attr_t *__attr, int __detachstate)
     * }
     */
    public static FunctionDescriptor pthread_attr_setdetachstate$descriptor() {
        return pthread_attr_setdetachstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setdetachstate(pthread_attr_t *__attr, int __detachstate)
     * }
     */
    public static MethodHandle pthread_attr_setdetachstate$handle() {
        return pthread_attr_setdetachstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setdetachstate(pthread_attr_t *__attr, int __detachstate)
     * }
     */
    public static MemorySegment pthread_attr_setdetachstate$address() {
        return pthread_attr_setdetachstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setdetachstate(pthread_attr_t *__attr, int __detachstate)
     * }
     */
    public static int pthread_attr_setdetachstate(MemorySegment __attr, int __detachstate) {
        var mh$ = pthread_attr_setdetachstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setdetachstate", __attr, __detachstate);
            }
            return (int)mh$.invokeExact(__attr, __detachstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getguardsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_getguardsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getguardsize(const pthread_attr_t *__attr, size_t *__guardsize)
     * }
     */
    public static FunctionDescriptor pthread_attr_getguardsize$descriptor() {
        return pthread_attr_getguardsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getguardsize(const pthread_attr_t *__attr, size_t *__guardsize)
     * }
     */
    public static MethodHandle pthread_attr_getguardsize$handle() {
        return pthread_attr_getguardsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getguardsize(const pthread_attr_t *__attr, size_t *__guardsize)
     * }
     */
    public static MemorySegment pthread_attr_getguardsize$address() {
        return pthread_attr_getguardsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getguardsize(const pthread_attr_t *__attr, size_t *__guardsize)
     * }
     */
    public static int pthread_attr_getguardsize(MemorySegment __attr, MemorySegment __guardsize) {
        var mh$ = pthread_attr_getguardsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getguardsize", __attr, __guardsize);
            }
            return (int)mh$.invokeExact(__attr, __guardsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setguardsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_setguardsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setguardsize(pthread_attr_t *__attr, size_t __guardsize)
     * }
     */
    public static FunctionDescriptor pthread_attr_setguardsize$descriptor() {
        return pthread_attr_setguardsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setguardsize(pthread_attr_t *__attr, size_t __guardsize)
     * }
     */
    public static MethodHandle pthread_attr_setguardsize$handle() {
        return pthread_attr_setguardsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setguardsize(pthread_attr_t *__attr, size_t __guardsize)
     * }
     */
    public static MemorySegment pthread_attr_setguardsize$address() {
        return pthread_attr_setguardsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setguardsize(pthread_attr_t *__attr, size_t __guardsize)
     * }
     */
    public static int pthread_attr_setguardsize(MemorySegment __attr, long __guardsize) {
        var mh$ = pthread_attr_setguardsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setguardsize", __attr, __guardsize);
            }
            return (int)mh$.invokeExact(__attr, __guardsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_getschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getschedparam(const pthread_attr_t *restrict __attr, struct sched_param *restrict __param)
     * }
     */
    public static FunctionDescriptor pthread_attr_getschedparam$descriptor() {
        return pthread_attr_getschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getschedparam(const pthread_attr_t *restrict __attr, struct sched_param *restrict __param)
     * }
     */
    public static MethodHandle pthread_attr_getschedparam$handle() {
        return pthread_attr_getschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getschedparam(const pthread_attr_t *restrict __attr, struct sched_param *restrict __param)
     * }
     */
    public static MemorySegment pthread_attr_getschedparam$address() {
        return pthread_attr_getschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getschedparam(const pthread_attr_t *restrict __attr, struct sched_param *restrict __param)
     * }
     */
    public static int pthread_attr_getschedparam(MemorySegment __attr, MemorySegment __param) {
        var mh$ = pthread_attr_getschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getschedparam", __attr, __param);
            }
            return (int)mh$.invokeExact(__attr, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_setschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setschedparam(pthread_attr_t *restrict __attr, const struct sched_param *restrict __param)
     * }
     */
    public static FunctionDescriptor pthread_attr_setschedparam$descriptor() {
        return pthread_attr_setschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setschedparam(pthread_attr_t *restrict __attr, const struct sched_param *restrict __param)
     * }
     */
    public static MethodHandle pthread_attr_setschedparam$handle() {
        return pthread_attr_setschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setschedparam(pthread_attr_t *restrict __attr, const struct sched_param *restrict __param)
     * }
     */
    public static MemorySegment pthread_attr_setschedparam$address() {
        return pthread_attr_setschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setschedparam(pthread_attr_t *restrict __attr, const struct sched_param *restrict __param)
     * }
     */
    public static int pthread_attr_setschedparam(MemorySegment __attr, MemorySegment __param) {
        var mh$ = pthread_attr_setschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setschedparam", __attr, __param);
            }
            return (int)mh$.invokeExact(__attr, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getschedpolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_getschedpolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getschedpolicy(const pthread_attr_t *restrict __attr, int *restrict __policy)
     * }
     */
    public static FunctionDescriptor pthread_attr_getschedpolicy$descriptor() {
        return pthread_attr_getschedpolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getschedpolicy(const pthread_attr_t *restrict __attr, int *restrict __policy)
     * }
     */
    public static MethodHandle pthread_attr_getschedpolicy$handle() {
        return pthread_attr_getschedpolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getschedpolicy(const pthread_attr_t *restrict __attr, int *restrict __policy)
     * }
     */
    public static MemorySegment pthread_attr_getschedpolicy$address() {
        return pthread_attr_getschedpolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getschedpolicy(const pthread_attr_t *restrict __attr, int *restrict __policy)
     * }
     */
    public static int pthread_attr_getschedpolicy(MemorySegment __attr, MemorySegment __policy) {
        var mh$ = pthread_attr_getschedpolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getschedpolicy", __attr, __policy);
            }
            return (int)mh$.invokeExact(__attr, __policy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setschedpolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_setschedpolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr, int __policy)
     * }
     */
    public static FunctionDescriptor pthread_attr_setschedpolicy$descriptor() {
        return pthread_attr_setschedpolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr, int __policy)
     * }
     */
    public static MethodHandle pthread_attr_setschedpolicy$handle() {
        return pthread_attr_setschedpolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr, int __policy)
     * }
     */
    public static MemorySegment pthread_attr_setschedpolicy$address() {
        return pthread_attr_setschedpolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr, int __policy)
     * }
     */
    public static int pthread_attr_setschedpolicy(MemorySegment __attr, int __policy) {
        var mh$ = pthread_attr_setschedpolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setschedpolicy", __attr, __policy);
            }
            return (int)mh$.invokeExact(__attr, __policy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getinheritsched {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_getinheritsched");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getinheritsched(const pthread_attr_t *restrict __attr, int *restrict __inherit)
     * }
     */
    public static FunctionDescriptor pthread_attr_getinheritsched$descriptor() {
        return pthread_attr_getinheritsched.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getinheritsched(const pthread_attr_t *restrict __attr, int *restrict __inherit)
     * }
     */
    public static MethodHandle pthread_attr_getinheritsched$handle() {
        return pthread_attr_getinheritsched.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getinheritsched(const pthread_attr_t *restrict __attr, int *restrict __inherit)
     * }
     */
    public static MemorySegment pthread_attr_getinheritsched$address() {
        return pthread_attr_getinheritsched.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getinheritsched(const pthread_attr_t *restrict __attr, int *restrict __inherit)
     * }
     */
    public static int pthread_attr_getinheritsched(MemorySegment __attr, MemorySegment __inherit) {
        var mh$ = pthread_attr_getinheritsched.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getinheritsched", __attr, __inherit);
            }
            return (int)mh$.invokeExact(__attr, __inherit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setinheritsched {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_setinheritsched");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setinheritsched(pthread_attr_t *__attr, int __inherit)
     * }
     */
    public static FunctionDescriptor pthread_attr_setinheritsched$descriptor() {
        return pthread_attr_setinheritsched.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setinheritsched(pthread_attr_t *__attr, int __inherit)
     * }
     */
    public static MethodHandle pthread_attr_setinheritsched$handle() {
        return pthread_attr_setinheritsched.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setinheritsched(pthread_attr_t *__attr, int __inherit)
     * }
     */
    public static MemorySegment pthread_attr_setinheritsched$address() {
        return pthread_attr_setinheritsched.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setinheritsched(pthread_attr_t *__attr, int __inherit)
     * }
     */
    public static int pthread_attr_setinheritsched(MemorySegment __attr, int __inherit) {
        var mh$ = pthread_attr_setinheritsched.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setinheritsched", __attr, __inherit);
            }
            return (int)mh$.invokeExact(__attr, __inherit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getscope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_getscope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getscope(const pthread_attr_t *restrict __attr, int *restrict __scope)
     * }
     */
    public static FunctionDescriptor pthread_attr_getscope$descriptor() {
        return pthread_attr_getscope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getscope(const pthread_attr_t *restrict __attr, int *restrict __scope)
     * }
     */
    public static MethodHandle pthread_attr_getscope$handle() {
        return pthread_attr_getscope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getscope(const pthread_attr_t *restrict __attr, int *restrict __scope)
     * }
     */
    public static MemorySegment pthread_attr_getscope$address() {
        return pthread_attr_getscope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getscope(const pthread_attr_t *restrict __attr, int *restrict __scope)
     * }
     */
    public static int pthread_attr_getscope(MemorySegment __attr, MemorySegment __scope) {
        var mh$ = pthread_attr_getscope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getscope", __attr, __scope);
            }
            return (int)mh$.invokeExact(__attr, __scope);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setscope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_setscope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setscope(pthread_attr_t *__attr, int __scope)
     * }
     */
    public static FunctionDescriptor pthread_attr_setscope$descriptor() {
        return pthread_attr_setscope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setscope(pthread_attr_t *__attr, int __scope)
     * }
     */
    public static MethodHandle pthread_attr_setscope$handle() {
        return pthread_attr_setscope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setscope(pthread_attr_t *__attr, int __scope)
     * }
     */
    public static MemorySegment pthread_attr_setscope$address() {
        return pthread_attr_setscope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setscope(pthread_attr_t *__attr, int __scope)
     * }
     */
    public static int pthread_attr_setscope(MemorySegment __attr, int __scope) {
        var mh$ = pthread_attr_setscope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setscope", __attr, __scope);
            }
            return (int)mh$.invokeExact(__attr, __scope);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getstackaddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_getstackaddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstackaddr(const pthread_attr_t *restrict __attr, void **restrict __stackaddr)
     * }
     */
    public static FunctionDescriptor pthread_attr_getstackaddr$descriptor() {
        return pthread_attr_getstackaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstackaddr(const pthread_attr_t *restrict __attr, void **restrict __stackaddr)
     * }
     */
    public static MethodHandle pthread_attr_getstackaddr$handle() {
        return pthread_attr_getstackaddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstackaddr(const pthread_attr_t *restrict __attr, void **restrict __stackaddr)
     * }
     */
    public static MemorySegment pthread_attr_getstackaddr$address() {
        return pthread_attr_getstackaddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getstackaddr(const pthread_attr_t *restrict __attr, void **restrict __stackaddr)
     * }
     */
    public static int pthread_attr_getstackaddr(MemorySegment __attr, MemorySegment __stackaddr) {
        var mh$ = pthread_attr_getstackaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getstackaddr", __attr, __stackaddr);
            }
            return (int)mh$.invokeExact(__attr, __stackaddr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setstackaddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_setstackaddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstackaddr(pthread_attr_t *__attr, void *__stackaddr)
     * }
     */
    public static FunctionDescriptor pthread_attr_setstackaddr$descriptor() {
        return pthread_attr_setstackaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstackaddr(pthread_attr_t *__attr, void *__stackaddr)
     * }
     */
    public static MethodHandle pthread_attr_setstackaddr$handle() {
        return pthread_attr_setstackaddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstackaddr(pthread_attr_t *__attr, void *__stackaddr)
     * }
     */
    public static MemorySegment pthread_attr_setstackaddr$address() {
        return pthread_attr_setstackaddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setstackaddr(pthread_attr_t *__attr, void *__stackaddr)
     * }
     */
    public static int pthread_attr_setstackaddr(MemorySegment __attr, MemorySegment __stackaddr) {
        var mh$ = pthread_attr_setstackaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setstackaddr", __attr, __stackaddr);
            }
            return (int)mh$.invokeExact(__attr, __stackaddr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getstacksize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_getstacksize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstacksize(const pthread_attr_t *restrict __attr, size_t *restrict __stacksize)
     * }
     */
    public static FunctionDescriptor pthread_attr_getstacksize$descriptor() {
        return pthread_attr_getstacksize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstacksize(const pthread_attr_t *restrict __attr, size_t *restrict __stacksize)
     * }
     */
    public static MethodHandle pthread_attr_getstacksize$handle() {
        return pthread_attr_getstacksize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstacksize(const pthread_attr_t *restrict __attr, size_t *restrict __stacksize)
     * }
     */
    public static MemorySegment pthread_attr_getstacksize$address() {
        return pthread_attr_getstacksize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getstacksize(const pthread_attr_t *restrict __attr, size_t *restrict __stacksize)
     * }
     */
    public static int pthread_attr_getstacksize(MemorySegment __attr, MemorySegment __stacksize) {
        var mh$ = pthread_attr_getstacksize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getstacksize", __attr, __stacksize);
            }
            return (int)mh$.invokeExact(__attr, __stacksize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setstacksize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_setstacksize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstacksize(pthread_attr_t *__attr, size_t __stacksize)
     * }
     */
    public static FunctionDescriptor pthread_attr_setstacksize$descriptor() {
        return pthread_attr_setstacksize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstacksize(pthread_attr_t *__attr, size_t __stacksize)
     * }
     */
    public static MethodHandle pthread_attr_setstacksize$handle() {
        return pthread_attr_setstacksize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstacksize(pthread_attr_t *__attr, size_t __stacksize)
     * }
     */
    public static MemorySegment pthread_attr_setstacksize$address() {
        return pthread_attr_setstacksize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setstacksize(pthread_attr_t *__attr, size_t __stacksize)
     * }
     */
    public static int pthread_attr_setstacksize(MemorySegment __attr, long __stacksize) {
        var mh$ = pthread_attr_setstacksize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setstacksize", __attr, __stacksize);
            }
            return (int)mh$.invokeExact(__attr, __stacksize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_getstack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstack(const pthread_attr_t *restrict __attr, void **restrict __stackaddr, size_t *restrict __stacksize)
     * }
     */
    public static FunctionDescriptor pthread_attr_getstack$descriptor() {
        return pthread_attr_getstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstack(const pthread_attr_t *restrict __attr, void **restrict __stackaddr, size_t *restrict __stacksize)
     * }
     */
    public static MethodHandle pthread_attr_getstack$handle() {
        return pthread_attr_getstack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstack(const pthread_attr_t *restrict __attr, void **restrict __stackaddr, size_t *restrict __stacksize)
     * }
     */
    public static MemorySegment pthread_attr_getstack$address() {
        return pthread_attr_getstack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getstack(const pthread_attr_t *restrict __attr, void **restrict __stackaddr, size_t *restrict __stacksize)
     * }
     */
    public static int pthread_attr_getstack(MemorySegment __attr, MemorySegment __stackaddr, MemorySegment __stacksize) {
        var mh$ = pthread_attr_getstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getstack", __attr, __stackaddr, __stacksize);
            }
            return (int)mh$.invokeExact(__attr, __stackaddr, __stacksize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_attr_setstack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr, size_t __stacksize)
     * }
     */
    public static FunctionDescriptor pthread_attr_setstack$descriptor() {
        return pthread_attr_setstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr, size_t __stacksize)
     * }
     */
    public static MethodHandle pthread_attr_setstack$handle() {
        return pthread_attr_setstack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr, size_t __stacksize)
     * }
     */
    public static MemorySegment pthread_attr_setstack$address() {
        return pthread_attr_setstack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr, size_t __stacksize)
     * }
     */
    public static int pthread_attr_setstack(MemorySegment __attr, MemorySegment __stackaddr, long __stacksize) {
        var mh$ = pthread_attr_setstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setstack", __attr, __stackaddr, __stacksize);
            }
            return (int)mh$.invokeExact(__attr, __stackaddr, __stacksize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_LONG,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_setschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor pthread_setschedparam$descriptor() {
        return pthread_setschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const struct sched_param *__param)
     * }
     */
    public static MethodHandle pthread_setschedparam$handle() {
        return pthread_setschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const struct sched_param *__param)
     * }
     */
    public static MemorySegment pthread_setschedparam$address() {
        return pthread_setschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const struct sched_param *__param)
     * }
     */
    public static int pthread_setschedparam(long __target_thread, int __policy, MemorySegment __param) {
        var mh$ = pthread_setschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setschedparam", __target_thread, __policy, __param);
            }
            return (int)mh$.invokeExact(__target_thread, __policy, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_getschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_getschedparam(pthread_t __target_thread, int *restrict __policy, struct sched_param *restrict __param)
     * }
     */
    public static FunctionDescriptor pthread_getschedparam$descriptor() {
        return pthread_getschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_getschedparam(pthread_t __target_thread, int *restrict __policy, struct sched_param *restrict __param)
     * }
     */
    public static MethodHandle pthread_getschedparam$handle() {
        return pthread_getschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_getschedparam(pthread_t __target_thread, int *restrict __policy, struct sched_param *restrict __param)
     * }
     */
    public static MemorySegment pthread_getschedparam$address() {
        return pthread_getschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_getschedparam(pthread_t __target_thread, int *restrict __policy, struct sched_param *restrict __param)
     * }
     */
    public static int pthread_getschedparam(long __target_thread, MemorySegment __policy, MemorySegment __param) {
        var mh$ = pthread_getschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getschedparam", __target_thread, __policy, __param);
            }
            return (int)mh$.invokeExact(__target_thread, __policy, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setschedprio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_LONG,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_setschedprio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_setschedprio(pthread_t __target_thread, int __prio)
     * }
     */
    public static FunctionDescriptor pthread_setschedprio$descriptor() {
        return pthread_setschedprio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_setschedprio(pthread_t __target_thread, int __prio)
     * }
     */
    public static MethodHandle pthread_setschedprio$handle() {
        return pthread_setschedprio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_setschedprio(pthread_t __target_thread, int __prio)
     * }
     */
    public static MemorySegment pthread_setschedprio$address() {
        return pthread_setschedprio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_setschedprio(pthread_t __target_thread, int __prio)
     * }
     */
    public static int pthread_setschedprio(long __target_thread, int __prio) {
        var mh$ = pthread_setschedprio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setschedprio", __target_thread, __prio);
            }
            return (int)mh$.invokeExact(__target_thread, __prio);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_once {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_once");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_once(pthread_once_t *__once_control, void (*__init_routine)(void))
     * }
     */
    public static FunctionDescriptor pthread_once$descriptor() {
        return pthread_once.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_once(pthread_once_t *__once_control, void (*__init_routine)(void))
     * }
     */
    public static MethodHandle pthread_once$handle() {
        return pthread_once.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_once(pthread_once_t *__once_control, void (*__init_routine)(void))
     * }
     */
    public static MemorySegment pthread_once$address() {
        return pthread_once.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_once(pthread_once_t *__once_control, void (*__init_routine)(void))
     * }
     */
    public static int pthread_once(MemorySegment __once_control, MemorySegment __init_routine) {
        var mh$ = pthread_once.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_once", __once_control, __init_routine);
            }
            return (int)mh$.invokeExact(__once_control, __init_routine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setcancelstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_setcancelstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_setcancelstate(int __state, int *__oldstate)
     * }
     */
    public static FunctionDescriptor pthread_setcancelstate$descriptor() {
        return pthread_setcancelstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_setcancelstate(int __state, int *__oldstate)
     * }
     */
    public static MethodHandle pthread_setcancelstate$handle() {
        return pthread_setcancelstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_setcancelstate(int __state, int *__oldstate)
     * }
     */
    public static MemorySegment pthread_setcancelstate$address() {
        return pthread_setcancelstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_setcancelstate(int __state, int *__oldstate)
     * }
     */
    public static int pthread_setcancelstate(int __state, MemorySegment __oldstate) {
        var mh$ = pthread_setcancelstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setcancelstate", __state, __oldstate);
            }
            return (int)mh$.invokeExact(__state, __oldstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setcanceltype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_setcanceltype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_setcanceltype(int __type, int *__oldtype)
     * }
     */
    public static FunctionDescriptor pthread_setcanceltype$descriptor() {
        return pthread_setcanceltype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_setcanceltype(int __type, int *__oldtype)
     * }
     */
    public static MethodHandle pthread_setcanceltype$handle() {
        return pthread_setcanceltype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_setcanceltype(int __type, int *__oldtype)
     * }
     */
    public static MemorySegment pthread_setcanceltype$address() {
        return pthread_setcanceltype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_setcanceltype(int __type, int *__oldtype)
     * }
     */
    public static int pthread_setcanceltype(int __type, MemorySegment __oldtype) {
        var mh$ = pthread_setcanceltype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setcanceltype", __type, __oldtype);
            }
            return (int)mh$.invokeExact(__type, __oldtype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_cancel(pthread_t __th)
     * }
     */
    public static FunctionDescriptor pthread_cancel$descriptor() {
        return pthread_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_cancel(pthread_t __th)
     * }
     */
    public static MethodHandle pthread_cancel$handle() {
        return pthread_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_cancel(pthread_t __th)
     * }
     */
    public static MemorySegment pthread_cancel$address() {
        return pthread_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_cancel(pthread_t __th)
     * }
     */
    public static int pthread_cancel(long __th) {
        var mh$ = pthread_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cancel", __th);
            }
            return (int)mh$.invokeExact(__th);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_testcancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_testcancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void pthread_testcancel()
     * }
     */
    public static FunctionDescriptor pthread_testcancel$descriptor() {
        return pthread_testcancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void pthread_testcancel()
     * }
     */
    public static MethodHandle pthread_testcancel$handle() {
        return pthread_testcancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void pthread_testcancel()
     * }
     */
    public static MemorySegment pthread_testcancel$address() {
        return pthread_testcancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void pthread_testcancel()
     * }
     */
    public static void pthread_testcancel() {
        var mh$ = pthread_testcancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_testcancel");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __pthread_register_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("__pthread_register_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static FunctionDescriptor __pthread_register_cancel$descriptor() {
        return __pthread_register_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static MethodHandle __pthread_register_cancel$handle() {
        return __pthread_register_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static MemorySegment __pthread_register_cancel$address() {
        return __pthread_register_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static void __pthread_register_cancel(MemorySegment __buf) {
        var mh$ = __pthread_register_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__pthread_register_cancel", __buf);
            }
            mh$.invokeExact(__buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __pthread_unregister_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("__pthread_unregister_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static FunctionDescriptor __pthread_unregister_cancel$descriptor() {
        return __pthread_unregister_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static MethodHandle __pthread_unregister_cancel$handle() {
        return __pthread_unregister_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static MemorySegment __pthread_unregister_cancel$address() {
        return __pthread_unregister_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static void __pthread_unregister_cancel(MemorySegment __buf) {
        var mh$ = __pthread_unregister_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__pthread_unregister_cancel", __buf);
            }
            mh$.invokeExact(__buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __pthread_unwind_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("__pthread_unwind_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static FunctionDescriptor __pthread_unwind_next$descriptor() {
        return __pthread_unwind_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static MethodHandle __pthread_unwind_next$handle() {
        return __pthread_unwind_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static MemorySegment __pthread_unwind_next$address() {
        return __pthread_unwind_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static void __pthread_unwind_next(MemorySegment __buf) {
        var mh$ = __pthread_unwind_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__pthread_unwind_next", __buf);
            }
            mh$.invokeExact(__buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sigsetjmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("__sigsetjmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __sigsetjmp(struct __jmp_buf_tag __env[1], int __savemask)
     * }
     */
    public static FunctionDescriptor __sigsetjmp$descriptor() {
        return __sigsetjmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __sigsetjmp(struct __jmp_buf_tag __env[1], int __savemask)
     * }
     */
    public static MethodHandle __sigsetjmp$handle() {
        return __sigsetjmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __sigsetjmp(struct __jmp_buf_tag __env[1], int __savemask)
     * }
     */
    public static MemorySegment __sigsetjmp$address() {
        return __sigsetjmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __sigsetjmp(struct __jmp_buf_tag __env[1], int __savemask)
     * }
     */
    public static int __sigsetjmp(MemorySegment __env, int __savemask) {
        var mh$ = __sigsetjmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sigsetjmp", __env, __savemask);
            }
            return (int)mh$.invokeExact(__env, __savemask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutex_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr)
     * }
     */
    public static FunctionDescriptor pthread_mutex_init$descriptor() {
        return pthread_mutex_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr)
     * }
     */
    public static MethodHandle pthread_mutex_init$handle() {
        return pthread_mutex_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr)
     * }
     */
    public static MemorySegment pthread_mutex_init$address() {
        return pthread_mutex_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr)
     * }
     */
    public static int pthread_mutex_init(MemorySegment __mutex, MemorySegment __mutexattr) {
        var mh$ = pthread_mutex_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_init", __mutex, __mutexattr);
            }
            return (int)mh$.invokeExact(__mutex, __mutexattr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutex_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_destroy(pthread_mutex_t *__mutex)
     * }
     */
    public static FunctionDescriptor pthread_mutex_destroy$descriptor() {
        return pthread_mutex_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_destroy(pthread_mutex_t *__mutex)
     * }
     */
    public static MethodHandle pthread_mutex_destroy$handle() {
        return pthread_mutex_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_destroy(pthread_mutex_t *__mutex)
     * }
     */
    public static MemorySegment pthread_mutex_destroy$address() {
        return pthread_mutex_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_destroy(pthread_mutex_t *__mutex)
     * }
     */
    public static int pthread_mutex_destroy(MemorySegment __mutex) {
        var mh$ = pthread_mutex_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_destroy", __mutex);
            }
            return (int)mh$.invokeExact(__mutex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_trylock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutex_trylock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_trylock(pthread_mutex_t *__mutex)
     * }
     */
    public static FunctionDescriptor pthread_mutex_trylock$descriptor() {
        return pthread_mutex_trylock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_trylock(pthread_mutex_t *__mutex)
     * }
     */
    public static MethodHandle pthread_mutex_trylock$handle() {
        return pthread_mutex_trylock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_trylock(pthread_mutex_t *__mutex)
     * }
     */
    public static MemorySegment pthread_mutex_trylock$address() {
        return pthread_mutex_trylock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_trylock(pthread_mutex_t *__mutex)
     * }
     */
    public static int pthread_mutex_trylock(MemorySegment __mutex) {
        var mh$ = pthread_mutex_trylock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_trylock", __mutex);
            }
            return (int)mh$.invokeExact(__mutex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutex_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_lock(pthread_mutex_t *__mutex)
     * }
     */
    public static FunctionDescriptor pthread_mutex_lock$descriptor() {
        return pthread_mutex_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_lock(pthread_mutex_t *__mutex)
     * }
     */
    public static MethodHandle pthread_mutex_lock$handle() {
        return pthread_mutex_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_lock(pthread_mutex_t *__mutex)
     * }
     */
    public static MemorySegment pthread_mutex_lock$address() {
        return pthread_mutex_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_lock(pthread_mutex_t *__mutex)
     * }
     */
    public static int pthread_mutex_lock(MemorySegment __mutex) {
        var mh$ = pthread_mutex_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_lock", __mutex);
            }
            return (int)mh$.invokeExact(__mutex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_timedlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutex_timedlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_timedlock(pthread_mutex_t *restrict __mutex, const struct timespec *restrict __abstime)
     * }
     */
    public static FunctionDescriptor pthread_mutex_timedlock$descriptor() {
        return pthread_mutex_timedlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_timedlock(pthread_mutex_t *restrict __mutex, const struct timespec *restrict __abstime)
     * }
     */
    public static MethodHandle pthread_mutex_timedlock$handle() {
        return pthread_mutex_timedlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_timedlock(pthread_mutex_t *restrict __mutex, const struct timespec *restrict __abstime)
     * }
     */
    public static MemorySegment pthread_mutex_timedlock$address() {
        return pthread_mutex_timedlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_timedlock(pthread_mutex_t *restrict __mutex, const struct timespec *restrict __abstime)
     * }
     */
    public static int pthread_mutex_timedlock(MemorySegment __mutex, MemorySegment __abstime) {
        var mh$ = pthread_mutex_timedlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_timedlock", __mutex, __abstime);
            }
            return (int)mh$.invokeExact(__mutex, __abstime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutex_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_unlock(pthread_mutex_t *__mutex)
     * }
     */
    public static FunctionDescriptor pthread_mutex_unlock$descriptor() {
        return pthread_mutex_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_unlock(pthread_mutex_t *__mutex)
     * }
     */
    public static MethodHandle pthread_mutex_unlock$handle() {
        return pthread_mutex_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_unlock(pthread_mutex_t *__mutex)
     * }
     */
    public static MemorySegment pthread_mutex_unlock$address() {
        return pthread_mutex_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_unlock(pthread_mutex_t *__mutex)
     * }
     */
    public static int pthread_mutex_unlock(MemorySegment __mutex) {
        var mh$ = pthread_mutex_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_unlock", __mutex);
            }
            return (int)mh$.invokeExact(__mutex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_getprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutex_getprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict __mutex, int *restrict __prioceiling)
     * }
     */
    public static FunctionDescriptor pthread_mutex_getprioceiling$descriptor() {
        return pthread_mutex_getprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict __mutex, int *restrict __prioceiling)
     * }
     */
    public static MethodHandle pthread_mutex_getprioceiling$handle() {
        return pthread_mutex_getprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict __mutex, int *restrict __prioceiling)
     * }
     */
    public static MemorySegment pthread_mutex_getprioceiling$address() {
        return pthread_mutex_getprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict __mutex, int *restrict __prioceiling)
     * }
     */
    public static int pthread_mutex_getprioceiling(MemorySegment __mutex, MemorySegment __prioceiling) {
        var mh$ = pthread_mutex_getprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_getprioceiling", __mutex, __prioceiling);
            }
            return (int)mh$.invokeExact(__mutex, __prioceiling);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_setprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutex_setprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_setprioceiling(pthread_mutex_t *restrict __mutex, int __prioceiling, int *restrict __old_ceiling)
     * }
     */
    public static FunctionDescriptor pthread_mutex_setprioceiling$descriptor() {
        return pthread_mutex_setprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_setprioceiling(pthread_mutex_t *restrict __mutex, int __prioceiling, int *restrict __old_ceiling)
     * }
     */
    public static MethodHandle pthread_mutex_setprioceiling$handle() {
        return pthread_mutex_setprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_setprioceiling(pthread_mutex_t *restrict __mutex, int __prioceiling, int *restrict __old_ceiling)
     * }
     */
    public static MemorySegment pthread_mutex_setprioceiling$address() {
        return pthread_mutex_setprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_setprioceiling(pthread_mutex_t *restrict __mutex, int __prioceiling, int *restrict __old_ceiling)
     * }
     */
    public static int pthread_mutex_setprioceiling(MemorySegment __mutex, int __prioceiling, MemorySegment __old_ceiling) {
        var mh$ = pthread_mutex_setprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_setprioceiling", __mutex, __prioceiling, __old_ceiling);
            }
            return (int)mh$.invokeExact(__mutex, __prioceiling, __old_ceiling);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_consistent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutex_consistent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_consistent(pthread_mutex_t *__mutex)
     * }
     */
    public static FunctionDescriptor pthread_mutex_consistent$descriptor() {
        return pthread_mutex_consistent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_consistent(pthread_mutex_t *__mutex)
     * }
     */
    public static MethodHandle pthread_mutex_consistent$handle() {
        return pthread_mutex_consistent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_consistent(pthread_mutex_t *__mutex)
     * }
     */
    public static MemorySegment pthread_mutex_consistent$address() {
        return pthread_mutex_consistent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_consistent(pthread_mutex_t *__mutex)
     * }
     */
    public static int pthread_mutex_consistent(MemorySegment __mutex) {
        var mh$ = pthread_mutex_consistent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_consistent", __mutex);
            }
            return (int)mh$.invokeExact(__mutex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutexattr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_init$descriptor() {
        return pthread_mutexattr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr)
     * }
     */
    public static MethodHandle pthread_mutexattr_init$handle() {
        return pthread_mutexattr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr)
     * }
     */
    public static MemorySegment pthread_mutexattr_init$address() {
        return pthread_mutexattr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr)
     * }
     */
    public static int pthread_mutexattr_init(MemorySegment __attr) {
        var mh$ = pthread_mutexattr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_init", __attr);
            }
            return (int)mh$.invokeExact(__attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutexattr_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_destroy$descriptor() {
        return pthread_mutexattr_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr)
     * }
     */
    public static MethodHandle pthread_mutexattr_destroy$handle() {
        return pthread_mutexattr_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr)
     * }
     */
    public static MemorySegment pthread_mutexattr_destroy$address() {
        return pthread_mutexattr_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr)
     * }
     */
    public static int pthread_mutexattr_destroy(MemorySegment __attr) {
        var mh$ = pthread_mutexattr_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_destroy", __attr);
            }
            return (int)mh$.invokeExact(__attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutexattr_getpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getpshared$descriptor() {
        return pthread_mutexattr_getpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static MethodHandle pthread_mutexattr_getpshared$handle() {
        return pthread_mutexattr_getpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static MemorySegment pthread_mutexattr_getpshared$address() {
        return pthread_mutexattr_getpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static int pthread_mutexattr_getpshared(MemorySegment __attr, MemorySegment __pshared) {
        var mh$ = pthread_mutexattr_getpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getpshared", __attr, __pshared);
            }
            return (int)mh$.invokeExact(__attr, __pshared);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutexattr_setpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr, int __pshared)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setpshared$descriptor() {
        return pthread_mutexattr_setpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr, int __pshared)
     * }
     */
    public static MethodHandle pthread_mutexattr_setpshared$handle() {
        return pthread_mutexattr_setpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr, int __pshared)
     * }
     */
    public static MemorySegment pthread_mutexattr_setpshared$address() {
        return pthread_mutexattr_setpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr, int __pshared)
     * }
     */
    public static int pthread_mutexattr_setpshared(MemorySegment __attr, int __pshared) {
        var mh$ = pthread_mutexattr_setpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setpshared", __attr, __pshared);
            }
            return (int)mh$.invokeExact(__attr, __pshared);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_gettype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutexattr_gettype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict __attr, int *restrict __kind)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_gettype$descriptor() {
        return pthread_mutexattr_gettype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict __attr, int *restrict __kind)
     * }
     */
    public static MethodHandle pthread_mutexattr_gettype$handle() {
        return pthread_mutexattr_gettype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict __attr, int *restrict __kind)
     * }
     */
    public static MemorySegment pthread_mutexattr_gettype$address() {
        return pthread_mutexattr_gettype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict __attr, int *restrict __kind)
     * }
     */
    public static int pthread_mutexattr_gettype(MemorySegment __attr, MemorySegment __kind) {
        var mh$ = pthread_mutexattr_gettype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_gettype", __attr, __kind);
            }
            return (int)mh$.invokeExact(__attr, __kind);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_settype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutexattr_settype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr, int __kind)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_settype$descriptor() {
        return pthread_mutexattr_settype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr, int __kind)
     * }
     */
    public static MethodHandle pthread_mutexattr_settype$handle() {
        return pthread_mutexattr_settype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr, int __kind)
     * }
     */
    public static MemorySegment pthread_mutexattr_settype$address() {
        return pthread_mutexattr_settype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr, int __kind)
     * }
     */
    public static int pthread_mutexattr_settype(MemorySegment __attr, int __kind) {
        var mh$ = pthread_mutexattr_settype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_settype", __attr, __kind);
            }
            return (int)mh$.invokeExact(__attr, __kind);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getprotocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutexattr_getprotocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict __attr, int *restrict __protocol)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getprotocol$descriptor() {
        return pthread_mutexattr_getprotocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict __attr, int *restrict __protocol)
     * }
     */
    public static MethodHandle pthread_mutexattr_getprotocol$handle() {
        return pthread_mutexattr_getprotocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict __attr, int *restrict __protocol)
     * }
     */
    public static MemorySegment pthread_mutexattr_getprotocol$address() {
        return pthread_mutexattr_getprotocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict __attr, int *restrict __protocol)
     * }
     */
    public static int pthread_mutexattr_getprotocol(MemorySegment __attr, MemorySegment __protocol) {
        var mh$ = pthread_mutexattr_getprotocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getprotocol", __attr, __protocol);
            }
            return (int)mh$.invokeExact(__attr, __protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setprotocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutexattr_setprotocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr, int __protocol)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setprotocol$descriptor() {
        return pthread_mutexattr_setprotocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr, int __protocol)
     * }
     */
    public static MethodHandle pthread_mutexattr_setprotocol$handle() {
        return pthread_mutexattr_setprotocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr, int __protocol)
     * }
     */
    public static MemorySegment pthread_mutexattr_setprotocol$address() {
        return pthread_mutexattr_setprotocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr, int __protocol)
     * }
     */
    public static int pthread_mutexattr_setprotocol(MemorySegment __attr, int __protocol) {
        var mh$ = pthread_mutexattr_setprotocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setprotocol", __attr, __protocol);
            }
            return (int)mh$.invokeExact(__attr, __protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutexattr_getprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict __attr, int *restrict __prioceiling)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getprioceiling$descriptor() {
        return pthread_mutexattr_getprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict __attr, int *restrict __prioceiling)
     * }
     */
    public static MethodHandle pthread_mutexattr_getprioceiling$handle() {
        return pthread_mutexattr_getprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict __attr, int *restrict __prioceiling)
     * }
     */
    public static MemorySegment pthread_mutexattr_getprioceiling$address() {
        return pthread_mutexattr_getprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict __attr, int *restrict __prioceiling)
     * }
     */
    public static int pthread_mutexattr_getprioceiling(MemorySegment __attr, MemorySegment __prioceiling) {
        var mh$ = pthread_mutexattr_getprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getprioceiling", __attr, __prioceiling);
            }
            return (int)mh$.invokeExact(__attr, __prioceiling);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutexattr_setprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr, int __prioceiling)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setprioceiling$descriptor() {
        return pthread_mutexattr_setprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr, int __prioceiling)
     * }
     */
    public static MethodHandle pthread_mutexattr_setprioceiling$handle() {
        return pthread_mutexattr_setprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr, int __prioceiling)
     * }
     */
    public static MemorySegment pthread_mutexattr_setprioceiling$address() {
        return pthread_mutexattr_setprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr, int __prioceiling)
     * }
     */
    public static int pthread_mutexattr_setprioceiling(MemorySegment __attr, int __prioceiling) {
        var mh$ = pthread_mutexattr_setprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setprioceiling", __attr, __prioceiling);
            }
            return (int)mh$.invokeExact(__attr, __prioceiling);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getrobust {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutexattr_getrobust");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr, int *__robustness)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getrobust$descriptor() {
        return pthread_mutexattr_getrobust.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr, int *__robustness)
     * }
     */
    public static MethodHandle pthread_mutexattr_getrobust$handle() {
        return pthread_mutexattr_getrobust.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr, int *__robustness)
     * }
     */
    public static MemorySegment pthread_mutexattr_getrobust$address() {
        return pthread_mutexattr_getrobust.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr, int *__robustness)
     * }
     */
    public static int pthread_mutexattr_getrobust(MemorySegment __attr, MemorySegment __robustness) {
        var mh$ = pthread_mutexattr_getrobust.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getrobust", __attr, __robustness);
            }
            return (int)mh$.invokeExact(__attr, __robustness);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setrobust {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_mutexattr_setrobust");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr, int __robustness)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setrobust$descriptor() {
        return pthread_mutexattr_setrobust.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr, int __robustness)
     * }
     */
    public static MethodHandle pthread_mutexattr_setrobust$handle() {
        return pthread_mutexattr_setrobust.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr, int __robustness)
     * }
     */
    public static MemorySegment pthread_mutexattr_setrobust$address() {
        return pthread_mutexattr_setrobust.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr, int __robustness)
     * }
     */
    public static int pthread_mutexattr_setrobust(MemorySegment __attr, int __robustness) {
        var mh$ = pthread_mutexattr_setrobust.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setrobust", __attr, __robustness);
            }
            return (int)mh$.invokeExact(__attr, __robustness);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_rwlock_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_init(pthread_rwlock_t *restrict __rwlock, const pthread_rwlockattr_t *restrict __attr)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_init$descriptor() {
        return pthread_rwlock_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_init(pthread_rwlock_t *restrict __rwlock, const pthread_rwlockattr_t *restrict __attr)
     * }
     */
    public static MethodHandle pthread_rwlock_init$handle() {
        return pthread_rwlock_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_init(pthread_rwlock_t *restrict __rwlock, const pthread_rwlockattr_t *restrict __attr)
     * }
     */
    public static MemorySegment pthread_rwlock_init$address() {
        return pthread_rwlock_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_init(pthread_rwlock_t *restrict __rwlock, const pthread_rwlockattr_t *restrict __attr)
     * }
     */
    public static int pthread_rwlock_init(MemorySegment __rwlock, MemorySegment __attr) {
        var mh$ = pthread_rwlock_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_init", __rwlock, __attr);
            }
            return (int)mh$.invokeExact(__rwlock, __attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_rwlock_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_destroy$descriptor() {
        return pthread_rwlock_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MethodHandle pthread_rwlock_destroy$handle() {
        return pthread_rwlock_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MemorySegment pthread_rwlock_destroy$address() {
        return pthread_rwlock_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock)
     * }
     */
    public static int pthread_rwlock_destroy(MemorySegment __rwlock) {
        var mh$ = pthread_rwlock_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_destroy", __rwlock);
            }
            return (int)mh$.invokeExact(__rwlock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_rdlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_rwlock_rdlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_rdlock$descriptor() {
        return pthread_rwlock_rdlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MethodHandle pthread_rwlock_rdlock$handle() {
        return pthread_rwlock_rdlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MemorySegment pthread_rwlock_rdlock$address() {
        return pthread_rwlock_rdlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static int pthread_rwlock_rdlock(MemorySegment __rwlock) {
        var mh$ = pthread_rwlock_rdlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_rdlock", __rwlock);
            }
            return (int)mh$.invokeExact(__rwlock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_tryrdlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_rwlock_tryrdlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_tryrdlock$descriptor() {
        return pthread_rwlock_tryrdlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MethodHandle pthread_rwlock_tryrdlock$handle() {
        return pthread_rwlock_tryrdlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MemorySegment pthread_rwlock_tryrdlock$address() {
        return pthread_rwlock_tryrdlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static int pthread_rwlock_tryrdlock(MemorySegment __rwlock) {
        var mh$ = pthread_rwlock_tryrdlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_tryrdlock", __rwlock);
            }
            return (int)mh$.invokeExact(__rwlock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_timedrdlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_rwlock_timedrdlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_timedrdlock$descriptor() {
        return pthread_rwlock_timedrdlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static MethodHandle pthread_rwlock_timedrdlock$handle() {
        return pthread_rwlock_timedrdlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static MemorySegment pthread_rwlock_timedrdlock$address() {
        return pthread_rwlock_timedrdlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static int pthread_rwlock_timedrdlock(MemorySegment __rwlock, MemorySegment __abstime) {
        var mh$ = pthread_rwlock_timedrdlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_timedrdlock", __rwlock, __abstime);
            }
            return (int)mh$.invokeExact(__rwlock, __abstime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_wrlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_rwlock_wrlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_wrlock$descriptor() {
        return pthread_rwlock_wrlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MethodHandle pthread_rwlock_wrlock$handle() {
        return pthread_rwlock_wrlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MemorySegment pthread_rwlock_wrlock$address() {
        return pthread_rwlock_wrlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static int pthread_rwlock_wrlock(MemorySegment __rwlock) {
        var mh$ = pthread_rwlock_wrlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_wrlock", __rwlock);
            }
            return (int)mh$.invokeExact(__rwlock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_trywrlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_rwlock_trywrlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_trywrlock$descriptor() {
        return pthread_rwlock_trywrlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MethodHandle pthread_rwlock_trywrlock$handle() {
        return pthread_rwlock_trywrlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MemorySegment pthread_rwlock_trywrlock$address() {
        return pthread_rwlock_trywrlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static int pthread_rwlock_trywrlock(MemorySegment __rwlock) {
        var mh$ = pthread_rwlock_trywrlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_trywrlock", __rwlock);
            }
            return (int)mh$.invokeExact(__rwlock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_timedwrlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_rwlock_timedwrlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_timedwrlock$descriptor() {
        return pthread_rwlock_timedwrlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static MethodHandle pthread_rwlock_timedwrlock$handle() {
        return pthread_rwlock_timedwrlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static MemorySegment pthread_rwlock_timedwrlock$address() {
        return pthread_rwlock_timedwrlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static int pthread_rwlock_timedwrlock(MemorySegment __rwlock, MemorySegment __abstime) {
        var mh$ = pthread_rwlock_timedwrlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_timedwrlock", __rwlock, __abstime);
            }
            return (int)mh$.invokeExact(__rwlock, __abstime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_rwlock_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_unlock$descriptor() {
        return pthread_rwlock_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MethodHandle pthread_rwlock_unlock$handle() {
        return pthread_rwlock_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MemorySegment pthread_rwlock_unlock$address() {
        return pthread_rwlock_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static int pthread_rwlock_unlock(MemorySegment __rwlock) {
        var mh$ = pthread_rwlock_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_unlock", __rwlock);
            }
            return (int)mh$.invokeExact(__rwlock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlockattr_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_rwlockattr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr)
     * }
     */
    public static FunctionDescriptor pthread_rwlockattr_init$descriptor() {
        return pthread_rwlockattr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr)
     * }
     */
    public static MethodHandle pthread_rwlockattr_init$handle() {
        return pthread_rwlockattr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr)
     * }
     */
    public static MemorySegment pthread_rwlockattr_init$address() {
        return pthread_rwlockattr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr)
     * }
     */
    public static int pthread_rwlockattr_init(MemorySegment __attr) {
        var mh$ = pthread_rwlockattr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlockattr_init", __attr);
            }
            return (int)mh$.invokeExact(__attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlockattr_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_rwlockattr_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr)
     * }
     */
    public static FunctionDescriptor pthread_rwlockattr_destroy$descriptor() {
        return pthread_rwlockattr_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr)
     * }
     */
    public static MethodHandle pthread_rwlockattr_destroy$handle() {
        return pthread_rwlockattr_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr)
     * }
     */
    public static MemorySegment pthread_rwlockattr_destroy$address() {
        return pthread_rwlockattr_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr)
     * }
     */
    public static int pthread_rwlockattr_destroy(MemorySegment __attr) {
        var mh$ = pthread_rwlockattr_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlockattr_destroy", __attr);
            }
            return (int)mh$.invokeExact(__attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlockattr_getpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_rwlockattr_getpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static FunctionDescriptor pthread_rwlockattr_getpshared$descriptor() {
        return pthread_rwlockattr_getpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static MethodHandle pthread_rwlockattr_getpshared$handle() {
        return pthread_rwlockattr_getpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static MemorySegment pthread_rwlockattr_getpshared$address() {
        return pthread_rwlockattr_getpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static int pthread_rwlockattr_getpshared(MemorySegment __attr, MemorySegment __pshared) {
        var mh$ = pthread_rwlockattr_getpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlockattr_getpshared", __attr, __pshared);
            }
            return (int)mh$.invokeExact(__attr, __pshared);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlockattr_setpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_rwlockattr_setpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr, int __pshared)
     * }
     */
    public static FunctionDescriptor pthread_rwlockattr_setpshared$descriptor() {
        return pthread_rwlockattr_setpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr, int __pshared)
     * }
     */
    public static MethodHandle pthread_rwlockattr_setpshared$handle() {
        return pthread_rwlockattr_setpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr, int __pshared)
     * }
     */
    public static MemorySegment pthread_rwlockattr_setpshared$address() {
        return pthread_rwlockattr_setpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr, int __pshared)
     * }
     */
    public static int pthread_rwlockattr_setpshared(MemorySegment __attr, int __pshared) {
        var mh$ = pthread_rwlockattr_setpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlockattr_setpshared", __attr, __pshared);
            }
            return (int)mh$.invokeExact(__attr, __pshared);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlockattr_getkind_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_rwlockattr_getkind_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *restrict __attr, int *restrict __pref)
     * }
     */
    public static FunctionDescriptor pthread_rwlockattr_getkind_np$descriptor() {
        return pthread_rwlockattr_getkind_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *restrict __attr, int *restrict __pref)
     * }
     */
    public static MethodHandle pthread_rwlockattr_getkind_np$handle() {
        return pthread_rwlockattr_getkind_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *restrict __attr, int *restrict __pref)
     * }
     */
    public static MemorySegment pthread_rwlockattr_getkind_np$address() {
        return pthread_rwlockattr_getkind_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *restrict __attr, int *restrict __pref)
     * }
     */
    public static int pthread_rwlockattr_getkind_np(MemorySegment __attr, MemorySegment __pref) {
        var mh$ = pthread_rwlockattr_getkind_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlockattr_getkind_np", __attr, __pref);
            }
            return (int)mh$.invokeExact(__attr, __pref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlockattr_setkind_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_rwlockattr_setkind_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr, int __pref)
     * }
     */
    public static FunctionDescriptor pthread_rwlockattr_setkind_np$descriptor() {
        return pthread_rwlockattr_setkind_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr, int __pref)
     * }
     */
    public static MethodHandle pthread_rwlockattr_setkind_np$handle() {
        return pthread_rwlockattr_setkind_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr, int __pref)
     * }
     */
    public static MemorySegment pthread_rwlockattr_setkind_np$address() {
        return pthread_rwlockattr_setkind_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr, int __pref)
     * }
     */
    public static int pthread_rwlockattr_setkind_np(MemorySegment __attr, int __pref) {
        var mh$ = pthread_rwlockattr_setkind_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlockattr_setkind_np", __attr, __pref);
            }
            return (int)mh$.invokeExact(__attr, __pref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_cond_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_cond_init(pthread_cond_t *restrict __cond, const pthread_condattr_t *restrict __cond_attr)
     * }
     */
    public static FunctionDescriptor pthread_cond_init$descriptor() {
        return pthread_cond_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_cond_init(pthread_cond_t *restrict __cond, const pthread_condattr_t *restrict __cond_attr)
     * }
     */
    public static MethodHandle pthread_cond_init$handle() {
        return pthread_cond_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_cond_init(pthread_cond_t *restrict __cond, const pthread_condattr_t *restrict __cond_attr)
     * }
     */
    public static MemorySegment pthread_cond_init$address() {
        return pthread_cond_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_cond_init(pthread_cond_t *restrict __cond, const pthread_condattr_t *restrict __cond_attr)
     * }
     */
    public static int pthread_cond_init(MemorySegment __cond, MemorySegment __cond_attr) {
        var mh$ = pthread_cond_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_init", __cond, __cond_attr);
            }
            return (int)mh$.invokeExact(__cond, __cond_attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_cond_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_cond_destroy(pthread_cond_t *__cond)
     * }
     */
    public static FunctionDescriptor pthread_cond_destroy$descriptor() {
        return pthread_cond_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_cond_destroy(pthread_cond_t *__cond)
     * }
     */
    public static MethodHandle pthread_cond_destroy$handle() {
        return pthread_cond_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_cond_destroy(pthread_cond_t *__cond)
     * }
     */
    public static MemorySegment pthread_cond_destroy$address() {
        return pthread_cond_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_cond_destroy(pthread_cond_t *__cond)
     * }
     */
    public static int pthread_cond_destroy(MemorySegment __cond) {
        var mh$ = pthread_cond_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_destroy", __cond);
            }
            return (int)mh$.invokeExact(__cond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_cond_signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_cond_signal(pthread_cond_t *__cond)
     * }
     */
    public static FunctionDescriptor pthread_cond_signal$descriptor() {
        return pthread_cond_signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_cond_signal(pthread_cond_t *__cond)
     * }
     */
    public static MethodHandle pthread_cond_signal$handle() {
        return pthread_cond_signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_cond_signal(pthread_cond_t *__cond)
     * }
     */
    public static MemorySegment pthread_cond_signal$address() {
        return pthread_cond_signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_cond_signal(pthread_cond_t *__cond)
     * }
     */
    public static int pthread_cond_signal(MemorySegment __cond) {
        var mh$ = pthread_cond_signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_signal", __cond);
            }
            return (int)mh$.invokeExact(__cond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_broadcast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_cond_broadcast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_cond_broadcast(pthread_cond_t *__cond)
     * }
     */
    public static FunctionDescriptor pthread_cond_broadcast$descriptor() {
        return pthread_cond_broadcast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_cond_broadcast(pthread_cond_t *__cond)
     * }
     */
    public static MethodHandle pthread_cond_broadcast$handle() {
        return pthread_cond_broadcast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_cond_broadcast(pthread_cond_t *__cond)
     * }
     */
    public static MemorySegment pthread_cond_broadcast$address() {
        return pthread_cond_broadcast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_cond_broadcast(pthread_cond_t *__cond)
     * }
     */
    public static int pthread_cond_broadcast(MemorySegment __cond) {
        var mh$ = pthread_cond_broadcast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_broadcast", __cond);
            }
            return (int)mh$.invokeExact(__cond);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_cond_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_cond_wait(pthread_cond_t *restrict __cond, pthread_mutex_t *restrict __mutex)
     * }
     */
    public static FunctionDescriptor pthread_cond_wait$descriptor() {
        return pthread_cond_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_cond_wait(pthread_cond_t *restrict __cond, pthread_mutex_t *restrict __mutex)
     * }
     */
    public static MethodHandle pthread_cond_wait$handle() {
        return pthread_cond_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_cond_wait(pthread_cond_t *restrict __cond, pthread_mutex_t *restrict __mutex)
     * }
     */
    public static MemorySegment pthread_cond_wait$address() {
        return pthread_cond_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_cond_wait(pthread_cond_t *restrict __cond, pthread_mutex_t *restrict __mutex)
     * }
     */
    public static int pthread_cond_wait(MemorySegment __cond, MemorySegment __mutex) {
        var mh$ = pthread_cond_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_wait", __cond, __mutex);
            }
            return (int)mh$.invokeExact(__cond, __mutex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_timedwait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_cond_timedwait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_cond_timedwait(pthread_cond_t *restrict __cond, pthread_mutex_t *restrict __mutex, const struct timespec *restrict __abstime)
     * }
     */
    public static FunctionDescriptor pthread_cond_timedwait$descriptor() {
        return pthread_cond_timedwait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_cond_timedwait(pthread_cond_t *restrict __cond, pthread_mutex_t *restrict __mutex, const struct timespec *restrict __abstime)
     * }
     */
    public static MethodHandle pthread_cond_timedwait$handle() {
        return pthread_cond_timedwait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_cond_timedwait(pthread_cond_t *restrict __cond, pthread_mutex_t *restrict __mutex, const struct timespec *restrict __abstime)
     * }
     */
    public static MemorySegment pthread_cond_timedwait$address() {
        return pthread_cond_timedwait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_cond_timedwait(pthread_cond_t *restrict __cond, pthread_mutex_t *restrict __mutex, const struct timespec *restrict __abstime)
     * }
     */
    public static int pthread_cond_timedwait(MemorySegment __cond, MemorySegment __mutex, MemorySegment __abstime) {
        var mh$ = pthread_cond_timedwait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_timedwait", __cond, __mutex, __abstime);
            }
            return (int)mh$.invokeExact(__cond, __mutex, __abstime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_condattr_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_condattr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_condattr_init(pthread_condattr_t *__attr)
     * }
     */
    public static FunctionDescriptor pthread_condattr_init$descriptor() {
        return pthread_condattr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_condattr_init(pthread_condattr_t *__attr)
     * }
     */
    public static MethodHandle pthread_condattr_init$handle() {
        return pthread_condattr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_condattr_init(pthread_condattr_t *__attr)
     * }
     */
    public static MemorySegment pthread_condattr_init$address() {
        return pthread_condattr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_condattr_init(pthread_condattr_t *__attr)
     * }
     */
    public static int pthread_condattr_init(MemorySegment __attr) {
        var mh$ = pthread_condattr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_condattr_init", __attr);
            }
            return (int)mh$.invokeExact(__attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_condattr_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_condattr_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_condattr_destroy(pthread_condattr_t *__attr)
     * }
     */
    public static FunctionDescriptor pthread_condattr_destroy$descriptor() {
        return pthread_condattr_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_condattr_destroy(pthread_condattr_t *__attr)
     * }
     */
    public static MethodHandle pthread_condattr_destroy$handle() {
        return pthread_condattr_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_condattr_destroy(pthread_condattr_t *__attr)
     * }
     */
    public static MemorySegment pthread_condattr_destroy$address() {
        return pthread_condattr_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_condattr_destroy(pthread_condattr_t *__attr)
     * }
     */
    public static int pthread_condattr_destroy(MemorySegment __attr) {
        var mh$ = pthread_condattr_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_condattr_destroy", __attr);
            }
            return (int)mh$.invokeExact(__attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_condattr_getpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_condattr_getpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_condattr_getpshared(const pthread_condattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static FunctionDescriptor pthread_condattr_getpshared$descriptor() {
        return pthread_condattr_getpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_condattr_getpshared(const pthread_condattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static MethodHandle pthread_condattr_getpshared$handle() {
        return pthread_condattr_getpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_condattr_getpshared(const pthread_condattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static MemorySegment pthread_condattr_getpshared$address() {
        return pthread_condattr_getpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_condattr_getpshared(const pthread_condattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static int pthread_condattr_getpshared(MemorySegment __attr, MemorySegment __pshared) {
        var mh$ = pthread_condattr_getpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_condattr_getpshared", __attr, __pshared);
            }
            return (int)mh$.invokeExact(__attr, __pshared);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_condattr_setpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_condattr_setpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_condattr_setpshared(pthread_condattr_t *__attr, int __pshared)
     * }
     */
    public static FunctionDescriptor pthread_condattr_setpshared$descriptor() {
        return pthread_condattr_setpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_condattr_setpshared(pthread_condattr_t *__attr, int __pshared)
     * }
     */
    public static MethodHandle pthread_condattr_setpshared$handle() {
        return pthread_condattr_setpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_condattr_setpshared(pthread_condattr_t *__attr, int __pshared)
     * }
     */
    public static MemorySegment pthread_condattr_setpshared$address() {
        return pthread_condattr_setpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_condattr_setpshared(pthread_condattr_t *__attr, int __pshared)
     * }
     */
    public static int pthread_condattr_setpshared(MemorySegment __attr, int __pshared) {
        var mh$ = pthread_condattr_setpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_condattr_setpshared", __attr, __pshared);
            }
            return (int)mh$.invokeExact(__attr, __pshared);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_condattr_getclock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_condattr_getclock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_condattr_getclock(const pthread_condattr_t *restrict __attr, __clockid_t *restrict __clock_id)
     * }
     */
    public static FunctionDescriptor pthread_condattr_getclock$descriptor() {
        return pthread_condattr_getclock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_condattr_getclock(const pthread_condattr_t *restrict __attr, __clockid_t *restrict __clock_id)
     * }
     */
    public static MethodHandle pthread_condattr_getclock$handle() {
        return pthread_condattr_getclock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_condattr_getclock(const pthread_condattr_t *restrict __attr, __clockid_t *restrict __clock_id)
     * }
     */
    public static MemorySegment pthread_condattr_getclock$address() {
        return pthread_condattr_getclock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_condattr_getclock(const pthread_condattr_t *restrict __attr, __clockid_t *restrict __clock_id)
     * }
     */
    public static int pthread_condattr_getclock(MemorySegment __attr, MemorySegment __clock_id) {
        var mh$ = pthread_condattr_getclock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_condattr_getclock", __attr, __clock_id);
            }
            return (int)mh$.invokeExact(__attr, __clock_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_condattr_setclock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_condattr_setclock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_condattr_setclock(pthread_condattr_t *__attr, __clockid_t __clock_id)
     * }
     */
    public static FunctionDescriptor pthread_condattr_setclock$descriptor() {
        return pthread_condattr_setclock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_condattr_setclock(pthread_condattr_t *__attr, __clockid_t __clock_id)
     * }
     */
    public static MethodHandle pthread_condattr_setclock$handle() {
        return pthread_condattr_setclock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_condattr_setclock(pthread_condattr_t *__attr, __clockid_t __clock_id)
     * }
     */
    public static MemorySegment pthread_condattr_setclock$address() {
        return pthread_condattr_setclock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_condattr_setclock(pthread_condattr_t *__attr, __clockid_t __clock_id)
     * }
     */
    public static int pthread_condattr_setclock(MemorySegment __attr, int __clock_id) {
        var mh$ = pthread_condattr_setclock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_condattr_setclock", __attr, __clock_id);
            }
            return (int)mh$.invokeExact(__attr, __clock_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_spin_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_spin_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_spin_init(pthread_spinlock_t *__lock, int __pshared)
     * }
     */
    public static FunctionDescriptor pthread_spin_init$descriptor() {
        return pthread_spin_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_spin_init(pthread_spinlock_t *__lock, int __pshared)
     * }
     */
    public static MethodHandle pthread_spin_init$handle() {
        return pthread_spin_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_spin_init(pthread_spinlock_t *__lock, int __pshared)
     * }
     */
    public static MemorySegment pthread_spin_init$address() {
        return pthread_spin_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_spin_init(pthread_spinlock_t *__lock, int __pshared)
     * }
     */
    public static int pthread_spin_init(MemorySegment __lock, int __pshared) {
        var mh$ = pthread_spin_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_spin_init", __lock, __pshared);
            }
            return (int)mh$.invokeExact(__lock, __pshared);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_spin_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_spin_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_spin_destroy(pthread_spinlock_t *__lock)
     * }
     */
    public static FunctionDescriptor pthread_spin_destroy$descriptor() {
        return pthread_spin_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_spin_destroy(pthread_spinlock_t *__lock)
     * }
     */
    public static MethodHandle pthread_spin_destroy$handle() {
        return pthread_spin_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_spin_destroy(pthread_spinlock_t *__lock)
     * }
     */
    public static MemorySegment pthread_spin_destroy$address() {
        return pthread_spin_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_spin_destroy(pthread_spinlock_t *__lock)
     * }
     */
    public static int pthread_spin_destroy(MemorySegment __lock) {
        var mh$ = pthread_spin_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_spin_destroy", __lock);
            }
            return (int)mh$.invokeExact(__lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_spin_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_spin_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_spin_lock(pthread_spinlock_t *__lock)
     * }
     */
    public static FunctionDescriptor pthread_spin_lock$descriptor() {
        return pthread_spin_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_spin_lock(pthread_spinlock_t *__lock)
     * }
     */
    public static MethodHandle pthread_spin_lock$handle() {
        return pthread_spin_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_spin_lock(pthread_spinlock_t *__lock)
     * }
     */
    public static MemorySegment pthread_spin_lock$address() {
        return pthread_spin_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_spin_lock(pthread_spinlock_t *__lock)
     * }
     */
    public static int pthread_spin_lock(MemorySegment __lock) {
        var mh$ = pthread_spin_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_spin_lock", __lock);
            }
            return (int)mh$.invokeExact(__lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_spin_trylock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_spin_trylock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_spin_trylock(pthread_spinlock_t *__lock)
     * }
     */
    public static FunctionDescriptor pthread_spin_trylock$descriptor() {
        return pthread_spin_trylock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_spin_trylock(pthread_spinlock_t *__lock)
     * }
     */
    public static MethodHandle pthread_spin_trylock$handle() {
        return pthread_spin_trylock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_spin_trylock(pthread_spinlock_t *__lock)
     * }
     */
    public static MemorySegment pthread_spin_trylock$address() {
        return pthread_spin_trylock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_spin_trylock(pthread_spinlock_t *__lock)
     * }
     */
    public static int pthread_spin_trylock(MemorySegment __lock) {
        var mh$ = pthread_spin_trylock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_spin_trylock", __lock);
            }
            return (int)mh$.invokeExact(__lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_spin_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_spin_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_spin_unlock(pthread_spinlock_t *__lock)
     * }
     */
    public static FunctionDescriptor pthread_spin_unlock$descriptor() {
        return pthread_spin_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_spin_unlock(pthread_spinlock_t *__lock)
     * }
     */
    public static MethodHandle pthread_spin_unlock$handle() {
        return pthread_spin_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_spin_unlock(pthread_spinlock_t *__lock)
     * }
     */
    public static MemorySegment pthread_spin_unlock$address() {
        return pthread_spin_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_spin_unlock(pthread_spinlock_t *__lock)
     * }
     */
    public static int pthread_spin_unlock(MemorySegment __lock) {
        var mh$ = pthread_spin_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_spin_unlock", __lock);
            }
            return (int)mh$.invokeExact(__lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_barrier_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_barrier_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_barrier_init(pthread_barrier_t *restrict __barrier, const pthread_barrierattr_t *restrict __attr, unsigned int __count)
     * }
     */
    public static FunctionDescriptor pthread_barrier_init$descriptor() {
        return pthread_barrier_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_barrier_init(pthread_barrier_t *restrict __barrier, const pthread_barrierattr_t *restrict __attr, unsigned int __count)
     * }
     */
    public static MethodHandle pthread_barrier_init$handle() {
        return pthread_barrier_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_barrier_init(pthread_barrier_t *restrict __barrier, const pthread_barrierattr_t *restrict __attr, unsigned int __count)
     * }
     */
    public static MemorySegment pthread_barrier_init$address() {
        return pthread_barrier_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_barrier_init(pthread_barrier_t *restrict __barrier, const pthread_barrierattr_t *restrict __attr, unsigned int __count)
     * }
     */
    public static int pthread_barrier_init(MemorySegment __barrier, MemorySegment __attr, int __count) {
        var mh$ = pthread_barrier_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_barrier_init", __barrier, __attr, __count);
            }
            return (int)mh$.invokeExact(__barrier, __attr, __count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_barrier_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_barrier_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_barrier_destroy(pthread_barrier_t *__barrier)
     * }
     */
    public static FunctionDescriptor pthread_barrier_destroy$descriptor() {
        return pthread_barrier_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_barrier_destroy(pthread_barrier_t *__barrier)
     * }
     */
    public static MethodHandle pthread_barrier_destroy$handle() {
        return pthread_barrier_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_barrier_destroy(pthread_barrier_t *__barrier)
     * }
     */
    public static MemorySegment pthread_barrier_destroy$address() {
        return pthread_barrier_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_barrier_destroy(pthread_barrier_t *__barrier)
     * }
     */
    public static int pthread_barrier_destroy(MemorySegment __barrier) {
        var mh$ = pthread_barrier_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_barrier_destroy", __barrier);
            }
            return (int)mh$.invokeExact(__barrier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_barrier_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_barrier_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_barrier_wait(pthread_barrier_t *__barrier)
     * }
     */
    public static FunctionDescriptor pthread_barrier_wait$descriptor() {
        return pthread_barrier_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_barrier_wait(pthread_barrier_t *__barrier)
     * }
     */
    public static MethodHandle pthread_barrier_wait$handle() {
        return pthread_barrier_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_barrier_wait(pthread_barrier_t *__barrier)
     * }
     */
    public static MemorySegment pthread_barrier_wait$address() {
        return pthread_barrier_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_barrier_wait(pthread_barrier_t *__barrier)
     * }
     */
    public static int pthread_barrier_wait(MemorySegment __barrier) {
        var mh$ = pthread_barrier_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_barrier_wait", __barrier);
            }
            return (int)mh$.invokeExact(__barrier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_barrierattr_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_barrierattr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_barrierattr_init(pthread_barrierattr_t *__attr)
     * }
     */
    public static FunctionDescriptor pthread_barrierattr_init$descriptor() {
        return pthread_barrierattr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_barrierattr_init(pthread_barrierattr_t *__attr)
     * }
     */
    public static MethodHandle pthread_barrierattr_init$handle() {
        return pthread_barrierattr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_barrierattr_init(pthread_barrierattr_t *__attr)
     * }
     */
    public static MemorySegment pthread_barrierattr_init$address() {
        return pthread_barrierattr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_barrierattr_init(pthread_barrierattr_t *__attr)
     * }
     */
    public static int pthread_barrierattr_init(MemorySegment __attr) {
        var mh$ = pthread_barrierattr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_barrierattr_init", __attr);
            }
            return (int)mh$.invokeExact(__attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_barrierattr_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_barrierattr_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr)
     * }
     */
    public static FunctionDescriptor pthread_barrierattr_destroy$descriptor() {
        return pthread_barrierattr_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr)
     * }
     */
    public static MethodHandle pthread_barrierattr_destroy$handle() {
        return pthread_barrierattr_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr)
     * }
     */
    public static MemorySegment pthread_barrierattr_destroy$address() {
        return pthread_barrierattr_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr)
     * }
     */
    public static int pthread_barrierattr_destroy(MemorySegment __attr) {
        var mh$ = pthread_barrierattr_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_barrierattr_destroy", __attr);
            }
            return (int)mh$.invokeExact(__attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_barrierattr_getpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_barrierattr_getpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static FunctionDescriptor pthread_barrierattr_getpshared$descriptor() {
        return pthread_barrierattr_getpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static MethodHandle pthread_barrierattr_getpshared$handle() {
        return pthread_barrierattr_getpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static MemorySegment pthread_barrierattr_getpshared$address() {
        return pthread_barrierattr_getpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static int pthread_barrierattr_getpshared(MemorySegment __attr, MemorySegment __pshared) {
        var mh$ = pthread_barrierattr_getpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_barrierattr_getpshared", __attr, __pshared);
            }
            return (int)mh$.invokeExact(__attr, __pshared);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_barrierattr_setpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_barrierattr_setpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr, int __pshared)
     * }
     */
    public static FunctionDescriptor pthread_barrierattr_setpshared$descriptor() {
        return pthread_barrierattr_setpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr, int __pshared)
     * }
     */
    public static MethodHandle pthread_barrierattr_setpshared$handle() {
        return pthread_barrierattr_setpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr, int __pshared)
     * }
     */
    public static MemorySegment pthread_barrierattr_setpshared$address() {
        return pthread_barrierattr_setpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr, int __pshared)
     * }
     */
    public static int pthread_barrierattr_setpshared(MemorySegment __attr, int __pshared) {
        var mh$ = pthread_barrierattr_setpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_barrierattr_setpshared", __attr, __pshared);
            }
            return (int)mh$.invokeExact(__attr, __pshared);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_key_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_key_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_key_create(pthread_key_t *__key, void (*__destr_function)(void *))
     * }
     */
    public static FunctionDescriptor pthread_key_create$descriptor() {
        return pthread_key_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_key_create(pthread_key_t *__key, void (*__destr_function)(void *))
     * }
     */
    public static MethodHandle pthread_key_create$handle() {
        return pthread_key_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_key_create(pthread_key_t *__key, void (*__destr_function)(void *))
     * }
     */
    public static MemorySegment pthread_key_create$address() {
        return pthread_key_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_key_create(pthread_key_t *__key, void (*__destr_function)(void *))
     * }
     */
    public static int pthread_key_create(MemorySegment __key, MemorySegment __destr_function) {
        var mh$ = pthread_key_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_key_create", __key, __destr_function);
            }
            return (int)mh$.invokeExact(__key, __destr_function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_key_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_key_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_key_delete(pthread_key_t __key)
     * }
     */
    public static FunctionDescriptor pthread_key_delete$descriptor() {
        return pthread_key_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_key_delete(pthread_key_t __key)
     * }
     */
    public static MethodHandle pthread_key_delete$handle() {
        return pthread_key_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_key_delete(pthread_key_t __key)
     * }
     */
    public static MemorySegment pthread_key_delete$address() {
        return pthread_key_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_key_delete(pthread_key_t __key)
     * }
     */
    public static int pthread_key_delete(int __key) {
        var mh$ = pthread_key_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_key_delete", __key);
            }
            return (int)mh$.invokeExact(__key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getspecific {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_getspecific");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *pthread_getspecific(pthread_key_t __key)
     * }
     */
    public static FunctionDescriptor pthread_getspecific$descriptor() {
        return pthread_getspecific.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *pthread_getspecific(pthread_key_t __key)
     * }
     */
    public static MethodHandle pthread_getspecific$handle() {
        return pthread_getspecific.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *pthread_getspecific(pthread_key_t __key)
     * }
     */
    public static MemorySegment pthread_getspecific$address() {
        return pthread_getspecific.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *pthread_getspecific(pthread_key_t __key)
     * }
     */
    public static MemorySegment pthread_getspecific(int __key) {
        var mh$ = pthread_getspecific.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getspecific", __key);
            }
            return (MemorySegment)mh$.invokeExact(__key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setspecific {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_setspecific");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_setspecific(pthread_key_t __key, const void *__pointer)
     * }
     */
    public static FunctionDescriptor pthread_setspecific$descriptor() {
        return pthread_setspecific.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_setspecific(pthread_key_t __key, const void *__pointer)
     * }
     */
    public static MethodHandle pthread_setspecific$handle() {
        return pthread_setspecific.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_setspecific(pthread_key_t __key, const void *__pointer)
     * }
     */
    public static MemorySegment pthread_setspecific$address() {
        return pthread_setspecific.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_setspecific(pthread_key_t __key, const void *__pointer)
     * }
     */
    public static int pthread_setspecific(int __key, MemorySegment __pointer) {
        var mh$ = pthread_setspecific.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setspecific", __key, __pointer);
            }
            return (int)mh$.invokeExact(__key, __pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getcpuclockid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_getcpuclockid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_getcpuclockid(pthread_t __thread_id, __clockid_t *__clock_id)
     * }
     */
    public static FunctionDescriptor pthread_getcpuclockid$descriptor() {
        return pthread_getcpuclockid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_getcpuclockid(pthread_t __thread_id, __clockid_t *__clock_id)
     * }
     */
    public static MethodHandle pthread_getcpuclockid$handle() {
        return pthread_getcpuclockid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_getcpuclockid(pthread_t __thread_id, __clockid_t *__clock_id)
     * }
     */
    public static MemorySegment pthread_getcpuclockid$address() {
        return pthread_getcpuclockid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_getcpuclockid(pthread_t __thread_id, __clockid_t *__clock_id)
     * }
     */
    public static int pthread_getcpuclockid(long __thread_id, MemorySegment __clock_id) {
        var mh$ = pthread_getcpuclockid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getcpuclockid", __thread_id, __clock_id);
            }
            return (int)mh$.invokeExact(__thread_id, __clock_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_atfork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pthread_atfork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_atfork(void (*__prepare)(void), void (*__parent)(void), void (*__child)(void))
     * }
     */
    public static FunctionDescriptor pthread_atfork$descriptor() {
        return pthread_atfork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_atfork(void (*__prepare)(void), void (*__parent)(void), void (*__child)(void))
     * }
     */
    public static MethodHandle pthread_atfork$handle() {
        return pthread_atfork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_atfork(void (*__prepare)(void), void (*__parent)(void), void (*__child)(void))
     * }
     */
    public static MemorySegment pthread_atfork$address() {
        return pthread_atfork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_atfork(void (*__prepare)(void), void (*__parent)(void), void (*__child)(void))
     * }
     */
    public static int pthread_atfork(MemorySegment __prepare, MemorySegment __parent, MemorySegment __child) {
        var mh$ = pthread_atfork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_atfork", __prepare, __parent, __child);
            }
            return (int)mh$.invokeExact(__prepare, __parent, __child);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = Ibverbs.C_INT;

    private static class __errno_location {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER    );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("__errno_location");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static FunctionDescriptor __errno_location$descriptor() {
        return __errno_location.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static MethodHandle __errno_location$handle() {
        return __errno_location.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static MemorySegment __errno_location$address() {
        return __errno_location.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static MemorySegment __errno_location() {
        var mh$ = __errno_location.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__errno_location");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dest, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dest, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memset(MemorySegment __s, int __c, long __n) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __memcmpeq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("__memcmpeq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor __memcmpeq$descriptor() {
        return __memcmpeq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle __memcmpeq$handle() {
        return __memcmpeq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment __memcmpeq$address() {
        return __memcmpeq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int __memcmpeq(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = __memcmpeq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__memcmpeq", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcat(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strcoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static FunctionDescriptor strcoll_l$descriptor() {
        return strcoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static MethodHandle strcoll_l$handle() {
        return strcoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static MemorySegment strcoll_l$address() {
        return strcoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static int strcoll_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __l) {
        var mh$ = strcoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll_l", __s1, __s2, __l);
            }
            return (int)mh$.invokeExact(__s1, __s2, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static FunctionDescriptor strxfrm_l$descriptor() {
        return strxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static MethodHandle strxfrm_l$handle() {
        return strxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static MemorySegment strxfrm_l$address() {
        return strxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static long strxfrm_l(MemorySegment __dest, MemorySegment __src, long __n, MemorySegment __l) {
        var mh$ = strxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm_l", __dest, __src, __n, __l);
            }
            return (long)mh$.invokeExact(__dest, __src, __n, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MemorySegment strndup$address() {
        return strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __string, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __string, __n);
            }
            return (MemorySegment)mh$.invokeExact(__string, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __reject) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __reject);
            }
            return (long)mh$.invokeExact(__s, __reject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __accept);
            }
            return (long)mh$.invokeExact(__s, __accept);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __accept);
            }
            return (MemorySegment)mh$.invokeExact(__s, __accept);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strstr(MemorySegment __haystack, MemorySegment __needle) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __haystack, __needle);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __needle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MemorySegment strtok(MemorySegment __s, MemorySegment __delim) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __s, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("__strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor __strtok_r$descriptor() {
        return __strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle __strtok_r$handle() {
        return __strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment __strtok_r$address() {
        return __strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment __strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = __strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment strtok_r$address() {
        return strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static long strnlen(MemorySegment __string, long __maxlen) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __string, __maxlen);
            }
            return (long)mh$.invokeExact(__string, __maxlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("__xpg_strerror_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static MemorySegment strerror_r$address() {
        return strerror_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __buf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __buf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __buf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strerror_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static FunctionDescriptor strerror_l$descriptor() {
        return strerror_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MethodHandle strerror_l$handle() {
        return strerror_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MemorySegment strerror_l$address() {
        return strerror_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MemorySegment strerror_l(int __errnum, MemorySegment __l) {
        var mh$ = strerror_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_l", __errnum, __l);
            }
            return (MemorySegment)mh$.invokeExact(__errnum, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor bcmp$descriptor() {
        return bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle bcmp$handle() {
        return bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment bcmp$address() {
        return bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int bcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("bcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static FunctionDescriptor bcopy$descriptor() {
        return bcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static MethodHandle bcopy$handle() {
        return bcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static MemorySegment bcopy$address() {
        return bcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static void bcopy(MemorySegment __src, MemorySegment __dest, long __n) {
        var mh$ = bcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcopy", __src, __dest, __n);
            }
            mh$.invokeExact(__src, __dest, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor bzero$descriptor() {
        return bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle bzero$handle() {
        return bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static MemorySegment bzero$address() {
        return bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static void bzero(MemorySegment __s, long __n) {
        var mh$ = bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor index$descriptor() {
        return index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MethodHandle index$handle() {
        return index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MemorySegment index$address() {
        return index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MemorySegment index(MemorySegment __s, int __c) {
        var mh$ = index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("index", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("rindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor rindex$descriptor() {
        return rindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MethodHandle rindex$handle() {
        return rindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MemorySegment rindex$address() {
        return rindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MemorySegment rindex(MemorySegment __s, int __c) {
        var mh$ = rindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rindex", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("ffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static FunctionDescriptor ffs$descriptor() {
        return ffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static MethodHandle ffs$handle() {
        return ffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static MemorySegment ffs$address() {
        return ffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static int ffs(int __i) {
        var mh$ = ffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffs", __i);
            }
            return (int)mh$.invokeExact(__i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("ffsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static FunctionDescriptor ffsl$descriptor() {
        return ffsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static MethodHandle ffsl$handle() {
        return ffsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static MemorySegment ffsl$address() {
        return ffsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static int ffsl(long __l) {
        var mh$ = ffsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsl", __l);
            }
            return (int)mh$.invokeExact(__l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("ffsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static FunctionDescriptor ffsll$descriptor() {
        return ffsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static MethodHandle ffsll$handle() {
        return ffsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static MemorySegment ffsll$address() {
        return ffsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static int ffsll(long __ll) {
        var mh$ = ffsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsll", __ll);
            }
            return (int)mh$.invokeExact(__ll);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strcasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcasecmp$descriptor() {
        return strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcasecmp$handle() {
        return strcasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcasecmp$address() {
        return strcasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcasecmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncasecmp$descriptor() {
        return strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncasecmp$handle() {
        return strncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncasecmp$address() {
        return strncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncasecmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strcasecmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strcasecmp_l$descriptor() {
        return strcasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static MethodHandle strcasecmp_l$handle() {
        return strcasecmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static MemorySegment strcasecmp_l$address() {
        return strcasecmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static int strcasecmp_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __loc) {
        var mh$ = strcasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp_l", __s1, __s2, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strncasecmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strncasecmp_l$descriptor() {
        return strncasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static MethodHandle strncasecmp_l$handle() {
        return strncasecmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static MemorySegment strncasecmp_l$address() {
        return strncasecmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static int strncasecmp_l(MemorySegment __s1, MemorySegment __s2, long __n, MemorySegment __loc) {
        var mh$ = strncasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp_l", __s1, __s2, __n, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class explicit_bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("explicit_bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor explicit_bzero$descriptor() {
        return explicit_bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle explicit_bzero$handle() {
        return explicit_bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static MemorySegment explicit_bzero$address() {
        return explicit_bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static void explicit_bzero(MemorySegment __s, long __n) {
        var mh$ = explicit_bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("explicit_bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strsep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MemorySegment strsep$address() {
        return strsep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("strsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal$address() {
        return strsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("__stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor __stpcpy$descriptor() {
        return __stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle __stpcpy$handle() {
        return __stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment __stpcpy$address() {
        return __stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment __stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = __stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment stpcpy$address() {
        return stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("__stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor __stpncpy$descriptor() {
        return __stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle __stpncpy$handle() {
        return __stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __stpncpy$address() {
        return __stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = __stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy$address() {
        return stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef signed char __s8
     * }
     */
    public static final OfByte __s8 = Ibverbs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u8
     * }
     */
    public static final OfByte __u8 = Ibverbs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __s16
     * }
     */
    public static final OfShort __s16 = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u16
     * }
     */
    public static final OfShort __u16 = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __s32
     * }
     */
    public static final OfInt __s32 = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u32
     * }
     */
    public static final OfInt __u32 = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __s64
     * }
     */
    public static final OfLong __s64 = Ibverbs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __u64
     * }
     */
    public static final OfLong __u64 = Ibverbs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_key_t
     * }
     */
    public static final OfInt __kernel_key_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_mqd_t
     * }
     */
    public static final OfInt __kernel_mqd_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_old_uid_t
     * }
     */
    public static final OfShort __kernel_old_uid_t = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_old_gid_t
     * }
     */
    public static final OfShort __kernel_old_gid_t = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __kernel_old_dev_t
     * }
     */
    public static final OfLong __kernel_old_dev_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __kernel_long_t
     * }
     */
    public static final OfLong __kernel_long_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __kernel_ulong_t
     * }
     */
    public static final OfLong __kernel_ulong_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_ulong_t __kernel_ino_t
     * }
     */
    public static final OfLong __kernel_ino_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_mode_t
     * }
     */
    public static final OfInt __kernel_mode_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_pid_t
     * }
     */
    public static final OfInt __kernel_pid_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_ipc_pid_t
     * }
     */
    public static final OfInt __kernel_ipc_pid_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_uid_t
     * }
     */
    public static final OfInt __kernel_uid_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_gid_t
     * }
     */
    public static final OfInt __kernel_gid_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_suseconds_t
     * }
     */
    public static final OfLong __kernel_suseconds_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_daddr_t
     * }
     */
    public static final OfInt __kernel_daddr_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_uid32_t
     * }
     */
    public static final OfInt __kernel_uid32_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_gid32_t
     * }
     */
    public static final OfInt __kernel_gid32_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __kernel_ulong_t __kernel_size_t
     * }
     */
    public static final OfLong __kernel_size_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_ssize_t
     * }
     */
    public static final OfLong __kernel_ssize_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_ptrdiff_t
     * }
     */
    public static final OfLong __kernel_ptrdiff_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_off_t
     * }
     */
    public static final OfLong __kernel_off_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __kernel_loff_t
     * }
     */
    public static final OfLong __kernel_loff_t = Ibverbs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_old_time_t
     * }
     */
    public static final OfLong __kernel_old_time_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_time_t
     * }
     */
    public static final OfLong __kernel_time_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __kernel_time64_t
     * }
     */
    public static final OfLong __kernel_time64_t = Ibverbs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_clock_t
     * }
     */
    public static final OfLong __kernel_clock_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_timer_t
     * }
     */
    public static final OfInt __kernel_timer_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_clockid_t
     * }
     */
    public static final OfInt __kernel_clockid_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef char *__kernel_caddr_t
     * }
     */
    public static final AddressLayout __kernel_caddr_t = Ibverbs.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_uid16_t
     * }
     */
    public static final OfShort __kernel_uid16_t = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_gid16_t
     * }
     */
    public static final OfShort __kernel_gid16_t = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u16 __le16
     * }
     */
    public static final OfShort __le16 = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u16 __be16
     * }
     */
    public static final OfShort __be16 = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u32 __le32
     * }
     */
    public static final OfInt __le32 = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u32 __be32
     * }
     */
    public static final OfInt __be32 = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u64 __le64
     * }
     */
    public static final OfLong __le64 = Ibverbs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u64 __be64
     * }
     */
    public static final OfLong __be64 = Ibverbs.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u16 __sum16
     * }
     */
    public static final OfShort __sum16 = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u32 __wsum
     * }
     */
    public static final OfInt __wsum = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __poll_t
     * }
     */
    public static final OfInt __poll_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = Ibverbs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = Ibverbs.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = Ibverbs.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = Ibverbs.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = Ibverbs.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = Ibverbs.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        public static final MemorySegment ADDR = Ibverbs.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = Ibverbs.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = Ibverbs.C_LONG;
    private static final int IB_USER_VERBS_CMD_GET_CONTEXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_GET_CONTEXT = 0
     * }
     */
    public static int IB_USER_VERBS_CMD_GET_CONTEXT() {
        return IB_USER_VERBS_CMD_GET_CONTEXT;
    }
    private static final int IB_USER_VERBS_CMD_QUERY_DEVICE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_QUERY_DEVICE = 1
     * }
     */
    public static int IB_USER_VERBS_CMD_QUERY_DEVICE() {
        return IB_USER_VERBS_CMD_QUERY_DEVICE;
    }
    private static final int IB_USER_VERBS_CMD_QUERY_PORT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_QUERY_PORT = 2
     * }
     */
    public static int IB_USER_VERBS_CMD_QUERY_PORT() {
        return IB_USER_VERBS_CMD_QUERY_PORT;
    }
    private static final int IB_USER_VERBS_CMD_ALLOC_PD = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_ALLOC_PD = 3
     * }
     */
    public static int IB_USER_VERBS_CMD_ALLOC_PD() {
        return IB_USER_VERBS_CMD_ALLOC_PD;
    }
    private static final int IB_USER_VERBS_CMD_DEALLOC_PD = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_DEALLOC_PD = 4
     * }
     */
    public static int IB_USER_VERBS_CMD_DEALLOC_PD() {
        return IB_USER_VERBS_CMD_DEALLOC_PD;
    }
    private static final int IB_USER_VERBS_CMD_CREATE_AH = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_CREATE_AH = 5
     * }
     */
    public static int IB_USER_VERBS_CMD_CREATE_AH() {
        return IB_USER_VERBS_CMD_CREATE_AH;
    }
    private static final int IB_USER_VERBS_CMD_MODIFY_AH = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_MODIFY_AH = 6
     * }
     */
    public static int IB_USER_VERBS_CMD_MODIFY_AH() {
        return IB_USER_VERBS_CMD_MODIFY_AH;
    }
    private static final int IB_USER_VERBS_CMD_QUERY_AH = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_QUERY_AH = 7
     * }
     */
    public static int IB_USER_VERBS_CMD_QUERY_AH() {
        return IB_USER_VERBS_CMD_QUERY_AH;
    }
    private static final int IB_USER_VERBS_CMD_DESTROY_AH = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_DESTROY_AH = 8
     * }
     */
    public static int IB_USER_VERBS_CMD_DESTROY_AH() {
        return IB_USER_VERBS_CMD_DESTROY_AH;
    }
    private static final int IB_USER_VERBS_CMD_REG_MR = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_REG_MR = 9
     * }
     */
    public static int IB_USER_VERBS_CMD_REG_MR() {
        return IB_USER_VERBS_CMD_REG_MR;
    }
    private static final int IB_USER_VERBS_CMD_REG_SMR = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_REG_SMR = 10
     * }
     */
    public static int IB_USER_VERBS_CMD_REG_SMR() {
        return IB_USER_VERBS_CMD_REG_SMR;
    }
    private static final int IB_USER_VERBS_CMD_REREG_MR = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_REREG_MR = 11
     * }
     */
    public static int IB_USER_VERBS_CMD_REREG_MR() {
        return IB_USER_VERBS_CMD_REREG_MR;
    }
    private static final int IB_USER_VERBS_CMD_QUERY_MR = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_QUERY_MR = 12
     * }
     */
    public static int IB_USER_VERBS_CMD_QUERY_MR() {
        return IB_USER_VERBS_CMD_QUERY_MR;
    }
    private static final int IB_USER_VERBS_CMD_DEREG_MR = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_DEREG_MR = 13
     * }
     */
    public static int IB_USER_VERBS_CMD_DEREG_MR() {
        return IB_USER_VERBS_CMD_DEREG_MR;
    }
    private static final int IB_USER_VERBS_CMD_ALLOC_MW = (int)14L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_ALLOC_MW = 14
     * }
     */
    public static int IB_USER_VERBS_CMD_ALLOC_MW() {
        return IB_USER_VERBS_CMD_ALLOC_MW;
    }
    private static final int IB_USER_VERBS_CMD_BIND_MW = (int)15L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_BIND_MW = 15
     * }
     */
    public static int IB_USER_VERBS_CMD_BIND_MW() {
        return IB_USER_VERBS_CMD_BIND_MW;
    }
    private static final int IB_USER_VERBS_CMD_DEALLOC_MW = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_DEALLOC_MW = 16
     * }
     */
    public static int IB_USER_VERBS_CMD_DEALLOC_MW() {
        return IB_USER_VERBS_CMD_DEALLOC_MW;
    }
    private static final int IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL = (int)17L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL = 17
     * }
     */
    public static int IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL() {
        return IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL;
    }
    private static final int IB_USER_VERBS_CMD_CREATE_CQ = (int)18L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_CREATE_CQ = 18
     * }
     */
    public static int IB_USER_VERBS_CMD_CREATE_CQ() {
        return IB_USER_VERBS_CMD_CREATE_CQ;
    }
    private static final int IB_USER_VERBS_CMD_RESIZE_CQ = (int)19L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_RESIZE_CQ = 19
     * }
     */
    public static int IB_USER_VERBS_CMD_RESIZE_CQ() {
        return IB_USER_VERBS_CMD_RESIZE_CQ;
    }
    private static final int IB_USER_VERBS_CMD_DESTROY_CQ = (int)20L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_DESTROY_CQ = 20
     * }
     */
    public static int IB_USER_VERBS_CMD_DESTROY_CQ() {
        return IB_USER_VERBS_CMD_DESTROY_CQ;
    }
    private static final int IB_USER_VERBS_CMD_POLL_CQ = (int)21L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_POLL_CQ = 21
     * }
     */
    public static int IB_USER_VERBS_CMD_POLL_CQ() {
        return IB_USER_VERBS_CMD_POLL_CQ;
    }
    private static final int IB_USER_VERBS_CMD_PEEK_CQ = (int)22L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_PEEK_CQ = 22
     * }
     */
    public static int IB_USER_VERBS_CMD_PEEK_CQ() {
        return IB_USER_VERBS_CMD_PEEK_CQ;
    }
    private static final int IB_USER_VERBS_CMD_REQ_NOTIFY_CQ = (int)23L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_REQ_NOTIFY_CQ = 23
     * }
     */
    public static int IB_USER_VERBS_CMD_REQ_NOTIFY_CQ() {
        return IB_USER_VERBS_CMD_REQ_NOTIFY_CQ;
    }
    private static final int IB_USER_VERBS_CMD_CREATE_QP = (int)24L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_CREATE_QP = 24
     * }
     */
    public static int IB_USER_VERBS_CMD_CREATE_QP() {
        return IB_USER_VERBS_CMD_CREATE_QP;
    }
    private static final int IB_USER_VERBS_CMD_QUERY_QP = (int)25L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_QUERY_QP = 25
     * }
     */
    public static int IB_USER_VERBS_CMD_QUERY_QP() {
        return IB_USER_VERBS_CMD_QUERY_QP;
    }
    private static final int IB_USER_VERBS_CMD_MODIFY_QP = (int)26L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_MODIFY_QP = 26
     * }
     */
    public static int IB_USER_VERBS_CMD_MODIFY_QP() {
        return IB_USER_VERBS_CMD_MODIFY_QP;
    }
    private static final int IB_USER_VERBS_CMD_DESTROY_QP = (int)27L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_DESTROY_QP = 27
     * }
     */
    public static int IB_USER_VERBS_CMD_DESTROY_QP() {
        return IB_USER_VERBS_CMD_DESTROY_QP;
    }
    private static final int IB_USER_VERBS_CMD_POST_SEND = (int)28L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_POST_SEND = 28
     * }
     */
    public static int IB_USER_VERBS_CMD_POST_SEND() {
        return IB_USER_VERBS_CMD_POST_SEND;
    }
    private static final int IB_USER_VERBS_CMD_POST_RECV = (int)29L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_POST_RECV = 29
     * }
     */
    public static int IB_USER_VERBS_CMD_POST_RECV() {
        return IB_USER_VERBS_CMD_POST_RECV;
    }
    private static final int IB_USER_VERBS_CMD_ATTACH_MCAST = (int)30L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_ATTACH_MCAST = 30
     * }
     */
    public static int IB_USER_VERBS_CMD_ATTACH_MCAST() {
        return IB_USER_VERBS_CMD_ATTACH_MCAST;
    }
    private static final int IB_USER_VERBS_CMD_DETACH_MCAST = (int)31L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_DETACH_MCAST = 31
     * }
     */
    public static int IB_USER_VERBS_CMD_DETACH_MCAST() {
        return IB_USER_VERBS_CMD_DETACH_MCAST;
    }
    private static final int IB_USER_VERBS_CMD_CREATE_SRQ = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_CREATE_SRQ = 32
     * }
     */
    public static int IB_USER_VERBS_CMD_CREATE_SRQ() {
        return IB_USER_VERBS_CMD_CREATE_SRQ;
    }
    private static final int IB_USER_VERBS_CMD_MODIFY_SRQ = (int)33L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_MODIFY_SRQ = 33
     * }
     */
    public static int IB_USER_VERBS_CMD_MODIFY_SRQ() {
        return IB_USER_VERBS_CMD_MODIFY_SRQ;
    }
    private static final int IB_USER_VERBS_CMD_QUERY_SRQ = (int)34L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_QUERY_SRQ = 34
     * }
     */
    public static int IB_USER_VERBS_CMD_QUERY_SRQ() {
        return IB_USER_VERBS_CMD_QUERY_SRQ;
    }
    private static final int IB_USER_VERBS_CMD_DESTROY_SRQ = (int)35L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_DESTROY_SRQ = 35
     * }
     */
    public static int IB_USER_VERBS_CMD_DESTROY_SRQ() {
        return IB_USER_VERBS_CMD_DESTROY_SRQ;
    }
    private static final int IB_USER_VERBS_CMD_POST_SRQ_RECV = (int)36L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_POST_SRQ_RECV = 36
     * }
     */
    public static int IB_USER_VERBS_CMD_POST_SRQ_RECV() {
        return IB_USER_VERBS_CMD_POST_SRQ_RECV;
    }
    private static final int IB_USER_VERBS_CMD_OPEN_XRCD = (int)37L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_OPEN_XRCD = 37
     * }
     */
    public static int IB_USER_VERBS_CMD_OPEN_XRCD() {
        return IB_USER_VERBS_CMD_OPEN_XRCD;
    }
    private static final int IB_USER_VERBS_CMD_CLOSE_XRCD = (int)38L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_CLOSE_XRCD = 38
     * }
     */
    public static int IB_USER_VERBS_CMD_CLOSE_XRCD() {
        return IB_USER_VERBS_CMD_CLOSE_XRCD;
    }
    private static final int IB_USER_VERBS_CMD_CREATE_XSRQ = (int)39L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_CREATE_XSRQ = 39
     * }
     */
    public static int IB_USER_VERBS_CMD_CREATE_XSRQ() {
        return IB_USER_VERBS_CMD_CREATE_XSRQ;
    }
    private static final int IB_USER_VERBS_CMD_OPEN_QP = (int)40L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_write_cmds.IB_USER_VERBS_CMD_OPEN_QP = 40
     * }
     */
    public static int IB_USER_VERBS_CMD_OPEN_QP() {
        return IB_USER_VERBS_CMD_OPEN_QP;
    }
    private static final int IB_USER_VERBS_EX_CMD_QUERY_DEVICE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IB_USER_VERBS_EX_CMD_QUERY_DEVICE = 1
     * }
     */
    public static int IB_USER_VERBS_EX_CMD_QUERY_DEVICE() {
        return IB_USER_VERBS_EX_CMD_QUERY_DEVICE;
    }
    private static final int IB_USER_VERBS_EX_CMD_CREATE_CQ = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IB_USER_VERBS_EX_CMD_CREATE_CQ = 18
     * }
     */
    public static int IB_USER_VERBS_EX_CMD_CREATE_CQ() {
        return IB_USER_VERBS_EX_CMD_CREATE_CQ;
    }
    private static final int IB_USER_VERBS_EX_CMD_CREATE_QP = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IB_USER_VERBS_EX_CMD_CREATE_QP = 24
     * }
     */
    public static int IB_USER_VERBS_EX_CMD_CREATE_QP() {
        return IB_USER_VERBS_EX_CMD_CREATE_QP;
    }
    private static final int IB_USER_VERBS_EX_CMD_MODIFY_QP = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IB_USER_VERBS_EX_CMD_MODIFY_QP = 26
     * }
     */
    public static int IB_USER_VERBS_EX_CMD_MODIFY_QP() {
        return IB_USER_VERBS_EX_CMD_MODIFY_QP;
    }
    private static final int IB_USER_VERBS_EX_CMD_CREATE_FLOW = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IB_USER_VERBS_EX_CMD_CREATE_FLOW = 50
     * }
     */
    public static int IB_USER_VERBS_EX_CMD_CREATE_FLOW() {
        return IB_USER_VERBS_EX_CMD_CREATE_FLOW;
    }
    private static final int IB_USER_VERBS_EX_CMD_DESTROY_FLOW = (int)51L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IB_USER_VERBS_EX_CMD_DESTROY_FLOW = 51
     * }
     */
    public static int IB_USER_VERBS_EX_CMD_DESTROY_FLOW() {
        return IB_USER_VERBS_EX_CMD_DESTROY_FLOW;
    }
    private static final int IB_USER_VERBS_EX_CMD_CREATE_WQ = (int)52L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IB_USER_VERBS_EX_CMD_CREATE_WQ = 52
     * }
     */
    public static int IB_USER_VERBS_EX_CMD_CREATE_WQ() {
        return IB_USER_VERBS_EX_CMD_CREATE_WQ;
    }
    private static final int IB_USER_VERBS_EX_CMD_MODIFY_WQ = (int)53L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IB_USER_VERBS_EX_CMD_MODIFY_WQ = 53
     * }
     */
    public static int IB_USER_VERBS_EX_CMD_MODIFY_WQ() {
        return IB_USER_VERBS_EX_CMD_MODIFY_WQ;
    }
    private static final int IB_USER_VERBS_EX_CMD_DESTROY_WQ = (int)54L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IB_USER_VERBS_EX_CMD_DESTROY_WQ = 54
     * }
     */
    public static int IB_USER_VERBS_EX_CMD_DESTROY_WQ() {
        return IB_USER_VERBS_EX_CMD_DESTROY_WQ;
    }
    private static final int IB_USER_VERBS_EX_CMD_CREATE_RWQ_IND_TBL = (int)55L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IB_USER_VERBS_EX_CMD_CREATE_RWQ_IND_TBL = 55
     * }
     */
    public static int IB_USER_VERBS_EX_CMD_CREATE_RWQ_IND_TBL() {
        return IB_USER_VERBS_EX_CMD_CREATE_RWQ_IND_TBL;
    }
    private static final int IB_USER_VERBS_EX_CMD_DESTROY_RWQ_IND_TBL = (int)56L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IB_USER_VERBS_EX_CMD_DESTROY_RWQ_IND_TBL = 56
     * }
     */
    public static int IB_USER_VERBS_EX_CMD_DESTROY_RWQ_IND_TBL() {
        return IB_USER_VERBS_EX_CMD_DESTROY_RWQ_IND_TBL;
    }
    private static final int IB_USER_VERBS_EX_CMD_MODIFY_CQ = (int)57L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IB_USER_VERBS_EX_CMD_MODIFY_CQ = 57
     * }
     */
    public static int IB_USER_VERBS_EX_CMD_MODIFY_CQ() {
        return IB_USER_VERBS_EX_CMD_MODIFY_CQ;
    }
    private static final int IB_UVERBS_CQ_FLAGS_TIMESTAMP_COMPLETION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_ex_create_cq_flags.IB_UVERBS_CQ_FLAGS_TIMESTAMP_COMPLETION = 1
     * }
     */
    public static int IB_UVERBS_CQ_FLAGS_TIMESTAMP_COMPLETION() {
        return IB_UVERBS_CQ_FLAGS_TIMESTAMP_COMPLETION;
    }
    private static final int IB_UVERBS_CQ_FLAGS_IGNORE_OVERRUN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_ex_create_cq_flags.IB_UVERBS_CQ_FLAGS_IGNORE_OVERRUN = 2
     * }
     */
    public static int IB_UVERBS_CQ_FLAGS_IGNORE_OVERRUN() {
        return IB_UVERBS_CQ_FLAGS_IGNORE_OVERRUN;
    }
    private static final int IB_UVERBS_WC_SEND = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wc_opcode.IB_UVERBS_WC_SEND = 0
     * }
     */
    public static int IB_UVERBS_WC_SEND() {
        return IB_UVERBS_WC_SEND;
    }
    private static final int IB_UVERBS_WC_RDMA_WRITE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wc_opcode.IB_UVERBS_WC_RDMA_WRITE = 1
     * }
     */
    public static int IB_UVERBS_WC_RDMA_WRITE() {
        return IB_UVERBS_WC_RDMA_WRITE;
    }
    private static final int IB_UVERBS_WC_RDMA_READ = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wc_opcode.IB_UVERBS_WC_RDMA_READ = 2
     * }
     */
    public static int IB_UVERBS_WC_RDMA_READ() {
        return IB_UVERBS_WC_RDMA_READ;
    }
    private static final int IB_UVERBS_WC_COMP_SWAP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wc_opcode.IB_UVERBS_WC_COMP_SWAP = 3
     * }
     */
    public static int IB_UVERBS_WC_COMP_SWAP() {
        return IB_UVERBS_WC_COMP_SWAP;
    }
    private static final int IB_UVERBS_WC_FETCH_ADD = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wc_opcode.IB_UVERBS_WC_FETCH_ADD = 4
     * }
     */
    public static int IB_UVERBS_WC_FETCH_ADD() {
        return IB_UVERBS_WC_FETCH_ADD;
    }
    private static final int IB_UVERBS_WC_BIND_MW = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wc_opcode.IB_UVERBS_WC_BIND_MW = 5
     * }
     */
    public static int IB_UVERBS_WC_BIND_MW() {
        return IB_UVERBS_WC_BIND_MW;
    }
    private static final int IB_UVERBS_WC_LOCAL_INV = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wc_opcode.IB_UVERBS_WC_LOCAL_INV = 6
     * }
     */
    public static int IB_UVERBS_WC_LOCAL_INV() {
        return IB_UVERBS_WC_LOCAL_INV;
    }
    private static final int IB_UVERBS_WC_TSO = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wc_opcode.IB_UVERBS_WC_TSO = 7
     * }
     */
    public static int IB_UVERBS_WC_TSO() {
        return IB_UVERBS_WC_TSO;
    }
    private static final int IB_UVERBS_CREATE_QP_MASK_IND_TABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_create_qp_mask.IB_UVERBS_CREATE_QP_MASK_IND_TABLE = 1
     * }
     */
    public static int IB_UVERBS_CREATE_QP_MASK_IND_TABLE() {
        return IB_UVERBS_CREATE_QP_MASK_IND_TABLE;
    }
    private static final int IB_UVERBS_CREATE_QP_SUP_COMP_MASK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IB_UVERBS_CREATE_QP_SUP_COMP_MASK = 1
     * }
     */
    public static int IB_UVERBS_CREATE_QP_SUP_COMP_MASK() {
        return IB_UVERBS_CREATE_QP_SUP_COMP_MASK;
    }
    private static final int IB_UVERBS_WR_RDMA_WRITE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wr_opcode.IB_UVERBS_WR_RDMA_WRITE = 0
     * }
     */
    public static int IB_UVERBS_WR_RDMA_WRITE() {
        return IB_UVERBS_WR_RDMA_WRITE;
    }
    private static final int IB_UVERBS_WR_RDMA_WRITE_WITH_IMM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wr_opcode.IB_UVERBS_WR_RDMA_WRITE_WITH_IMM = 1
     * }
     */
    public static int IB_UVERBS_WR_RDMA_WRITE_WITH_IMM() {
        return IB_UVERBS_WR_RDMA_WRITE_WITH_IMM;
    }
    private static final int IB_UVERBS_WR_SEND = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wr_opcode.IB_UVERBS_WR_SEND = 2
     * }
     */
    public static int IB_UVERBS_WR_SEND() {
        return IB_UVERBS_WR_SEND;
    }
    private static final int IB_UVERBS_WR_SEND_WITH_IMM = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wr_opcode.IB_UVERBS_WR_SEND_WITH_IMM = 3
     * }
     */
    public static int IB_UVERBS_WR_SEND_WITH_IMM() {
        return IB_UVERBS_WR_SEND_WITH_IMM;
    }
    private static final int IB_UVERBS_WR_RDMA_READ = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wr_opcode.IB_UVERBS_WR_RDMA_READ = 4
     * }
     */
    public static int IB_UVERBS_WR_RDMA_READ() {
        return IB_UVERBS_WR_RDMA_READ;
    }
    private static final int IB_UVERBS_WR_ATOMIC_CMP_AND_SWP = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wr_opcode.IB_UVERBS_WR_ATOMIC_CMP_AND_SWP = 5
     * }
     */
    public static int IB_UVERBS_WR_ATOMIC_CMP_AND_SWP() {
        return IB_UVERBS_WR_ATOMIC_CMP_AND_SWP;
    }
    private static final int IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wr_opcode.IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD = 6
     * }
     */
    public static int IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD() {
        return IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD;
    }
    private static final int IB_UVERBS_WR_LOCAL_INV = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wr_opcode.IB_UVERBS_WR_LOCAL_INV = 7
     * }
     */
    public static int IB_UVERBS_WR_LOCAL_INV() {
        return IB_UVERBS_WR_LOCAL_INV;
    }
    private static final int IB_UVERBS_WR_BIND_MW = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wr_opcode.IB_UVERBS_WR_BIND_MW = 8
     * }
     */
    public static int IB_UVERBS_WR_BIND_MW() {
        return IB_UVERBS_WR_BIND_MW;
    }
    private static final int IB_UVERBS_WR_SEND_WITH_INV = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wr_opcode.IB_UVERBS_WR_SEND_WITH_INV = 9
     * }
     */
    public static int IB_UVERBS_WR_SEND_WITH_INV() {
        return IB_UVERBS_WR_SEND_WITH_INV;
    }
    private static final int IB_UVERBS_WR_TSO = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wr_opcode.IB_UVERBS_WR_TSO = 10
     * }
     */
    public static int IB_UVERBS_WR_TSO() {
        return IB_UVERBS_WR_TSO;
    }
    private static final int IB_UVERBS_WR_RDMA_READ_WITH_INV = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wr_opcode.IB_UVERBS_WR_RDMA_READ_WITH_INV = 11
     * }
     */
    public static int IB_UVERBS_WR_RDMA_READ_WITH_INV() {
        return IB_UVERBS_WR_RDMA_READ_WITH_INV;
    }
    private static final int IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wr_opcode.IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP = 12
     * }
     */
    public static int IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP() {
        return IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP;
    }
    private static final int IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wr_opcode.IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13
     * }
     */
    public static int IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD() {
        return IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD;
    }
    private static final int IB_UVERBS_CORE_SUPPORT_OPTIONAL_MR_ACCESS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_core_support.IB_UVERBS_CORE_SUPPORT_OPTIONAL_MR_ACCESS = 1
     * }
     */
    public static int IB_UVERBS_CORE_SUPPORT_OPTIONAL_MR_ACCESS() {
        return IB_UVERBS_CORE_SUPPORT_OPTIONAL_MR_ACCESS;
    }
    private static final int IB_UVERBS_ACCESS_LOCAL_WRITE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_access_flags.IB_UVERBS_ACCESS_LOCAL_WRITE = 1
     * }
     */
    public static int IB_UVERBS_ACCESS_LOCAL_WRITE() {
        return IB_UVERBS_ACCESS_LOCAL_WRITE;
    }
    private static final int IB_UVERBS_ACCESS_REMOTE_WRITE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_access_flags.IB_UVERBS_ACCESS_REMOTE_WRITE = 2
     * }
     */
    public static int IB_UVERBS_ACCESS_REMOTE_WRITE() {
        return IB_UVERBS_ACCESS_REMOTE_WRITE;
    }
    private static final int IB_UVERBS_ACCESS_REMOTE_READ = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_access_flags.IB_UVERBS_ACCESS_REMOTE_READ = 4
     * }
     */
    public static int IB_UVERBS_ACCESS_REMOTE_READ() {
        return IB_UVERBS_ACCESS_REMOTE_READ;
    }
    private static final int IB_UVERBS_ACCESS_REMOTE_ATOMIC = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_access_flags.IB_UVERBS_ACCESS_REMOTE_ATOMIC = 8
     * }
     */
    public static int IB_UVERBS_ACCESS_REMOTE_ATOMIC() {
        return IB_UVERBS_ACCESS_REMOTE_ATOMIC;
    }
    private static final int IB_UVERBS_ACCESS_MW_BIND = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_access_flags.IB_UVERBS_ACCESS_MW_BIND = 16
     * }
     */
    public static int IB_UVERBS_ACCESS_MW_BIND() {
        return IB_UVERBS_ACCESS_MW_BIND;
    }
    private static final int IB_UVERBS_ACCESS_ZERO_BASED = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_access_flags.IB_UVERBS_ACCESS_ZERO_BASED = 32
     * }
     */
    public static int IB_UVERBS_ACCESS_ZERO_BASED() {
        return IB_UVERBS_ACCESS_ZERO_BASED;
    }
    private static final int IB_UVERBS_ACCESS_ON_DEMAND = (int)64L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_access_flags.IB_UVERBS_ACCESS_ON_DEMAND = 64
     * }
     */
    public static int IB_UVERBS_ACCESS_ON_DEMAND() {
        return IB_UVERBS_ACCESS_ON_DEMAND;
    }
    private static final int IB_UVERBS_ACCESS_HUGETLB = (int)128L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_access_flags.IB_UVERBS_ACCESS_HUGETLB = 128
     * }
     */
    public static int IB_UVERBS_ACCESS_HUGETLB() {
        return IB_UVERBS_ACCESS_HUGETLB;
    }
    private static final int IB_UVERBS_ACCESS_RELAXED_ORDERING = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_access_flags.IB_UVERBS_ACCESS_RELAXED_ORDERING = 1048576
     * }
     */
    public static int IB_UVERBS_ACCESS_RELAXED_ORDERING() {
        return IB_UVERBS_ACCESS_RELAXED_ORDERING;
    }
    private static final int IB_UVERBS_ACCESS_OPTIONAL_RANGE = (int)1072693248L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_access_flags.IB_UVERBS_ACCESS_OPTIONAL_RANGE = 1072693248
     * }
     */
    public static int IB_UVERBS_ACCESS_OPTIONAL_RANGE() {
        return IB_UVERBS_ACCESS_OPTIONAL_RANGE;
    }
    private static final int IB_UVERBS_SRQT_BASIC = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_srq_type.IB_UVERBS_SRQT_BASIC = 0
     * }
     */
    public static int IB_UVERBS_SRQT_BASIC() {
        return IB_UVERBS_SRQT_BASIC;
    }
    private static final int IB_UVERBS_SRQT_XRC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_srq_type.IB_UVERBS_SRQT_XRC = 1
     * }
     */
    public static int IB_UVERBS_SRQT_XRC() {
        return IB_UVERBS_SRQT_XRC;
    }
    private static final int IB_UVERBS_SRQT_TM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_srq_type.IB_UVERBS_SRQT_TM = 2
     * }
     */
    public static int IB_UVERBS_SRQT_TM() {
        return IB_UVERBS_SRQT_TM;
    }
    private static final int IB_UVERBS_WQT_RQ = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wq_type.IB_UVERBS_WQT_RQ = 0
     * }
     */
    public static int IB_UVERBS_WQT_RQ() {
        return IB_UVERBS_WQT_RQ;
    }
    private static final int IB_UVERBS_WQ_FLAGS_CVLAN_STRIPPING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wq_flags.IB_UVERBS_WQ_FLAGS_CVLAN_STRIPPING = 1
     * }
     */
    public static int IB_UVERBS_WQ_FLAGS_CVLAN_STRIPPING() {
        return IB_UVERBS_WQ_FLAGS_CVLAN_STRIPPING;
    }
    private static final int IB_UVERBS_WQ_FLAGS_SCATTER_FCS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wq_flags.IB_UVERBS_WQ_FLAGS_SCATTER_FCS = 2
     * }
     */
    public static int IB_UVERBS_WQ_FLAGS_SCATTER_FCS() {
        return IB_UVERBS_WQ_FLAGS_SCATTER_FCS;
    }
    private static final int IB_UVERBS_WQ_FLAGS_DELAY_DROP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wq_flags.IB_UVERBS_WQ_FLAGS_DELAY_DROP = 4
     * }
     */
    public static int IB_UVERBS_WQ_FLAGS_DELAY_DROP() {
        return IB_UVERBS_WQ_FLAGS_DELAY_DROP;
    }
    private static final int IB_UVERBS_WQ_FLAGS_PCI_WRITE_END_PADDING = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_wq_flags.IB_UVERBS_WQ_FLAGS_PCI_WRITE_END_PADDING = 8
     * }
     */
    public static int IB_UVERBS_WQ_FLAGS_PCI_WRITE_END_PADDING() {
        return IB_UVERBS_WQ_FLAGS_PCI_WRITE_END_PADDING;
    }
    private static final int IB_UVERBS_QPT_RC = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_qp_type.IB_UVERBS_QPT_RC = 2
     * }
     */
    public static int IB_UVERBS_QPT_RC() {
        return IB_UVERBS_QPT_RC;
    }
    private static final int IB_UVERBS_QPT_UC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_qp_type.IB_UVERBS_QPT_UC = 3
     * }
     */
    public static int IB_UVERBS_QPT_UC() {
        return IB_UVERBS_QPT_UC;
    }
    private static final int IB_UVERBS_QPT_UD = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_qp_type.IB_UVERBS_QPT_UD = 4
     * }
     */
    public static int IB_UVERBS_QPT_UD() {
        return IB_UVERBS_QPT_UD;
    }
    private static final int IB_UVERBS_QPT_RAW_PACKET = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_qp_type.IB_UVERBS_QPT_RAW_PACKET = 8
     * }
     */
    public static int IB_UVERBS_QPT_RAW_PACKET() {
        return IB_UVERBS_QPT_RAW_PACKET;
    }
    private static final int IB_UVERBS_QPT_XRC_INI = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_qp_type.IB_UVERBS_QPT_XRC_INI = 9
     * }
     */
    public static int IB_UVERBS_QPT_XRC_INI() {
        return IB_UVERBS_QPT_XRC_INI;
    }
    private static final int IB_UVERBS_QPT_XRC_TGT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_qp_type.IB_UVERBS_QPT_XRC_TGT = 10
     * }
     */
    public static int IB_UVERBS_QPT_XRC_TGT() {
        return IB_UVERBS_QPT_XRC_TGT;
    }
    private static final int IB_UVERBS_QPT_DRIVER = (int)255L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_qp_type.IB_UVERBS_QPT_DRIVER = 255
     * }
     */
    public static int IB_UVERBS_QPT_DRIVER() {
        return IB_UVERBS_QPT_DRIVER;
    }
    private static final int IB_UVERBS_QP_CREATE_BLOCK_MULTICAST_LOOPBACK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_qp_create_flags.IB_UVERBS_QP_CREATE_BLOCK_MULTICAST_LOOPBACK = 2
     * }
     */
    public static int IB_UVERBS_QP_CREATE_BLOCK_MULTICAST_LOOPBACK() {
        return IB_UVERBS_QP_CREATE_BLOCK_MULTICAST_LOOPBACK;
    }
    private static final int IB_UVERBS_QP_CREATE_SCATTER_FCS = (int)256L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_qp_create_flags.IB_UVERBS_QP_CREATE_SCATTER_FCS = 256
     * }
     */
    public static int IB_UVERBS_QP_CREATE_SCATTER_FCS() {
        return IB_UVERBS_QP_CREATE_SCATTER_FCS;
    }
    private static final int IB_UVERBS_QP_CREATE_CVLAN_STRIPPING = (int)512L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_qp_create_flags.IB_UVERBS_QP_CREATE_CVLAN_STRIPPING = 512
     * }
     */
    public static int IB_UVERBS_QP_CREATE_CVLAN_STRIPPING() {
        return IB_UVERBS_QP_CREATE_CVLAN_STRIPPING;
    }
    private static final int IB_UVERBS_QP_CREATE_PCI_WRITE_END_PADDING = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_qp_create_flags.IB_UVERBS_QP_CREATE_PCI_WRITE_END_PADDING = 2048
     * }
     */
    public static int IB_UVERBS_QP_CREATE_PCI_WRITE_END_PADDING() {
        return IB_UVERBS_QP_CREATE_PCI_WRITE_END_PADDING;
    }
    private static final int IB_UVERBS_QP_CREATE_SQ_SIG_ALL = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_qp_create_flags.IB_UVERBS_QP_CREATE_SQ_SIG_ALL = 4096
     * }
     */
    public static int IB_UVERBS_QP_CREATE_SQ_SIG_ALL() {
        return IB_UVERBS_QP_CREATE_SQ_SIG_ALL;
    }
    private static final int IB_UVERBS_PCF_SM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_SM = 2
     * }
     */
    public static int IB_UVERBS_PCF_SM() {
        return IB_UVERBS_PCF_SM;
    }
    private static final int IB_UVERBS_PCF_NOTICE_SUP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_NOTICE_SUP = 4
     * }
     */
    public static int IB_UVERBS_PCF_NOTICE_SUP() {
        return IB_UVERBS_PCF_NOTICE_SUP;
    }
    private static final int IB_UVERBS_PCF_TRAP_SUP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_TRAP_SUP = 8
     * }
     */
    public static int IB_UVERBS_PCF_TRAP_SUP() {
        return IB_UVERBS_PCF_TRAP_SUP;
    }
    private static final int IB_UVERBS_PCF_OPT_IPD_SUP = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_OPT_IPD_SUP = 16
     * }
     */
    public static int IB_UVERBS_PCF_OPT_IPD_SUP() {
        return IB_UVERBS_PCF_OPT_IPD_SUP;
    }
    private static final int IB_UVERBS_PCF_AUTO_MIGR_SUP = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_AUTO_MIGR_SUP = 32
     * }
     */
    public static int IB_UVERBS_PCF_AUTO_MIGR_SUP() {
        return IB_UVERBS_PCF_AUTO_MIGR_SUP;
    }
    private static final int IB_UVERBS_PCF_SL_MAP_SUP = (int)64L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_SL_MAP_SUP = 64
     * }
     */
    public static int IB_UVERBS_PCF_SL_MAP_SUP() {
        return IB_UVERBS_PCF_SL_MAP_SUP;
    }
    private static final int IB_UVERBS_PCF_MKEY_NVRAM = (int)128L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_MKEY_NVRAM = 128
     * }
     */
    public static int IB_UVERBS_PCF_MKEY_NVRAM() {
        return IB_UVERBS_PCF_MKEY_NVRAM;
    }
    private static final int IB_UVERBS_PCF_PKEY_NVRAM = (int)256L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_PKEY_NVRAM = 256
     * }
     */
    public static int IB_UVERBS_PCF_PKEY_NVRAM() {
        return IB_UVERBS_PCF_PKEY_NVRAM;
    }
    private static final int IB_UVERBS_PCF_LED_INFO_SUP = (int)512L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_LED_INFO_SUP = 512
     * }
     */
    public static int IB_UVERBS_PCF_LED_INFO_SUP() {
        return IB_UVERBS_PCF_LED_INFO_SUP;
    }
    private static final int IB_UVERBS_PCF_SM_DISABLED = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_SM_DISABLED = 1024
     * }
     */
    public static int IB_UVERBS_PCF_SM_DISABLED() {
        return IB_UVERBS_PCF_SM_DISABLED;
    }
    private static final int IB_UVERBS_PCF_SYS_IMAGE_GUID_SUP = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_SYS_IMAGE_GUID_SUP = 2048
     * }
     */
    public static int IB_UVERBS_PCF_SYS_IMAGE_GUID_SUP() {
        return IB_UVERBS_PCF_SYS_IMAGE_GUID_SUP;
    }
    private static final int IB_UVERBS_PCF_PKEY_SW_EXT_PORT_TRAP_SUP = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_PKEY_SW_EXT_PORT_TRAP_SUP = 4096
     * }
     */
    public static int IB_UVERBS_PCF_PKEY_SW_EXT_PORT_TRAP_SUP() {
        return IB_UVERBS_PCF_PKEY_SW_EXT_PORT_TRAP_SUP;
    }
    private static final int IB_UVERBS_PCF_EXTENDED_SPEEDS_SUP = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_EXTENDED_SPEEDS_SUP = 16384
     * }
     */
    public static int IB_UVERBS_PCF_EXTENDED_SPEEDS_SUP() {
        return IB_UVERBS_PCF_EXTENDED_SPEEDS_SUP;
    }
    private static final int IB_UVERBS_PCF_CM_SUP = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_CM_SUP = 65536
     * }
     */
    public static int IB_UVERBS_PCF_CM_SUP() {
        return IB_UVERBS_PCF_CM_SUP;
    }
    private static final int IB_UVERBS_PCF_SNMP_TUNNEL_SUP = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_SNMP_TUNNEL_SUP = 131072
     * }
     */
    public static int IB_UVERBS_PCF_SNMP_TUNNEL_SUP() {
        return IB_UVERBS_PCF_SNMP_TUNNEL_SUP;
    }
    private static final int IB_UVERBS_PCF_REINIT_SUP = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_REINIT_SUP = 262144
     * }
     */
    public static int IB_UVERBS_PCF_REINIT_SUP() {
        return IB_UVERBS_PCF_REINIT_SUP;
    }
    private static final int IB_UVERBS_PCF_DEVICE_MGMT_SUP = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_DEVICE_MGMT_SUP = 524288
     * }
     */
    public static int IB_UVERBS_PCF_DEVICE_MGMT_SUP() {
        return IB_UVERBS_PCF_DEVICE_MGMT_SUP;
    }
    private static final int IB_UVERBS_PCF_VENDOR_CLASS_SUP = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_VENDOR_CLASS_SUP = 1048576
     * }
     */
    public static int IB_UVERBS_PCF_VENDOR_CLASS_SUP() {
        return IB_UVERBS_PCF_VENDOR_CLASS_SUP;
    }
    private static final int IB_UVERBS_PCF_DR_NOTICE_SUP = (int)2097152L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_DR_NOTICE_SUP = 2097152
     * }
     */
    public static int IB_UVERBS_PCF_DR_NOTICE_SUP() {
        return IB_UVERBS_PCF_DR_NOTICE_SUP;
    }
    private static final int IB_UVERBS_PCF_CAP_MASK_NOTICE_SUP = (int)4194304L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_CAP_MASK_NOTICE_SUP = 4194304
     * }
     */
    public static int IB_UVERBS_PCF_CAP_MASK_NOTICE_SUP() {
        return IB_UVERBS_PCF_CAP_MASK_NOTICE_SUP;
    }
    private static final int IB_UVERBS_PCF_BOOT_MGMT_SUP = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_BOOT_MGMT_SUP = 8388608
     * }
     */
    public static int IB_UVERBS_PCF_BOOT_MGMT_SUP() {
        return IB_UVERBS_PCF_BOOT_MGMT_SUP;
    }
    private static final int IB_UVERBS_PCF_LINK_LATENCY_SUP = (int)16777216L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_LINK_LATENCY_SUP = 16777216
     * }
     */
    public static int IB_UVERBS_PCF_LINK_LATENCY_SUP() {
        return IB_UVERBS_PCF_LINK_LATENCY_SUP;
    }
    private static final int IB_UVERBS_PCF_CLIENT_REG_SUP = (int)33554432L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_CLIENT_REG_SUP = 33554432
     * }
     */
    public static int IB_UVERBS_PCF_CLIENT_REG_SUP() {
        return IB_UVERBS_PCF_CLIENT_REG_SUP;
    }
    private static final int IB_UVERBS_PCF_LINK_SPEED_WIDTH_TABLE_SUP = (int)134217728L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_LINK_SPEED_WIDTH_TABLE_SUP = 134217728
     * }
     */
    public static int IB_UVERBS_PCF_LINK_SPEED_WIDTH_TABLE_SUP() {
        return IB_UVERBS_PCF_LINK_SPEED_WIDTH_TABLE_SUP;
    }
    private static final int IB_UVERBS_PCF_VENDOR_SPECIFIC_MADS_TABLE_SUP = (int)268435456L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_VENDOR_SPECIFIC_MADS_TABLE_SUP = 268435456
     * }
     */
    public static int IB_UVERBS_PCF_VENDOR_SPECIFIC_MADS_TABLE_SUP() {
        return IB_UVERBS_PCF_VENDOR_SPECIFIC_MADS_TABLE_SUP;
    }
    private static final int IB_UVERBS_PCF_MCAST_PKEY_TRAP_SUPPRESSION_SUP = (int)536870912L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_MCAST_PKEY_TRAP_SUPPRESSION_SUP = 536870912
     * }
     */
    public static int IB_UVERBS_PCF_MCAST_PKEY_TRAP_SUPPRESSION_SUP() {
        return IB_UVERBS_PCF_MCAST_PKEY_TRAP_SUPPRESSION_SUP;
    }
    private static final int IB_UVERBS_PCF_MCAST_FDB_TOP_SUP = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_MCAST_FDB_TOP_SUP = 1073741824
     * }
     */
    public static int IB_UVERBS_PCF_MCAST_FDB_TOP_SUP() {
        return IB_UVERBS_PCF_MCAST_FDB_TOP_SUP;
    }
    private static final int IB_UVERBS_PCF_HIERARCHY_INFO_SUP = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_HIERARCHY_INFO_SUP = -2147483648
     * }
     */
    public static int IB_UVERBS_PCF_HIERARCHY_INFO_SUP() {
        return IB_UVERBS_PCF_HIERARCHY_INFO_SUP;
    }
    private static final int IB_UVERBS_PCF_IP_BASED_GIDS = (int)67108864L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_cap_flags.IB_UVERBS_PCF_IP_BASED_GIDS = 67108864
     * }
     */
    public static int IB_UVERBS_PCF_IP_BASED_GIDS() {
        return IB_UVERBS_PCF_IP_BASED_GIDS;
    }
    private static final int IB_UVERBS_QPF_GRH_REQUIRED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_query_port_flags.IB_UVERBS_QPF_GRH_REQUIRED = 1
     * }
     */
    public static int IB_UVERBS_QPF_GRH_REQUIRED() {
        return IB_UVERBS_QPF_GRH_REQUIRED;
    }
    private static final int IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_flow_action_esp_keymat.IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM = 0
     * }
     */
    public static int IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM() {
        return IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM;
    }
    private static final int IB_UVERBS_FLOW_ACTION_IV_ALGO_SEQ = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_flow_action_esp_keymat_aes_gcm_iv_algo.IB_UVERBS_FLOW_ACTION_IV_ALGO_SEQ = 0
     * }
     */
    public static int IB_UVERBS_FLOW_ACTION_IV_ALGO_SEQ() {
        return IB_UVERBS_FLOW_ACTION_IV_ALGO_SEQ;
    }
    private static final int IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_flow_action_esp_replay.IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE = 0
     * }
     */
    public static int IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE() {
        return IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE;
    }
    private static final int IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_flow_action_esp_replay.IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP = 1
     * }
     */
    public static int IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP() {
        return IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP;
    }
    private static final int IB_UVERBS_FLOW_ACTION_ESP_FLAGS_INLINE_CRYPTO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_flow_action_esp_flags.IB_UVERBS_FLOW_ACTION_ESP_FLAGS_INLINE_CRYPTO = 0
     * }
     */
    public static int IB_UVERBS_FLOW_ACTION_ESP_FLAGS_INLINE_CRYPTO() {
        return IB_UVERBS_FLOW_ACTION_ESP_FLAGS_INLINE_CRYPTO;
    }
    private static final int IB_UVERBS_FLOW_ACTION_ESP_FLAGS_FULL_OFFLOAD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_flow_action_esp_flags.IB_UVERBS_FLOW_ACTION_ESP_FLAGS_FULL_OFFLOAD = 1
     * }
     */
    public static int IB_UVERBS_FLOW_ACTION_ESP_FLAGS_FULL_OFFLOAD() {
        return IB_UVERBS_FLOW_ACTION_ESP_FLAGS_FULL_OFFLOAD;
    }
    private static final int IB_UVERBS_FLOW_ACTION_ESP_FLAGS_TUNNEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_flow_action_esp_flags.IB_UVERBS_FLOW_ACTION_ESP_FLAGS_TUNNEL = 0
     * }
     */
    public static int IB_UVERBS_FLOW_ACTION_ESP_FLAGS_TUNNEL() {
        return IB_UVERBS_FLOW_ACTION_ESP_FLAGS_TUNNEL;
    }
    private static final int IB_UVERBS_FLOW_ACTION_ESP_FLAGS_TRANSPORT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_flow_action_esp_flags.IB_UVERBS_FLOW_ACTION_ESP_FLAGS_TRANSPORT = 2
     * }
     */
    public static int IB_UVERBS_FLOW_ACTION_ESP_FLAGS_TRANSPORT() {
        return IB_UVERBS_FLOW_ACTION_ESP_FLAGS_TRANSPORT;
    }
    private static final int IB_UVERBS_FLOW_ACTION_ESP_FLAGS_DECRYPT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_flow_action_esp_flags.IB_UVERBS_FLOW_ACTION_ESP_FLAGS_DECRYPT = 0
     * }
     */
    public static int IB_UVERBS_FLOW_ACTION_ESP_FLAGS_DECRYPT() {
        return IB_UVERBS_FLOW_ACTION_ESP_FLAGS_DECRYPT;
    }
    private static final int IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ENCRYPT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_flow_action_esp_flags.IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ENCRYPT = 4
     * }
     */
    public static int IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ENCRYPT() {
        return IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ENCRYPT;
    }
    private static final int IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ESN_NEW_WINDOW = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_flow_action_esp_flags.IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ESN_NEW_WINDOW = 8
     * }
     */
    public static int IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ESN_NEW_WINDOW() {
        return IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ESN_NEW_WINDOW;
    }
    private static final int IB_UVERBS_READ_COUNTERS_PREFER_CACHED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_read_counters_flags.IB_UVERBS_READ_COUNTERS_PREFER_CACHED = 1
     * }
     */
    public static int IB_UVERBS_READ_COUNTERS_PREFER_CACHED() {
        return IB_UVERBS_READ_COUNTERS_PREFER_CACHED;
    }
    private static final int IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_advise_mr_advice.IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH = 0
     * }
     */
    public static int IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH() {
        return IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH;
    }
    private static final int IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_advise_mr_advice.IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE = 1
     * }
     */
    public static int IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE() {
        return IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE;
    }
    private static final int IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_advise_mr_advice.IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT = 2
     * }
     */
    public static int IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT() {
        return IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT;
    }
    private static final int IB_UVERBS_ADVISE_MR_FLAG_FLUSH = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_advise_mr_flag.IB_UVERBS_ADVISE_MR_FLAG_FLUSH = 1
     * }
     */
    public static int IB_UVERBS_ADVISE_MR_FLAG_FLUSH() {
        return IB_UVERBS_ADVISE_MR_FLAG_FLUSH;
    }
    private static final int RDMA_DRIVER_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_UNKNOWN = 0
     * }
     */
    public static int RDMA_DRIVER_UNKNOWN() {
        return RDMA_DRIVER_UNKNOWN;
    }
    private static final int RDMA_DRIVER_MLX5 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_MLX5 = 1
     * }
     */
    public static int RDMA_DRIVER_MLX5() {
        return RDMA_DRIVER_MLX5;
    }
    private static final int RDMA_DRIVER_MLX4 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_MLX4 = 2
     * }
     */
    public static int RDMA_DRIVER_MLX4() {
        return RDMA_DRIVER_MLX4;
    }
    private static final int RDMA_DRIVER_CXGB3 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_CXGB3 = 3
     * }
     */
    public static int RDMA_DRIVER_CXGB3() {
        return RDMA_DRIVER_CXGB3;
    }
    private static final int RDMA_DRIVER_CXGB4 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_CXGB4 = 4
     * }
     */
    public static int RDMA_DRIVER_CXGB4() {
        return RDMA_DRIVER_CXGB4;
    }
    private static final int RDMA_DRIVER_MTHCA = (int)5L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_MTHCA = 5
     * }
     */
    public static int RDMA_DRIVER_MTHCA() {
        return RDMA_DRIVER_MTHCA;
    }
    private static final int RDMA_DRIVER_BNXT_RE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_BNXT_RE = 6
     * }
     */
    public static int RDMA_DRIVER_BNXT_RE() {
        return RDMA_DRIVER_BNXT_RE;
    }
    private static final int RDMA_DRIVER_OCRDMA = (int)7L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_OCRDMA = 7
     * }
     */
    public static int RDMA_DRIVER_OCRDMA() {
        return RDMA_DRIVER_OCRDMA;
    }
    private static final int RDMA_DRIVER_NES = (int)8L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_NES = 8
     * }
     */
    public static int RDMA_DRIVER_NES() {
        return RDMA_DRIVER_NES;
    }
    private static final int RDMA_DRIVER_I40IW = (int)9L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_I40IW = 9
     * }
     */
    public static int RDMA_DRIVER_I40IW() {
        return RDMA_DRIVER_I40IW;
    }
    private static final int RDMA_DRIVER_IRDMA = (int)9L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_IRDMA = 9
     * }
     */
    public static int RDMA_DRIVER_IRDMA() {
        return RDMA_DRIVER_IRDMA;
    }
    private static final int RDMA_DRIVER_VMW_PVRDMA = (int)10L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_VMW_PVRDMA = 10
     * }
     */
    public static int RDMA_DRIVER_VMW_PVRDMA() {
        return RDMA_DRIVER_VMW_PVRDMA;
    }
    private static final int RDMA_DRIVER_QEDR = (int)11L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_QEDR = 11
     * }
     */
    public static int RDMA_DRIVER_QEDR() {
        return RDMA_DRIVER_QEDR;
    }
    private static final int RDMA_DRIVER_HNS = (int)12L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_HNS = 12
     * }
     */
    public static int RDMA_DRIVER_HNS() {
        return RDMA_DRIVER_HNS;
    }
    private static final int RDMA_DRIVER_USNIC = (int)13L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_USNIC = 13
     * }
     */
    public static int RDMA_DRIVER_USNIC() {
        return RDMA_DRIVER_USNIC;
    }
    private static final int RDMA_DRIVER_RXE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_RXE = 14
     * }
     */
    public static int RDMA_DRIVER_RXE() {
        return RDMA_DRIVER_RXE;
    }
    private static final int RDMA_DRIVER_HFI1 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_HFI1 = 15
     * }
     */
    public static int RDMA_DRIVER_HFI1() {
        return RDMA_DRIVER_HFI1;
    }
    private static final int RDMA_DRIVER_QIB = (int)16L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_QIB = 16
     * }
     */
    public static int RDMA_DRIVER_QIB() {
        return RDMA_DRIVER_QIB;
    }
    private static final int RDMA_DRIVER_EFA = (int)17L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_EFA = 17
     * }
     */
    public static int RDMA_DRIVER_EFA() {
        return RDMA_DRIVER_EFA;
    }
    private static final int RDMA_DRIVER_SIW = (int)18L;
    /**
     * {@snippet lang=c :
     * enum rdma_driver_id.RDMA_DRIVER_SIW = 18
     * }
     */
    public static int RDMA_DRIVER_SIW() {
        return RDMA_DRIVER_SIW;
    }
    private static final int IB_UVERBS_GID_TYPE_IB = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_gid_type.IB_UVERBS_GID_TYPE_IB = 0
     * }
     */
    public static int IB_UVERBS_GID_TYPE_IB() {
        return IB_UVERBS_GID_TYPE_IB;
    }
    private static final int IB_UVERBS_GID_TYPE_ROCE_V1 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_gid_type.IB_UVERBS_GID_TYPE_ROCE_V1 = 1
     * }
     */
    public static int IB_UVERBS_GID_TYPE_ROCE_V1() {
        return IB_UVERBS_GID_TYPE_ROCE_V1;
    }
    private static final int IB_UVERBS_GID_TYPE_ROCE_V2 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ib_uverbs_gid_type.IB_UVERBS_GID_TYPE_ROCE_V2 = 2
     * }
     */
    public static int IB_UVERBS_GID_TYPE_ROCE_V2() {
        return IB_UVERBS_GID_TYPE_ROCE_V2;
    }
    private static final int IBV_GID_TYPE_IB = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ibv_gid_type.IBV_GID_TYPE_IB = 0
     * }
     */
    public static int IBV_GID_TYPE_IB() {
        return IBV_GID_TYPE_IB;
    }
    private static final int IBV_GID_TYPE_ROCE_V1 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_gid_type.IBV_GID_TYPE_ROCE_V1 = 1
     * }
     */
    public static int IBV_GID_TYPE_ROCE_V1() {
        return IBV_GID_TYPE_ROCE_V1;
    }
    private static final int IBV_GID_TYPE_ROCE_V2 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_gid_type.IBV_GID_TYPE_ROCE_V2 = 2
     * }
     */
    public static int IBV_GID_TYPE_ROCE_V2() {
        return IBV_GID_TYPE_ROCE_V2;
    }
    private static final int IBV_NODE_UNKNOWN = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum ibv_node_type.IBV_NODE_UNKNOWN = -1
     * }
     */
    public static int IBV_NODE_UNKNOWN() {
        return IBV_NODE_UNKNOWN;
    }
    private static final int IBV_NODE_CA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_node_type.IBV_NODE_CA = 1
     * }
     */
    public static int IBV_NODE_CA() {
        return IBV_NODE_CA;
    }
    private static final int IBV_NODE_SWITCH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_node_type.IBV_NODE_SWITCH = 2
     * }
     */
    public static int IBV_NODE_SWITCH() {
        return IBV_NODE_SWITCH;
    }
    private static final int IBV_NODE_ROUTER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ibv_node_type.IBV_NODE_ROUTER = 3
     * }
     */
    public static int IBV_NODE_ROUTER() {
        return IBV_NODE_ROUTER;
    }
    private static final int IBV_NODE_RNIC = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ibv_node_type.IBV_NODE_RNIC = 4
     * }
     */
    public static int IBV_NODE_RNIC() {
        return IBV_NODE_RNIC;
    }
    private static final int IBV_NODE_USNIC = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ibv_node_type.IBV_NODE_USNIC = 5
     * }
     */
    public static int IBV_NODE_USNIC() {
        return IBV_NODE_USNIC;
    }
    private static final int IBV_NODE_USNIC_UDP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ibv_node_type.IBV_NODE_USNIC_UDP = 6
     * }
     */
    public static int IBV_NODE_USNIC_UDP() {
        return IBV_NODE_USNIC_UDP;
    }
    private static final int IBV_NODE_UNSPECIFIED = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ibv_node_type.IBV_NODE_UNSPECIFIED = 7
     * }
     */
    public static int IBV_NODE_UNSPECIFIED() {
        return IBV_NODE_UNSPECIFIED;
    }
    private static final int IBV_TRANSPORT_UNKNOWN = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum ibv_transport_type.IBV_TRANSPORT_UNKNOWN = -1
     * }
     */
    public static int IBV_TRANSPORT_UNKNOWN() {
        return IBV_TRANSPORT_UNKNOWN;
    }
    private static final int IBV_TRANSPORT_IB = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ibv_transport_type.IBV_TRANSPORT_IB = 0
     * }
     */
    public static int IBV_TRANSPORT_IB() {
        return IBV_TRANSPORT_IB;
    }
    private static final int IBV_TRANSPORT_IWARP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_transport_type.IBV_TRANSPORT_IWARP = 1
     * }
     */
    public static int IBV_TRANSPORT_IWARP() {
        return IBV_TRANSPORT_IWARP;
    }
    private static final int IBV_TRANSPORT_USNIC = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_transport_type.IBV_TRANSPORT_USNIC = 2
     * }
     */
    public static int IBV_TRANSPORT_USNIC() {
        return IBV_TRANSPORT_USNIC;
    }
    private static final int IBV_TRANSPORT_USNIC_UDP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ibv_transport_type.IBV_TRANSPORT_USNIC_UDP = 3
     * }
     */
    public static int IBV_TRANSPORT_USNIC_UDP() {
        return IBV_TRANSPORT_USNIC_UDP;
    }
    private static final int IBV_TRANSPORT_UNSPECIFIED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ibv_transport_type.IBV_TRANSPORT_UNSPECIFIED = 4
     * }
     */
    public static int IBV_TRANSPORT_UNSPECIFIED() {
        return IBV_TRANSPORT_UNSPECIFIED;
    }
    private static final int IBV_DEVICE_RESIZE_MAX_WR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_RESIZE_MAX_WR = 1
     * }
     */
    public static int IBV_DEVICE_RESIZE_MAX_WR() {
        return IBV_DEVICE_RESIZE_MAX_WR;
    }
    private static final int IBV_DEVICE_BAD_PKEY_CNTR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_BAD_PKEY_CNTR = 2
     * }
     */
    public static int IBV_DEVICE_BAD_PKEY_CNTR() {
        return IBV_DEVICE_BAD_PKEY_CNTR;
    }
    private static final int IBV_DEVICE_BAD_QKEY_CNTR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_BAD_QKEY_CNTR = 4
     * }
     */
    public static int IBV_DEVICE_BAD_QKEY_CNTR() {
        return IBV_DEVICE_BAD_QKEY_CNTR;
    }
    private static final int IBV_DEVICE_RAW_MULTI = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_RAW_MULTI = 8
     * }
     */
    public static int IBV_DEVICE_RAW_MULTI() {
        return IBV_DEVICE_RAW_MULTI;
    }
    private static final int IBV_DEVICE_AUTO_PATH_MIG = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_AUTO_PATH_MIG = 16
     * }
     */
    public static int IBV_DEVICE_AUTO_PATH_MIG() {
        return IBV_DEVICE_AUTO_PATH_MIG;
    }
    private static final int IBV_DEVICE_CHANGE_PHY_PORT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_CHANGE_PHY_PORT = 32
     * }
     */
    public static int IBV_DEVICE_CHANGE_PHY_PORT() {
        return IBV_DEVICE_CHANGE_PHY_PORT;
    }
    private static final int IBV_DEVICE_UD_AV_PORT_ENFORCE = (int)64L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_UD_AV_PORT_ENFORCE = 64
     * }
     */
    public static int IBV_DEVICE_UD_AV_PORT_ENFORCE() {
        return IBV_DEVICE_UD_AV_PORT_ENFORCE;
    }
    private static final int IBV_DEVICE_CURR_QP_STATE_MOD = (int)128L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_CURR_QP_STATE_MOD = 128
     * }
     */
    public static int IBV_DEVICE_CURR_QP_STATE_MOD() {
        return IBV_DEVICE_CURR_QP_STATE_MOD;
    }
    private static final int IBV_DEVICE_SHUTDOWN_PORT = (int)256L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_SHUTDOWN_PORT = 256
     * }
     */
    public static int IBV_DEVICE_SHUTDOWN_PORT() {
        return IBV_DEVICE_SHUTDOWN_PORT;
    }
    private static final int IBV_DEVICE_INIT_TYPE = (int)512L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_INIT_TYPE = 512
     * }
     */
    public static int IBV_DEVICE_INIT_TYPE() {
        return IBV_DEVICE_INIT_TYPE;
    }
    private static final int IBV_DEVICE_PORT_ACTIVE_EVENT = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_PORT_ACTIVE_EVENT = 1024
     * }
     */
    public static int IBV_DEVICE_PORT_ACTIVE_EVENT() {
        return IBV_DEVICE_PORT_ACTIVE_EVENT;
    }
    private static final int IBV_DEVICE_SYS_IMAGE_GUID = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_SYS_IMAGE_GUID = 2048
     * }
     */
    public static int IBV_DEVICE_SYS_IMAGE_GUID() {
        return IBV_DEVICE_SYS_IMAGE_GUID;
    }
    private static final int IBV_DEVICE_RC_RNR_NAK_GEN = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_RC_RNR_NAK_GEN = 4096
     * }
     */
    public static int IBV_DEVICE_RC_RNR_NAK_GEN() {
        return IBV_DEVICE_RC_RNR_NAK_GEN;
    }
    private static final int IBV_DEVICE_SRQ_RESIZE = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_SRQ_RESIZE = 8192
     * }
     */
    public static int IBV_DEVICE_SRQ_RESIZE() {
        return IBV_DEVICE_SRQ_RESIZE;
    }
    private static final int IBV_DEVICE_N_NOTIFY_CQ = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_N_NOTIFY_CQ = 16384
     * }
     */
    public static int IBV_DEVICE_N_NOTIFY_CQ() {
        return IBV_DEVICE_N_NOTIFY_CQ;
    }
    private static final int IBV_DEVICE_MEM_WINDOW = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_MEM_WINDOW = 131072
     * }
     */
    public static int IBV_DEVICE_MEM_WINDOW() {
        return IBV_DEVICE_MEM_WINDOW;
    }
    private static final int IBV_DEVICE_UD_IP_CSUM = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_UD_IP_CSUM = 262144
     * }
     */
    public static int IBV_DEVICE_UD_IP_CSUM() {
        return IBV_DEVICE_UD_IP_CSUM;
    }
    private static final int IBV_DEVICE_XRC = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_XRC = 1048576
     * }
     */
    public static int IBV_DEVICE_XRC() {
        return IBV_DEVICE_XRC;
    }
    private static final int IBV_DEVICE_MEM_MGT_EXTENSIONS = (int)2097152L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_MEM_MGT_EXTENSIONS = 2097152
     * }
     */
    public static int IBV_DEVICE_MEM_MGT_EXTENSIONS() {
        return IBV_DEVICE_MEM_MGT_EXTENSIONS;
    }
    private static final int IBV_DEVICE_MEM_WINDOW_TYPE_2A = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_MEM_WINDOW_TYPE_2A = 8388608
     * }
     */
    public static int IBV_DEVICE_MEM_WINDOW_TYPE_2A() {
        return IBV_DEVICE_MEM_WINDOW_TYPE_2A;
    }
    private static final int IBV_DEVICE_MEM_WINDOW_TYPE_2B = (int)16777216L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_MEM_WINDOW_TYPE_2B = 16777216
     * }
     */
    public static int IBV_DEVICE_MEM_WINDOW_TYPE_2B() {
        return IBV_DEVICE_MEM_WINDOW_TYPE_2B;
    }
    private static final int IBV_DEVICE_RC_IP_CSUM = (int)33554432L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_RC_IP_CSUM = 33554432
     * }
     */
    public static int IBV_DEVICE_RC_IP_CSUM() {
        return IBV_DEVICE_RC_IP_CSUM;
    }
    private static final int IBV_DEVICE_RAW_IP_CSUM = (int)67108864L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_RAW_IP_CSUM = 67108864
     * }
     */
    public static int IBV_DEVICE_RAW_IP_CSUM() {
        return IBV_DEVICE_RAW_IP_CSUM;
    }
    private static final int IBV_DEVICE_MANAGED_FLOW_STEERING = (int)536870912L;
    /**
     * {@snippet lang=c :
     * enum ibv_device_cap_flags.IBV_DEVICE_MANAGED_FLOW_STEERING = 536870912
     * }
     */
    public static int IBV_DEVICE_MANAGED_FLOW_STEERING() {
        return IBV_DEVICE_MANAGED_FLOW_STEERING;
    }
    private static final int IBV_FORK_DISABLED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ibv_fork_status.IBV_FORK_DISABLED = 0
     * }
     */
    public static int IBV_FORK_DISABLED() {
        return IBV_FORK_DISABLED;
    }
    private static final int IBV_FORK_ENABLED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_fork_status.IBV_FORK_ENABLED = 1
     * }
     */
    public static int IBV_FORK_ENABLED() {
        return IBV_FORK_ENABLED;
    }
    private static final int IBV_FORK_UNNEEDED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_fork_status.IBV_FORK_UNNEEDED = 2
     * }
     */
    public static int IBV_FORK_UNNEEDED() {
        return IBV_FORK_UNNEEDED;
    }
    private static final int IBV_ATOMIC_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ibv_atomic_cap.IBV_ATOMIC_NONE = 0
     * }
     */
    public static int IBV_ATOMIC_NONE() {
        return IBV_ATOMIC_NONE;
    }
    private static final int IBV_ATOMIC_HCA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_atomic_cap.IBV_ATOMIC_HCA = 1
     * }
     */
    public static int IBV_ATOMIC_HCA() {
        return IBV_ATOMIC_HCA;
    }
    private static final int IBV_ATOMIC_GLOB = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_atomic_cap.IBV_ATOMIC_GLOB = 2
     * }
     */
    public static int IBV_ATOMIC_GLOB() {
        return IBV_ATOMIC_GLOB;
    }
    private static final int IBV_DM_MASK_HANDLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_dm_mask.IBV_DM_MASK_HANDLE = 1
     * }
     */
    public static int IBV_DM_MASK_HANDLE() {
        return IBV_DM_MASK_HANDLE;
    }
    private static final int IBV_ODP_SUPPORT_SEND = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_odp_transport_cap_bits.IBV_ODP_SUPPORT_SEND = 1
     * }
     */
    public static int IBV_ODP_SUPPORT_SEND() {
        return IBV_ODP_SUPPORT_SEND;
    }
    private static final int IBV_ODP_SUPPORT_RECV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_odp_transport_cap_bits.IBV_ODP_SUPPORT_RECV = 2
     * }
     */
    public static int IBV_ODP_SUPPORT_RECV() {
        return IBV_ODP_SUPPORT_RECV;
    }
    private static final int IBV_ODP_SUPPORT_WRITE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ibv_odp_transport_cap_bits.IBV_ODP_SUPPORT_WRITE = 4
     * }
     */
    public static int IBV_ODP_SUPPORT_WRITE() {
        return IBV_ODP_SUPPORT_WRITE;
    }
    private static final int IBV_ODP_SUPPORT_READ = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ibv_odp_transport_cap_bits.IBV_ODP_SUPPORT_READ = 8
     * }
     */
    public static int IBV_ODP_SUPPORT_READ() {
        return IBV_ODP_SUPPORT_READ;
    }
    private static final int IBV_ODP_SUPPORT_ATOMIC = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ibv_odp_transport_cap_bits.IBV_ODP_SUPPORT_ATOMIC = 16
     * }
     */
    public static int IBV_ODP_SUPPORT_ATOMIC() {
        return IBV_ODP_SUPPORT_ATOMIC;
    }
    private static final int IBV_ODP_SUPPORT_SRQ_RECV = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ibv_odp_transport_cap_bits.IBV_ODP_SUPPORT_SRQ_RECV = 32
     * }
     */
    public static int IBV_ODP_SUPPORT_SRQ_RECV() {
        return IBV_ODP_SUPPORT_SRQ_RECV;
    }
    private static final int IBV_ODP_SUPPORT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_odp_general_caps.IBV_ODP_SUPPORT = 1
     * }
     */
    public static int IBV_ODP_SUPPORT() {
        return IBV_ODP_SUPPORT;
    }
    private static final int IBV_ODP_SUPPORT_IMPLICIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_odp_general_caps.IBV_ODP_SUPPORT_IMPLICIT = 2
     * }
     */
    public static int IBV_ODP_SUPPORT_IMPLICIT() {
        return IBV_ODP_SUPPORT_IMPLICIT;
    }
    private static final int IBV_RX_HASH_FUNC_TOEPLITZ = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_rx_hash_function_flags.IBV_RX_HASH_FUNC_TOEPLITZ = 1
     * }
     */
    public static int IBV_RX_HASH_FUNC_TOEPLITZ() {
        return IBV_RX_HASH_FUNC_TOEPLITZ;
    }
    private static final int IBV_RX_HASH_SRC_IPV4 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_rx_hash_fields.IBV_RX_HASH_SRC_IPV4 = 1
     * }
     */
    public static int IBV_RX_HASH_SRC_IPV4() {
        return IBV_RX_HASH_SRC_IPV4;
    }
    private static final int IBV_RX_HASH_DST_IPV4 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_rx_hash_fields.IBV_RX_HASH_DST_IPV4 = 2
     * }
     */
    public static int IBV_RX_HASH_DST_IPV4() {
        return IBV_RX_HASH_DST_IPV4;
    }
    private static final int IBV_RX_HASH_SRC_IPV6 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ibv_rx_hash_fields.IBV_RX_HASH_SRC_IPV6 = 4
     * }
     */
    public static int IBV_RX_HASH_SRC_IPV6() {
        return IBV_RX_HASH_SRC_IPV6;
    }
    private static final int IBV_RX_HASH_DST_IPV6 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ibv_rx_hash_fields.IBV_RX_HASH_DST_IPV6 = 8
     * }
     */
    public static int IBV_RX_HASH_DST_IPV6() {
        return IBV_RX_HASH_DST_IPV6;
    }
    private static final int IBV_RX_HASH_SRC_PORT_TCP = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ibv_rx_hash_fields.IBV_RX_HASH_SRC_PORT_TCP = 16
     * }
     */
    public static int IBV_RX_HASH_SRC_PORT_TCP() {
        return IBV_RX_HASH_SRC_PORT_TCP;
    }
    private static final int IBV_RX_HASH_DST_PORT_TCP = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ibv_rx_hash_fields.IBV_RX_HASH_DST_PORT_TCP = 32
     * }
     */
    public static int IBV_RX_HASH_DST_PORT_TCP() {
        return IBV_RX_HASH_DST_PORT_TCP;
    }
    private static final int IBV_RX_HASH_SRC_PORT_UDP = (int)64L;
    /**
     * {@snippet lang=c :
     * enum ibv_rx_hash_fields.IBV_RX_HASH_SRC_PORT_UDP = 64
     * }
     */
    public static int IBV_RX_HASH_SRC_PORT_UDP() {
        return IBV_RX_HASH_SRC_PORT_UDP;
    }
    private static final int IBV_RX_HASH_DST_PORT_UDP = (int)128L;
    /**
     * {@snippet lang=c :
     * enum ibv_rx_hash_fields.IBV_RX_HASH_DST_PORT_UDP = 128
     * }
     */
    public static int IBV_RX_HASH_DST_PORT_UDP() {
        return IBV_RX_HASH_DST_PORT_UDP;
    }
    private static final int IBV_RX_HASH_IPSEC_SPI = (int)256L;
    /**
     * {@snippet lang=c :
     * enum ibv_rx_hash_fields.IBV_RX_HASH_IPSEC_SPI = 256
     * }
     */
    public static int IBV_RX_HASH_IPSEC_SPI() {
        return IBV_RX_HASH_IPSEC_SPI;
    }
    private static final int IBV_RX_HASH_INNER = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * enum ibv_rx_hash_fields.IBV_RX_HASH_INNER = -2147483648
     * }
     */
    public static int IBV_RX_HASH_INNER() {
        return IBV_RX_HASH_INNER;
    }
    private static final int IBV_RAW_PACKET_CAP_CVLAN_STRIPPING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_raw_packet_caps.IBV_RAW_PACKET_CAP_CVLAN_STRIPPING = 1
     * }
     */
    public static int IBV_RAW_PACKET_CAP_CVLAN_STRIPPING() {
        return IBV_RAW_PACKET_CAP_CVLAN_STRIPPING;
    }
    private static final int IBV_RAW_PACKET_CAP_SCATTER_FCS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_raw_packet_caps.IBV_RAW_PACKET_CAP_SCATTER_FCS = 2
     * }
     */
    public static int IBV_RAW_PACKET_CAP_SCATTER_FCS() {
        return IBV_RAW_PACKET_CAP_SCATTER_FCS;
    }
    private static final int IBV_RAW_PACKET_CAP_IP_CSUM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ibv_raw_packet_caps.IBV_RAW_PACKET_CAP_IP_CSUM = 4
     * }
     */
    public static int IBV_RAW_PACKET_CAP_IP_CSUM() {
        return IBV_RAW_PACKET_CAP_IP_CSUM;
    }
    private static final int IBV_RAW_PACKET_CAP_DELAY_DROP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ibv_raw_packet_caps.IBV_RAW_PACKET_CAP_DELAY_DROP = 8
     * }
     */
    public static int IBV_RAW_PACKET_CAP_DELAY_DROP() {
        return IBV_RAW_PACKET_CAP_DELAY_DROP;
    }
    private static final int IBV_TM_CAP_RC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_tm_cap_flags.IBV_TM_CAP_RC = 1
     * }
     */
    public static int IBV_TM_CAP_RC() {
        return IBV_TM_CAP_RC;
    }
    private static final int IBV_PCI_ATOMIC_OPERATION_4_BYTE_SIZE_SUP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_pci_atomic_op_size.IBV_PCI_ATOMIC_OPERATION_4_BYTE_SIZE_SUP = 1
     * }
     */
    public static int IBV_PCI_ATOMIC_OPERATION_4_BYTE_SIZE_SUP() {
        return IBV_PCI_ATOMIC_OPERATION_4_BYTE_SIZE_SUP;
    }
    private static final int IBV_PCI_ATOMIC_OPERATION_8_BYTE_SIZE_SUP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_pci_atomic_op_size.IBV_PCI_ATOMIC_OPERATION_8_BYTE_SIZE_SUP = 2
     * }
     */
    public static int IBV_PCI_ATOMIC_OPERATION_8_BYTE_SIZE_SUP() {
        return IBV_PCI_ATOMIC_OPERATION_8_BYTE_SIZE_SUP;
    }
    private static final int IBV_PCI_ATOMIC_OPERATION_16_BYTE_SIZE_SUP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ibv_pci_atomic_op_size.IBV_PCI_ATOMIC_OPERATION_16_BYTE_SIZE_SUP = 4
     * }
     */
    public static int IBV_PCI_ATOMIC_OPERATION_16_BYTE_SIZE_SUP() {
        return IBV_PCI_ATOMIC_OPERATION_16_BYTE_SIZE_SUP;
    }
    private static final int IBV_MTU_256 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_mtu.IBV_MTU_256 = 1
     * }
     */
    public static int IBV_MTU_256() {
        return IBV_MTU_256;
    }
    private static final int IBV_MTU_512 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_mtu.IBV_MTU_512 = 2
     * }
     */
    public static int IBV_MTU_512() {
        return IBV_MTU_512;
    }
    private static final int IBV_MTU_1024 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ibv_mtu.IBV_MTU_1024 = 3
     * }
     */
    public static int IBV_MTU_1024() {
        return IBV_MTU_1024;
    }
    private static final int IBV_MTU_2048 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ibv_mtu.IBV_MTU_2048 = 4
     * }
     */
    public static int IBV_MTU_2048() {
        return IBV_MTU_2048;
    }
    private static final int IBV_MTU_4096 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ibv_mtu.IBV_MTU_4096 = 5
     * }
     */
    public static int IBV_MTU_4096() {
        return IBV_MTU_4096;
    }
    private static final int IBV_PORT_NOP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_state.IBV_PORT_NOP = 0
     * }
     */
    public static int IBV_PORT_NOP() {
        return IBV_PORT_NOP;
    }
    private static final int IBV_PORT_DOWN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_state.IBV_PORT_DOWN = 1
     * }
     */
    public static int IBV_PORT_DOWN() {
        return IBV_PORT_DOWN;
    }
    private static final int IBV_PORT_INIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_state.IBV_PORT_INIT = 2
     * }
     */
    public static int IBV_PORT_INIT() {
        return IBV_PORT_INIT;
    }
    private static final int IBV_PORT_ARMED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_state.IBV_PORT_ARMED = 3
     * }
     */
    public static int IBV_PORT_ARMED() {
        return IBV_PORT_ARMED;
    }
    private static final int IBV_PORT_ACTIVE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_state.IBV_PORT_ACTIVE = 4
     * }
     */
    public static int IBV_PORT_ACTIVE() {
        return IBV_PORT_ACTIVE;
    }
    private static final int IBV_PORT_ACTIVE_DEFER = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_state.IBV_PORT_ACTIVE_DEFER = 5
     * }
     */
    public static int IBV_PORT_ACTIVE_DEFER() {
        return IBV_PORT_ACTIVE_DEFER;
    }
    private static final int IBV_LINK_LAYER_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IBV_LINK_LAYER_UNSPECIFIED = 0
     * }
     */
    public static int IBV_LINK_LAYER_UNSPECIFIED() {
        return IBV_LINK_LAYER_UNSPECIFIED;
    }
    private static final int IBV_LINK_LAYER_INFINIBAND = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IBV_LINK_LAYER_INFINIBAND = 1
     * }
     */
    public static int IBV_LINK_LAYER_INFINIBAND() {
        return IBV_LINK_LAYER_INFINIBAND;
    }
    private static final int IBV_LINK_LAYER_ETHERNET = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IBV_LINK_LAYER_ETHERNET = 2
     * }
     */
    public static int IBV_LINK_LAYER_ETHERNET() {
        return IBV_LINK_LAYER_ETHERNET;
    }
    private static final int IBV_PORT_SM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_SM = 2
     * }
     */
    public static int IBV_PORT_SM() {
        return IBV_PORT_SM;
    }
    private static final int IBV_PORT_NOTICE_SUP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_NOTICE_SUP = 4
     * }
     */
    public static int IBV_PORT_NOTICE_SUP() {
        return IBV_PORT_NOTICE_SUP;
    }
    private static final int IBV_PORT_TRAP_SUP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_TRAP_SUP = 8
     * }
     */
    public static int IBV_PORT_TRAP_SUP() {
        return IBV_PORT_TRAP_SUP;
    }
    private static final int IBV_PORT_OPT_IPD_SUP = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_OPT_IPD_SUP = 16
     * }
     */
    public static int IBV_PORT_OPT_IPD_SUP() {
        return IBV_PORT_OPT_IPD_SUP;
    }
    private static final int IBV_PORT_AUTO_MIGR_SUP = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_AUTO_MIGR_SUP = 32
     * }
     */
    public static int IBV_PORT_AUTO_MIGR_SUP() {
        return IBV_PORT_AUTO_MIGR_SUP;
    }
    private static final int IBV_PORT_SL_MAP_SUP = (int)64L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_SL_MAP_SUP = 64
     * }
     */
    public static int IBV_PORT_SL_MAP_SUP() {
        return IBV_PORT_SL_MAP_SUP;
    }
    private static final int IBV_PORT_MKEY_NVRAM = (int)128L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_MKEY_NVRAM = 128
     * }
     */
    public static int IBV_PORT_MKEY_NVRAM() {
        return IBV_PORT_MKEY_NVRAM;
    }
    private static final int IBV_PORT_PKEY_NVRAM = (int)256L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_PKEY_NVRAM = 256
     * }
     */
    public static int IBV_PORT_PKEY_NVRAM() {
        return IBV_PORT_PKEY_NVRAM;
    }
    private static final int IBV_PORT_LED_INFO_SUP = (int)512L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_LED_INFO_SUP = 512
     * }
     */
    public static int IBV_PORT_LED_INFO_SUP() {
        return IBV_PORT_LED_INFO_SUP;
    }
    private static final int IBV_PORT_SYS_IMAGE_GUID_SUP = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_SYS_IMAGE_GUID_SUP = 2048
     * }
     */
    public static int IBV_PORT_SYS_IMAGE_GUID_SUP() {
        return IBV_PORT_SYS_IMAGE_GUID_SUP;
    }
    private static final int IBV_PORT_PKEY_SW_EXT_PORT_TRAP_SUP = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_PKEY_SW_EXT_PORT_TRAP_SUP = 4096
     * }
     */
    public static int IBV_PORT_PKEY_SW_EXT_PORT_TRAP_SUP() {
        return IBV_PORT_PKEY_SW_EXT_PORT_TRAP_SUP;
    }
    private static final int IBV_PORT_EXTENDED_SPEEDS_SUP = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_EXTENDED_SPEEDS_SUP = 16384
     * }
     */
    public static int IBV_PORT_EXTENDED_SPEEDS_SUP() {
        return IBV_PORT_EXTENDED_SPEEDS_SUP;
    }
    private static final int IBV_PORT_CAP_MASK2_SUP = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_CAP_MASK2_SUP = 32768
     * }
     */
    public static int IBV_PORT_CAP_MASK2_SUP() {
        return IBV_PORT_CAP_MASK2_SUP;
    }
    private static final int IBV_PORT_CM_SUP = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_CM_SUP = 65536
     * }
     */
    public static int IBV_PORT_CM_SUP() {
        return IBV_PORT_CM_SUP;
    }
    private static final int IBV_PORT_SNMP_TUNNEL_SUP = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_SNMP_TUNNEL_SUP = 131072
     * }
     */
    public static int IBV_PORT_SNMP_TUNNEL_SUP() {
        return IBV_PORT_SNMP_TUNNEL_SUP;
    }
    private static final int IBV_PORT_REINIT_SUP = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_REINIT_SUP = 262144
     * }
     */
    public static int IBV_PORT_REINIT_SUP() {
        return IBV_PORT_REINIT_SUP;
    }
    private static final int IBV_PORT_DEVICE_MGMT_SUP = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_DEVICE_MGMT_SUP = 524288
     * }
     */
    public static int IBV_PORT_DEVICE_MGMT_SUP() {
        return IBV_PORT_DEVICE_MGMT_SUP;
    }
    private static final int IBV_PORT_VENDOR_CLASS_SUP = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_VENDOR_CLASS_SUP = 1048576
     * }
     */
    public static int IBV_PORT_VENDOR_CLASS_SUP() {
        return IBV_PORT_VENDOR_CLASS_SUP;
    }
    private static final int IBV_PORT_DR_NOTICE_SUP = (int)2097152L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_DR_NOTICE_SUP = 2097152
     * }
     */
    public static int IBV_PORT_DR_NOTICE_SUP() {
        return IBV_PORT_DR_NOTICE_SUP;
    }
    private static final int IBV_PORT_CAP_MASK_NOTICE_SUP = (int)4194304L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_CAP_MASK_NOTICE_SUP = 4194304
     * }
     */
    public static int IBV_PORT_CAP_MASK_NOTICE_SUP() {
        return IBV_PORT_CAP_MASK_NOTICE_SUP;
    }
    private static final int IBV_PORT_BOOT_MGMT_SUP = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_BOOT_MGMT_SUP = 8388608
     * }
     */
    public static int IBV_PORT_BOOT_MGMT_SUP() {
        return IBV_PORT_BOOT_MGMT_SUP;
    }
    private static final int IBV_PORT_LINK_LATENCY_SUP = (int)16777216L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_LINK_LATENCY_SUP = 16777216
     * }
     */
    public static int IBV_PORT_LINK_LATENCY_SUP() {
        return IBV_PORT_LINK_LATENCY_SUP;
    }
    private static final int IBV_PORT_CLIENT_REG_SUP = (int)33554432L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_CLIENT_REG_SUP = 33554432
     * }
     */
    public static int IBV_PORT_CLIENT_REG_SUP() {
        return IBV_PORT_CLIENT_REG_SUP;
    }
    private static final int IBV_PORT_IP_BASED_GIDS = (int)67108864L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags.IBV_PORT_IP_BASED_GIDS = 67108864
     * }
     */
    public static int IBV_PORT_IP_BASED_GIDS() {
        return IBV_PORT_IP_BASED_GIDS;
    }
    private static final int IBV_PORT_SET_NODE_DESC_SUP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags2.IBV_PORT_SET_NODE_DESC_SUP = 1
     * }
     */
    public static int IBV_PORT_SET_NODE_DESC_SUP() {
        return IBV_PORT_SET_NODE_DESC_SUP;
    }
    private static final int IBV_PORT_INFO_EXT_SUP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags2.IBV_PORT_INFO_EXT_SUP = 2
     * }
     */
    public static int IBV_PORT_INFO_EXT_SUP() {
        return IBV_PORT_INFO_EXT_SUP;
    }
    private static final int IBV_PORT_VIRT_SUP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags2.IBV_PORT_VIRT_SUP = 4
     * }
     */
    public static int IBV_PORT_VIRT_SUP() {
        return IBV_PORT_VIRT_SUP;
    }
    private static final int IBV_PORT_SWITCH_PORT_STATE_TABLE_SUP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags2.IBV_PORT_SWITCH_PORT_STATE_TABLE_SUP = 8
     * }
     */
    public static int IBV_PORT_SWITCH_PORT_STATE_TABLE_SUP() {
        return IBV_PORT_SWITCH_PORT_STATE_TABLE_SUP;
    }
    private static final int IBV_PORT_LINK_WIDTH_2X_SUP = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags2.IBV_PORT_LINK_WIDTH_2X_SUP = 16
     * }
     */
    public static int IBV_PORT_LINK_WIDTH_2X_SUP() {
        return IBV_PORT_LINK_WIDTH_2X_SUP;
    }
    private static final int IBV_PORT_LINK_SPEED_HDR_SUP = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags2.IBV_PORT_LINK_SPEED_HDR_SUP = 32
     * }
     */
    public static int IBV_PORT_LINK_SPEED_HDR_SUP() {
        return IBV_PORT_LINK_SPEED_HDR_SUP;
    }
    private static final int IBV_PORT_LINK_SPEED_NDR_SUP = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum ibv_port_cap_flags2.IBV_PORT_LINK_SPEED_NDR_SUP = 1024
     * }
     */
    public static int IBV_PORT_LINK_SPEED_NDR_SUP() {
        return IBV_PORT_LINK_SPEED_NDR_SUP;
    }
    private static final int IBV_EVENT_CQ_ERR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ibv_event_type.IBV_EVENT_CQ_ERR = 0
     * }
     */
    public static int IBV_EVENT_CQ_ERR() {
        return IBV_EVENT_CQ_ERR;
    }
    private static final int IBV_EVENT_QP_FATAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ibv_event_type.IBV_EVENT_QP_FATAL = 1
     * }
     */
    public static int IBV_EVENT_QP_FATAL() {
        return IBV_EVENT_QP_FATAL;
    }
    private static final int IBV_EVENT_QP_REQ_ERR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ibv_event_type.IBV_EVENT_QP_REQ_ERR = 2
     * }
     */
    public static int IBV_EVENT_QP_REQ_ERR() {
        return IBV_EVENT_QP_REQ_ERR;
    }
    private static final int IBV_EVENT_QP_ACCESS_ERR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ibv_event_type.IBV_EVENT_QP_ACCESS_ERR = 3
     * }
     */
    public static int IBV_EVENT_QP_ACCESS_ERR() {
        return IBV_EVENT_QP_ACCESS_ERR;
    }
    private static final int IBV_EVENT_COMM_EST = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ibv_event_type.IBV_EVENT_COMM_EST = 4
     * }
     */
    public static int IBV_EVENT_COMM_EST() {
        return IBV_EVENT_COMM_EST;
    }
    private static final int IBV_EVENT_SQ_DRAINED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ibv_event_type.IBV_EVENT_SQ_DRAINED = 5
     * }
     */
    public static int IBV_EVENT_SQ_DRAINED() {
        return IBV_EVENT_SQ_DRAINED;
    }
    private static final int IBV_EVENT_PATH_MIG = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ibv_event_type.IBV_EVENT_PATH_MIG = 6
     * }
     */
    public static int IBV_EVENT_PATH_MIG() {
        return IBV_EVENT_PATH_MIG;
    }
    private static final int IBV_EVENT_PATH_MIG_ERR = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ibv_event_type.IBV_EVENT_PATH_MIG_ERR = 7
     * }
     */
    public static int IBV_EVENT_PATH_MIG_ERR() {
        return IBV_EVENT_PATH_MIG_ERR;
    }
    private static final int IBV_EVENT_DEVICE_FATAL = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ibv_event_type.IBV_EVENT_DEVICE_FATAL = 8
     * }
     */
    public static int IBV_EVENT_DEVICE_FATAL() {
        return IBV_EVENT_DEVICE_FATAL;
    }
    private static final int IBV_EVENT_PORT_ACTIVE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ibv_event_type.IBV_EVENT_PORT_ACTIVE = 9
     * }
     */
    public static int IBV_EVENT_PORT_ACTIVE() {
        return IBV_EVENT_PORT_ACTIVE;
    }
    private static final int IBV_EVENT_PORT_ERR = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ibv_event_type.IBV_EVENT_PORT_ERR = 10
     * }
     */
    public static int IBV_EVENT_PORT_ERR() {
        return IBV_EVENT_PORT_ERR;
    }
    private static final int IBV_EVENT_LID_CHANGE = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ibv_event_type.IBV_EVENT_LID_CHANGE = 11
     * }
     */
    public static int IBV_EVENT_LID_CHANGE() {
        return IBV_EVENT_LID_CHANGE;
    }
    private static final int IBV_EVENT_PKEY_CHANGE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ibv_event_type.IBV_EVENT_PKEY_CHANGE = 12
     * }
     */
    public static int IBV_EVENT_PKEY_CHANGE() {
        return IBV_EVENT_PKEY_CHANGE;
    }
    private static final int IBV_EVENT_SM_CHANGE = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ibv_event_type.IBV_EVENT_SM_CHANGE = 13
     * }
     */
    public static int IBV_EVENT_SM_CHANGE() {
        return IBV_EVENT_SM_CHANGE;
    }
    private static final int IBV_EVENT_SRQ_ERR = (int)14L;
    /**
     * {@snippet lang=c :
     * enum ibv_event_type.IBV_EVENT_SRQ_ERR = 14
     * }
     */
    public static int IBV_EVENT_SRQ_ERR() {
        return IBV_EVENT_SRQ_ERR;
    }
}

