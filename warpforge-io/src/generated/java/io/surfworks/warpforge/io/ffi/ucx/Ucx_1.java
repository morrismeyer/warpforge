// Generated by jextract

package io.surfworks.warpforge.io.ffi.ucx;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Ucx_1 {

    Ucx_1() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("ucp"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int UCS_ALLOCA_MAX_SIZE = (int)1200L;
    /**
     * {@snippet lang=c :
     * #define UCS_ALLOCA_MAX_SIZE 1200
     * }
     */
    public static int UCS_ALLOCA_MAX_SIZE() {
        return UCS_ALLOCA_MAX_SIZE;
    }
    private static final int _SYS_SOCKET_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SOCKET_H 1
     * }
     */
    public static int _SYS_SOCKET_H() {
        return _SYS_SOCKET_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)35L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 35
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int __iovec_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __iovec_defined 1
     * }
     */
    public static int __iovec_defined() {
        return __iovec_defined;
    }
    private static final int _SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_TYPES_H 1
     * }
     */
    public static int _SYS_TYPES_H() {
        return _SYS_TYPES_H;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int __clock_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clock_t_defined 1
     * }
     */
    public static int __clock_t_defined() {
        return __clock_t_defined;
    }
    private static final int __clockid_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clockid_t_defined 1
     * }
     */
    public static int __clockid_t_defined() {
        return __clockid_t_defined;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int __BIT_TYPES_DEFINED__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __BIT_TYPES_DEFINED__ 1
     * }
     */
    public static int __BIT_TYPES_DEFINED__() {
        return __BIT_TYPES_DEFINED__;
    }
    private static final int _ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ENDIAN_H 1
     * }
     */
    public static int _ENDIAN_H() {
        return _ENDIAN_H;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_BYTESWAP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_BYTESWAP_H 1
     * }
     */
    public static int _BITS_BYTESWAP_H() {
        return _BITS_BYTESWAP_H;
    }
    private static final int _BITS_UINTN_IDENTITY_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_UINTN_IDENTITY_H 1
     * }
     */
    public static int _BITS_UINTN_IDENTITY_H() {
        return _BITS_UINTN_IDENTITY_H;
    }
    private static final int _SYS_SELECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SELECT_H 1
     * }
     */
    public static int _SYS_SELECT_H() {
        return _SYS_SELECT_H;
    }
    private static final int __sigset_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __sigset_t_defined 1
     * }
     */
    public static int __sigset_t_defined() {
        return __sigset_t_defined;
    }
    private static final int __timeval_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timeval_defined 1
     * }
     */
    public static int __timeval_defined() {
        return __timeval_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_PTHREADTYPES_COMMON_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_COMMON_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return _BITS_PTHREADTYPES_COMMON_H;
    }
    private static final int _THREAD_SHARED_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_SHARED_TYPES_H 1
     * }
     */
    public static int _THREAD_SHARED_TYPES_H() {
        return _THREAD_SHARED_TYPES_H;
    }
    private static final int _BITS_PTHREADTYPES_ARCH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_ARCH_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return _BITS_PTHREADTYPES_ARCH_H;
    }
    private static final int __SIZEOF_PTHREAD_MUTEX_T = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEX_T 40
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return __SIZEOF_PTHREAD_MUTEX_T;
    }
    private static final int __SIZEOF_PTHREAD_ATTR_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_ATTR_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return __SIZEOF_PTHREAD_ATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCK_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCK_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return __SIZEOF_PTHREAD_RWLOCK_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIER_T = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIER_T 32
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return __SIZEOF_PTHREAD_BARRIER_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEXATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEXATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return __SIZEOF_PTHREAD_MUTEXATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_COND_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_COND_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_COND_T() {
        return __SIZEOF_PTHREAD_COND_T;
    }
    private static final int __SIZEOF_PTHREAD_CONDATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_CONDATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return __SIZEOF_PTHREAD_CONDATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCKATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return __SIZEOF_PTHREAD_RWLOCKATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIERATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIERATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return __SIZEOF_PTHREAD_BARRIERATTR_T;
    }
    private static final int _THREAD_MUTEX_INTERNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_MUTEX_INTERNAL_H 1
     * }
     */
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return _THREAD_MUTEX_INTERNAL_H;
    }
    private static final int __PTHREAD_MUTEX_HAVE_PREV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_HAVE_PREV 1
     * }
     */
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return __PTHREAD_MUTEX_HAVE_PREV;
    }
    private static final int __have_pthread_attr_t = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __have_pthread_attr_t 1
     * }
     */
    public static int __have_pthread_attr_t() {
        return __have_pthread_attr_t;
    }
    private static final int PF_UNSPEC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PF_UNSPEC 0
     * }
     */
    public static int PF_UNSPEC() {
        return PF_UNSPEC;
    }
    private static final int PF_LOCAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PF_LOCAL 1
     * }
     */
    public static int PF_LOCAL() {
        return PF_LOCAL;
    }
    private static final int PF_INET = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PF_INET 2
     * }
     */
    public static int PF_INET() {
        return PF_INET;
    }
    private static final int PF_AX25 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PF_AX25 3
     * }
     */
    public static int PF_AX25() {
        return PF_AX25;
    }
    private static final int PF_IPX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PF_IPX 4
     * }
     */
    public static int PF_IPX() {
        return PF_IPX;
    }
    private static final int PF_APPLETALK = (int)5L;
    /**
     * {@snippet lang=c :
     * #define PF_APPLETALK 5
     * }
     */
    public static int PF_APPLETALK() {
        return PF_APPLETALK;
    }
    private static final int PF_NETROM = (int)6L;
    /**
     * {@snippet lang=c :
     * #define PF_NETROM 6
     * }
     */
    public static int PF_NETROM() {
        return PF_NETROM;
    }
    private static final int PF_BRIDGE = (int)7L;
    /**
     * {@snippet lang=c :
     * #define PF_BRIDGE 7
     * }
     */
    public static int PF_BRIDGE() {
        return PF_BRIDGE;
    }
    private static final int PF_ATMPVC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PF_ATMPVC 8
     * }
     */
    public static int PF_ATMPVC() {
        return PF_ATMPVC;
    }
    private static final int PF_X25 = (int)9L;
    /**
     * {@snippet lang=c :
     * #define PF_X25 9
     * }
     */
    public static int PF_X25() {
        return PF_X25;
    }
    private static final int PF_INET6 = (int)10L;
    /**
     * {@snippet lang=c :
     * #define PF_INET6 10
     * }
     */
    public static int PF_INET6() {
        return PF_INET6;
    }
    private static final int PF_ROSE = (int)11L;
    /**
     * {@snippet lang=c :
     * #define PF_ROSE 11
     * }
     */
    public static int PF_ROSE() {
        return PF_ROSE;
    }
    private static final int PF_DECnet = (int)12L;
    /**
     * {@snippet lang=c :
     * #define PF_DECnet 12
     * }
     */
    public static int PF_DECnet() {
        return PF_DECnet;
    }
    private static final int PF_NETBEUI = (int)13L;
    /**
     * {@snippet lang=c :
     * #define PF_NETBEUI 13
     * }
     */
    public static int PF_NETBEUI() {
        return PF_NETBEUI;
    }
    private static final int PF_SECURITY = (int)14L;
    /**
     * {@snippet lang=c :
     * #define PF_SECURITY 14
     * }
     */
    public static int PF_SECURITY() {
        return PF_SECURITY;
    }
    private static final int PF_KEY = (int)15L;
    /**
     * {@snippet lang=c :
     * #define PF_KEY 15
     * }
     */
    public static int PF_KEY() {
        return PF_KEY;
    }
    private static final int PF_NETLINK = (int)16L;
    /**
     * {@snippet lang=c :
     * #define PF_NETLINK 16
     * }
     */
    public static int PF_NETLINK() {
        return PF_NETLINK;
    }
    private static final int PF_PACKET = (int)17L;
    /**
     * {@snippet lang=c :
     * #define PF_PACKET 17
     * }
     */
    public static int PF_PACKET() {
        return PF_PACKET;
    }
    private static final int PF_ASH = (int)18L;
    /**
     * {@snippet lang=c :
     * #define PF_ASH 18
     * }
     */
    public static int PF_ASH() {
        return PF_ASH;
    }
    private static final int PF_ECONET = (int)19L;
    /**
     * {@snippet lang=c :
     * #define PF_ECONET 19
     * }
     */
    public static int PF_ECONET() {
        return PF_ECONET;
    }
    private static final int PF_ATMSVC = (int)20L;
    /**
     * {@snippet lang=c :
     * #define PF_ATMSVC 20
     * }
     */
    public static int PF_ATMSVC() {
        return PF_ATMSVC;
    }
    private static final int PF_RDS = (int)21L;
    /**
     * {@snippet lang=c :
     * #define PF_RDS 21
     * }
     */
    public static int PF_RDS() {
        return PF_RDS;
    }
    private static final int PF_SNA = (int)22L;
    /**
     * {@snippet lang=c :
     * #define PF_SNA 22
     * }
     */
    public static int PF_SNA() {
        return PF_SNA;
    }
    private static final int PF_IRDA = (int)23L;
    /**
     * {@snippet lang=c :
     * #define PF_IRDA 23
     * }
     */
    public static int PF_IRDA() {
        return PF_IRDA;
    }
    private static final int PF_PPPOX = (int)24L;
    /**
     * {@snippet lang=c :
     * #define PF_PPPOX 24
     * }
     */
    public static int PF_PPPOX() {
        return PF_PPPOX;
    }
    private static final int PF_WANPIPE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define PF_WANPIPE 25
     * }
     */
    public static int PF_WANPIPE() {
        return PF_WANPIPE;
    }
    private static final int PF_LLC = (int)26L;
    /**
     * {@snippet lang=c :
     * #define PF_LLC 26
     * }
     */
    public static int PF_LLC() {
        return PF_LLC;
    }
    private static final int PF_IB = (int)27L;
    /**
     * {@snippet lang=c :
     * #define PF_IB 27
     * }
     */
    public static int PF_IB() {
        return PF_IB;
    }
    private static final int PF_MPLS = (int)28L;
    /**
     * {@snippet lang=c :
     * #define PF_MPLS 28
     * }
     */
    public static int PF_MPLS() {
        return PF_MPLS;
    }
    private static final int PF_CAN = (int)29L;
    /**
     * {@snippet lang=c :
     * #define PF_CAN 29
     * }
     */
    public static int PF_CAN() {
        return PF_CAN;
    }
    private static final int PF_TIPC = (int)30L;
    /**
     * {@snippet lang=c :
     * #define PF_TIPC 30
     * }
     */
    public static int PF_TIPC() {
        return PF_TIPC;
    }
    private static final int PF_BLUETOOTH = (int)31L;
    /**
     * {@snippet lang=c :
     * #define PF_BLUETOOTH 31
     * }
     */
    public static int PF_BLUETOOTH() {
        return PF_BLUETOOTH;
    }
    private static final int PF_IUCV = (int)32L;
    /**
     * {@snippet lang=c :
     * #define PF_IUCV 32
     * }
     */
    public static int PF_IUCV() {
        return PF_IUCV;
    }
    private static final int PF_RXRPC = (int)33L;
    /**
     * {@snippet lang=c :
     * #define PF_RXRPC 33
     * }
     */
    public static int PF_RXRPC() {
        return PF_RXRPC;
    }
    private static final int PF_ISDN = (int)34L;
    /**
     * {@snippet lang=c :
     * #define PF_ISDN 34
     * }
     */
    public static int PF_ISDN() {
        return PF_ISDN;
    }
    private static final int PF_PHONET = (int)35L;
    /**
     * {@snippet lang=c :
     * #define PF_PHONET 35
     * }
     */
    public static int PF_PHONET() {
        return PF_PHONET;
    }
    private static final int PF_IEEE802154 = (int)36L;
    /**
     * {@snippet lang=c :
     * #define PF_IEEE802154 36
     * }
     */
    public static int PF_IEEE802154() {
        return PF_IEEE802154;
    }
    private static final int PF_CAIF = (int)37L;
    /**
     * {@snippet lang=c :
     * #define PF_CAIF 37
     * }
     */
    public static int PF_CAIF() {
        return PF_CAIF;
    }
    private static final int PF_ALG = (int)38L;
    /**
     * {@snippet lang=c :
     * #define PF_ALG 38
     * }
     */
    public static int PF_ALG() {
        return PF_ALG;
    }
    private static final int PF_NFC = (int)39L;
    /**
     * {@snippet lang=c :
     * #define PF_NFC 39
     * }
     */
    public static int PF_NFC() {
        return PF_NFC;
    }
    private static final int PF_VSOCK = (int)40L;
    /**
     * {@snippet lang=c :
     * #define PF_VSOCK 40
     * }
     */
    public static int PF_VSOCK() {
        return PF_VSOCK;
    }
    private static final int PF_KCM = (int)41L;
    /**
     * {@snippet lang=c :
     * #define PF_KCM 41
     * }
     */
    public static int PF_KCM() {
        return PF_KCM;
    }
    private static final int PF_QIPCRTR = (int)42L;
    /**
     * {@snippet lang=c :
     * #define PF_QIPCRTR 42
     * }
     */
    public static int PF_QIPCRTR() {
        return PF_QIPCRTR;
    }
    private static final int PF_SMC = (int)43L;
    /**
     * {@snippet lang=c :
     * #define PF_SMC 43
     * }
     */
    public static int PF_SMC() {
        return PF_SMC;
    }
    private static final int PF_XDP = (int)44L;
    /**
     * {@snippet lang=c :
     * #define PF_XDP 44
     * }
     */
    public static int PF_XDP() {
        return PF_XDP;
    }
    private static final int PF_MCTP = (int)45L;
    /**
     * {@snippet lang=c :
     * #define PF_MCTP 45
     * }
     */
    public static int PF_MCTP() {
        return PF_MCTP;
    }
    private static final int PF_MAX = (int)46L;
    /**
     * {@snippet lang=c :
     * #define PF_MAX 46
     * }
     */
    public static int PF_MAX() {
        return PF_MAX;
    }
    private static final int SOL_RAW = (int)255L;
    /**
     * {@snippet lang=c :
     * #define SOL_RAW 255
     * }
     */
    public static int SOL_RAW() {
        return SOL_RAW;
    }
    private static final int SOL_DECNET = (int)261L;
    /**
     * {@snippet lang=c :
     * #define SOL_DECNET 261
     * }
     */
    public static int SOL_DECNET() {
        return SOL_DECNET;
    }
    private static final int SOL_X25 = (int)262L;
    /**
     * {@snippet lang=c :
     * #define SOL_X25 262
     * }
     */
    public static int SOL_X25() {
        return SOL_X25;
    }
    private static final int SOL_PACKET = (int)263L;
    /**
     * {@snippet lang=c :
     * #define SOL_PACKET 263
     * }
     */
    public static int SOL_PACKET() {
        return SOL_PACKET;
    }
    private static final int SOL_ATM = (int)264L;
    /**
     * {@snippet lang=c :
     * #define SOL_ATM 264
     * }
     */
    public static int SOL_ATM() {
        return SOL_ATM;
    }
    private static final int SOL_AAL = (int)265L;
    /**
     * {@snippet lang=c :
     * #define SOL_AAL 265
     * }
     */
    public static int SOL_AAL() {
        return SOL_AAL;
    }
    private static final int SOL_IRDA = (int)266L;
    /**
     * {@snippet lang=c :
     * #define SOL_IRDA 266
     * }
     */
    public static int SOL_IRDA() {
        return SOL_IRDA;
    }
    private static final int SOL_NETBEUI = (int)267L;
    /**
     * {@snippet lang=c :
     * #define SOL_NETBEUI 267
     * }
     */
    public static int SOL_NETBEUI() {
        return SOL_NETBEUI;
    }
    private static final int SOL_LLC = (int)268L;
    /**
     * {@snippet lang=c :
     * #define SOL_LLC 268
     * }
     */
    public static int SOL_LLC() {
        return SOL_LLC;
    }
    private static final int SOL_DCCP = (int)269L;
    /**
     * {@snippet lang=c :
     * #define SOL_DCCP 269
     * }
     */
    public static int SOL_DCCP() {
        return SOL_DCCP;
    }
    private static final int SOL_NETLINK = (int)270L;
    /**
     * {@snippet lang=c :
     * #define SOL_NETLINK 270
     * }
     */
    public static int SOL_NETLINK() {
        return SOL_NETLINK;
    }
    private static final int SOL_TIPC = (int)271L;
    /**
     * {@snippet lang=c :
     * #define SOL_TIPC 271
     * }
     */
    public static int SOL_TIPC() {
        return SOL_TIPC;
    }
    private static final int SOL_RXRPC = (int)272L;
    /**
     * {@snippet lang=c :
     * #define SOL_RXRPC 272
     * }
     */
    public static int SOL_RXRPC() {
        return SOL_RXRPC;
    }
    private static final int SOL_PPPOL2TP = (int)273L;
    /**
     * {@snippet lang=c :
     * #define SOL_PPPOL2TP 273
     * }
     */
    public static int SOL_PPPOL2TP() {
        return SOL_PPPOL2TP;
    }
    private static final int SOL_BLUETOOTH = (int)274L;
    /**
     * {@snippet lang=c :
     * #define SOL_BLUETOOTH 274
     * }
     */
    public static int SOL_BLUETOOTH() {
        return SOL_BLUETOOTH;
    }
    private static final int SOL_PNPIPE = (int)275L;
    /**
     * {@snippet lang=c :
     * #define SOL_PNPIPE 275
     * }
     */
    public static int SOL_PNPIPE() {
        return SOL_PNPIPE;
    }
    private static final int SOL_RDS = (int)276L;
    /**
     * {@snippet lang=c :
     * #define SOL_RDS 276
     * }
     */
    public static int SOL_RDS() {
        return SOL_RDS;
    }
    private static final int SOL_IUCV = (int)277L;
    /**
     * {@snippet lang=c :
     * #define SOL_IUCV 277
     * }
     */
    public static int SOL_IUCV() {
        return SOL_IUCV;
    }
    private static final int SOL_CAIF = (int)278L;
    /**
     * {@snippet lang=c :
     * #define SOL_CAIF 278
     * }
     */
    public static int SOL_CAIF() {
        return SOL_CAIF;
    }
    private static final int SOL_ALG = (int)279L;
    /**
     * {@snippet lang=c :
     * #define SOL_ALG 279
     * }
     */
    public static int SOL_ALG() {
        return SOL_ALG;
    }
    private static final int SOL_NFC = (int)280L;
    /**
     * {@snippet lang=c :
     * #define SOL_NFC 280
     * }
     */
    public static int SOL_NFC() {
        return SOL_NFC;
    }
    private static final int SOL_KCM = (int)281L;
    /**
     * {@snippet lang=c :
     * #define SOL_KCM 281
     * }
     */
    public static int SOL_KCM() {
        return SOL_KCM;
    }
    private static final int SOL_TLS = (int)282L;
    /**
     * {@snippet lang=c :
     * #define SOL_TLS 282
     * }
     */
    public static int SOL_TLS() {
        return SOL_TLS;
    }
    private static final int SOL_XDP = (int)283L;
    /**
     * {@snippet lang=c :
     * #define SOL_XDP 283
     * }
     */
    public static int SOL_XDP() {
        return SOL_XDP;
    }
    private static final int SOMAXCONN = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define SOMAXCONN 4096
     * }
     */
    public static int SOMAXCONN() {
        return SOMAXCONN;
    }
    private static final int _BITS_SOCKADDR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_SOCKADDR_H 1
     * }
     */
    public static int _BITS_SOCKADDR_H() {
        return _BITS_SOCKADDR_H;
    }
    private static final int _SS_SIZE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _SS_SIZE 128
     * }
     */
    public static int _SS_SIZE() {
        return _SS_SIZE;
    }
    private static final int __BITS_PER_LONG = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __BITS_PER_LONG 64
     * }
     */
    public static int __BITS_PER_LONG() {
        return __BITS_PER_LONG;
    }
    private static final int FIOSETOWN = (int)35073L;
    /**
     * {@snippet lang=c :
     * #define FIOSETOWN 35073
     * }
     */
    public static int FIOSETOWN() {
        return FIOSETOWN;
    }
    private static final int SIOCSPGRP = (int)35074L;
    /**
     * {@snippet lang=c :
     * #define SIOCSPGRP 35074
     * }
     */
    public static int SIOCSPGRP() {
        return SIOCSPGRP;
    }
    private static final int FIOGETOWN = (int)35075L;
    /**
     * {@snippet lang=c :
     * #define FIOGETOWN 35075
     * }
     */
    public static int FIOGETOWN() {
        return FIOGETOWN;
    }
    private static final int SIOCGPGRP = (int)35076L;
    /**
     * {@snippet lang=c :
     * #define SIOCGPGRP 35076
     * }
     */
    public static int SIOCGPGRP() {
        return SIOCGPGRP;
    }
    private static final int SIOCATMARK = (int)35077L;
    /**
     * {@snippet lang=c :
     * #define SIOCATMARK 35077
     * }
     */
    public static int SIOCATMARK() {
        return SIOCATMARK;
    }
    private static final int SIOCGSTAMP_OLD = (int)35078L;
    /**
     * {@snippet lang=c :
     * #define SIOCGSTAMP_OLD 35078
     * }
     */
    public static int SIOCGSTAMP_OLD() {
        return SIOCGSTAMP_OLD;
    }
    private static final int SIOCGSTAMPNS_OLD = (int)35079L;
    /**
     * {@snippet lang=c :
     * #define SIOCGSTAMPNS_OLD 35079
     * }
     */
    public static int SIOCGSTAMPNS_OLD() {
        return SIOCGSTAMPNS_OLD;
    }
    private static final int SOL_SOCKET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SOL_SOCKET 1
     * }
     */
    public static int SOL_SOCKET() {
        return SOL_SOCKET;
    }
    private static final int SO_DEBUG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SO_DEBUG 1
     * }
     */
    public static int SO_DEBUG() {
        return SO_DEBUG;
    }
    private static final int SO_REUSEADDR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SO_REUSEADDR 2
     * }
     */
    public static int SO_REUSEADDR() {
        return SO_REUSEADDR;
    }
    private static final int SO_TYPE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SO_TYPE 3
     * }
     */
    public static int SO_TYPE() {
        return SO_TYPE;
    }
    private static final int SO_ERROR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SO_ERROR 4
     * }
     */
    public static int SO_ERROR() {
        return SO_ERROR;
    }
    private static final int SO_DONTROUTE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SO_DONTROUTE 5
     * }
     */
    public static int SO_DONTROUTE() {
        return SO_DONTROUTE;
    }
    private static final int SO_BROADCAST = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SO_BROADCAST 6
     * }
     */
    public static int SO_BROADCAST() {
        return SO_BROADCAST;
    }
    private static final int SO_SNDBUF = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDBUF 7
     * }
     */
    public static int SO_SNDBUF() {
        return SO_SNDBUF;
    }
    private static final int SO_RCVBUF = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVBUF 8
     * }
     */
    public static int SO_RCVBUF() {
        return SO_RCVBUF;
    }
    private static final int SO_SNDBUFFORCE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDBUFFORCE 32
     * }
     */
    public static int SO_SNDBUFFORCE() {
        return SO_SNDBUFFORCE;
    }
    private static final int SO_RCVBUFFORCE = (int)33L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVBUFFORCE 33
     * }
     */
    public static int SO_RCVBUFFORCE() {
        return SO_RCVBUFFORCE;
    }
    private static final int SO_KEEPALIVE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define SO_KEEPALIVE 9
     * }
     */
    public static int SO_KEEPALIVE() {
        return SO_KEEPALIVE;
    }
    private static final int SO_OOBINLINE = (int)10L;
    /**
     * {@snippet lang=c :
     * #define SO_OOBINLINE 10
     * }
     */
    public static int SO_OOBINLINE() {
        return SO_OOBINLINE;
    }
    private static final int SO_NO_CHECK = (int)11L;
    /**
     * {@snippet lang=c :
     * #define SO_NO_CHECK 11
     * }
     */
    public static int SO_NO_CHECK() {
        return SO_NO_CHECK;
    }
    private static final int SO_PRIORITY = (int)12L;
    /**
     * {@snippet lang=c :
     * #define SO_PRIORITY 12
     * }
     */
    public static int SO_PRIORITY() {
        return SO_PRIORITY;
    }
    private static final int SO_LINGER = (int)13L;
    /**
     * {@snippet lang=c :
     * #define SO_LINGER 13
     * }
     */
    public static int SO_LINGER() {
        return SO_LINGER;
    }
    private static final int SO_BSDCOMPAT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define SO_BSDCOMPAT 14
     * }
     */
    public static int SO_BSDCOMPAT() {
        return SO_BSDCOMPAT;
    }
    private static final int SO_REUSEPORT = (int)15L;
    /**
     * {@snippet lang=c :
     * #define SO_REUSEPORT 15
     * }
     */
    public static int SO_REUSEPORT() {
        return SO_REUSEPORT;
    }
    private static final int SO_PASSCRED = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SO_PASSCRED 16
     * }
     */
    public static int SO_PASSCRED() {
        return SO_PASSCRED;
    }
    private static final int SO_PEERCRED = (int)17L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERCRED 17
     * }
     */
    public static int SO_PEERCRED() {
        return SO_PEERCRED;
    }
    private static final int SO_RCVLOWAT = (int)18L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVLOWAT 18
     * }
     */
    public static int SO_RCVLOWAT() {
        return SO_RCVLOWAT;
    }
    private static final int SO_SNDLOWAT = (int)19L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDLOWAT 19
     * }
     */
    public static int SO_SNDLOWAT() {
        return SO_SNDLOWAT;
    }
    private static final int SO_RCVTIMEO_OLD = (int)20L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVTIMEO_OLD 20
     * }
     */
    public static int SO_RCVTIMEO_OLD() {
        return SO_RCVTIMEO_OLD;
    }
    private static final int SO_SNDTIMEO_OLD = (int)21L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDTIMEO_OLD 21
     * }
     */
    public static int SO_SNDTIMEO_OLD() {
        return SO_SNDTIMEO_OLD;
    }
    private static final int SO_SECURITY_AUTHENTICATION = (int)22L;
    /**
     * {@snippet lang=c :
     * #define SO_SECURITY_AUTHENTICATION 22
     * }
     */
    public static int SO_SECURITY_AUTHENTICATION() {
        return SO_SECURITY_AUTHENTICATION;
    }
    private static final int SO_SECURITY_ENCRYPTION_TRANSPORT = (int)23L;
    /**
     * {@snippet lang=c :
     * #define SO_SECURITY_ENCRYPTION_TRANSPORT 23
     * }
     */
    public static int SO_SECURITY_ENCRYPTION_TRANSPORT() {
        return SO_SECURITY_ENCRYPTION_TRANSPORT;
    }
    private static final int SO_SECURITY_ENCRYPTION_NETWORK = (int)24L;
    /**
     * {@snippet lang=c :
     * #define SO_SECURITY_ENCRYPTION_NETWORK 24
     * }
     */
    public static int SO_SECURITY_ENCRYPTION_NETWORK() {
        return SO_SECURITY_ENCRYPTION_NETWORK;
    }
    private static final int SO_BINDTODEVICE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define SO_BINDTODEVICE 25
     * }
     */
    public static int SO_BINDTODEVICE() {
        return SO_BINDTODEVICE;
    }
    private static final int SO_ATTACH_FILTER = (int)26L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_FILTER 26
     * }
     */
    public static int SO_ATTACH_FILTER() {
        return SO_ATTACH_FILTER;
    }
    private static final int SO_DETACH_FILTER = (int)27L;
    /**
     * {@snippet lang=c :
     * #define SO_DETACH_FILTER 27
     * }
     */
    public static int SO_DETACH_FILTER() {
        return SO_DETACH_FILTER;
    }
    private static final int SO_PEERNAME = (int)28L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERNAME 28
     * }
     */
    public static int SO_PEERNAME() {
        return SO_PEERNAME;
    }
    private static final int SO_ACCEPTCONN = (int)30L;
    /**
     * {@snippet lang=c :
     * #define SO_ACCEPTCONN 30
     * }
     */
    public static int SO_ACCEPTCONN() {
        return SO_ACCEPTCONN;
    }
    private static final int SO_PEERSEC = (int)31L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERSEC 31
     * }
     */
    public static int SO_PEERSEC() {
        return SO_PEERSEC;
    }
    private static final int SO_PASSSEC = (int)34L;
    /**
     * {@snippet lang=c :
     * #define SO_PASSSEC 34
     * }
     */
    public static int SO_PASSSEC() {
        return SO_PASSSEC;
    }
    private static final int SO_MARK = (int)36L;
    /**
     * {@snippet lang=c :
     * #define SO_MARK 36
     * }
     */
    public static int SO_MARK() {
        return SO_MARK;
    }
    private static final int SO_PROTOCOL = (int)38L;
    /**
     * {@snippet lang=c :
     * #define SO_PROTOCOL 38
     * }
     */
    public static int SO_PROTOCOL() {
        return SO_PROTOCOL;
    }
    private static final int SO_DOMAIN = (int)39L;
    /**
     * {@snippet lang=c :
     * #define SO_DOMAIN 39
     * }
     */
    public static int SO_DOMAIN() {
        return SO_DOMAIN;
    }
    private static final int SO_RXQ_OVFL = (int)40L;
    /**
     * {@snippet lang=c :
     * #define SO_RXQ_OVFL 40
     * }
     */
    public static int SO_RXQ_OVFL() {
        return SO_RXQ_OVFL;
    }
    private static final int SO_WIFI_STATUS = (int)41L;
    /**
     * {@snippet lang=c :
     * #define SO_WIFI_STATUS 41
     * }
     */
    public static int SO_WIFI_STATUS() {
        return SO_WIFI_STATUS;
    }
    private static final int SO_PEEK_OFF = (int)42L;
    /**
     * {@snippet lang=c :
     * #define SO_PEEK_OFF 42
     * }
     */
    public static int SO_PEEK_OFF() {
        return SO_PEEK_OFF;
    }
    private static final int SO_NOFCS = (int)43L;
    /**
     * {@snippet lang=c :
     * #define SO_NOFCS 43
     * }
     */
    public static int SO_NOFCS() {
        return SO_NOFCS;
    }
    private static final int SO_LOCK_FILTER = (int)44L;
    /**
     * {@snippet lang=c :
     * #define SO_LOCK_FILTER 44
     * }
     */
    public static int SO_LOCK_FILTER() {
        return SO_LOCK_FILTER;
    }
    private static final int SO_SELECT_ERR_QUEUE = (int)45L;
    /**
     * {@snippet lang=c :
     * #define SO_SELECT_ERR_QUEUE 45
     * }
     */
    public static int SO_SELECT_ERR_QUEUE() {
        return SO_SELECT_ERR_QUEUE;
    }
    private static final int SO_BUSY_POLL = (int)46L;
    /**
     * {@snippet lang=c :
     * #define SO_BUSY_POLL 46
     * }
     */
    public static int SO_BUSY_POLL() {
        return SO_BUSY_POLL;
    }
    private static final int SO_MAX_PACING_RATE = (int)47L;
    /**
     * {@snippet lang=c :
     * #define SO_MAX_PACING_RATE 47
     * }
     */
    public static int SO_MAX_PACING_RATE() {
        return SO_MAX_PACING_RATE;
    }
    private static final int SO_BPF_EXTENSIONS = (int)48L;
    /**
     * {@snippet lang=c :
     * #define SO_BPF_EXTENSIONS 48
     * }
     */
    public static int SO_BPF_EXTENSIONS() {
        return SO_BPF_EXTENSIONS;
    }
    private static final int SO_INCOMING_CPU = (int)49L;
    /**
     * {@snippet lang=c :
     * #define SO_INCOMING_CPU 49
     * }
     */
    public static int SO_INCOMING_CPU() {
        return SO_INCOMING_CPU;
    }
    private static final int SO_ATTACH_BPF = (int)50L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_BPF 50
     * }
     */
    public static int SO_ATTACH_BPF() {
        return SO_ATTACH_BPF;
    }
    private static final int SO_ATTACH_REUSEPORT_CBPF = (int)51L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_REUSEPORT_CBPF 51
     * }
     */
    public static int SO_ATTACH_REUSEPORT_CBPF() {
        return SO_ATTACH_REUSEPORT_CBPF;
    }
    private static final int SO_ATTACH_REUSEPORT_EBPF = (int)52L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_REUSEPORT_EBPF 52
     * }
     */
    public static int SO_ATTACH_REUSEPORT_EBPF() {
        return SO_ATTACH_REUSEPORT_EBPF;
    }
    private static final int SO_CNX_ADVICE = (int)53L;
    /**
     * {@snippet lang=c :
     * #define SO_CNX_ADVICE 53
     * }
     */
    public static int SO_CNX_ADVICE() {
        return SO_CNX_ADVICE;
    }
    private static final int SCM_TIMESTAMPING_OPT_STATS = (int)54L;
    /**
     * {@snippet lang=c :
     * #define SCM_TIMESTAMPING_OPT_STATS 54
     * }
     */
    public static int SCM_TIMESTAMPING_OPT_STATS() {
        return SCM_TIMESTAMPING_OPT_STATS;
    }
    private static final int SO_MEMINFO = (int)55L;
    /**
     * {@snippet lang=c :
     * #define SO_MEMINFO 55
     * }
     */
    public static int SO_MEMINFO() {
        return SO_MEMINFO;
    }
    private static final int SO_INCOMING_NAPI_ID = (int)56L;
    /**
     * {@snippet lang=c :
     * #define SO_INCOMING_NAPI_ID 56
     * }
     */
    public static int SO_INCOMING_NAPI_ID() {
        return SO_INCOMING_NAPI_ID;
    }
    private static final int SO_COOKIE = (int)57L;
    /**
     * {@snippet lang=c :
     * #define SO_COOKIE 57
     * }
     */
    public static int SO_COOKIE() {
        return SO_COOKIE;
    }
    private static final int SCM_TIMESTAMPING_PKTINFO = (int)58L;
    /**
     * {@snippet lang=c :
     * #define SCM_TIMESTAMPING_PKTINFO 58
     * }
     */
    public static int SCM_TIMESTAMPING_PKTINFO() {
        return SCM_TIMESTAMPING_PKTINFO;
    }
    private static final int SO_PEERGROUPS = (int)59L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERGROUPS 59
     * }
     */
    public static int SO_PEERGROUPS() {
        return SO_PEERGROUPS;
    }
    private static final int SO_ZEROCOPY = (int)60L;
    /**
     * {@snippet lang=c :
     * #define SO_ZEROCOPY 60
     * }
     */
    public static int SO_ZEROCOPY() {
        return SO_ZEROCOPY;
    }
    private static final int SO_TXTIME = (int)61L;
    /**
     * {@snippet lang=c :
     * #define SO_TXTIME 61
     * }
     */
    public static int SO_TXTIME() {
        return SO_TXTIME;
    }
    private static final int SO_BINDTOIFINDEX = (int)62L;
    /**
     * {@snippet lang=c :
     * #define SO_BINDTOIFINDEX 62
     * }
     */
    public static int SO_BINDTOIFINDEX() {
        return SO_BINDTOIFINDEX;
    }
    private static final int SO_TIMESTAMP_OLD = (int)29L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMP_OLD 29
     * }
     */
    public static int SO_TIMESTAMP_OLD() {
        return SO_TIMESTAMP_OLD;
    }
    private static final int SO_TIMESTAMPNS_OLD = (int)35L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPNS_OLD 35
     * }
     */
    public static int SO_TIMESTAMPNS_OLD() {
        return SO_TIMESTAMPNS_OLD;
    }
    private static final int SO_TIMESTAMPING_OLD = (int)37L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPING_OLD 37
     * }
     */
    public static int SO_TIMESTAMPING_OLD() {
        return SO_TIMESTAMPING_OLD;
    }
    private static final int SO_TIMESTAMP_NEW = (int)63L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMP_NEW 63
     * }
     */
    public static int SO_TIMESTAMP_NEW() {
        return SO_TIMESTAMP_NEW;
    }
    private static final int SO_TIMESTAMPNS_NEW = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPNS_NEW 64
     * }
     */
    public static int SO_TIMESTAMPNS_NEW() {
        return SO_TIMESTAMPNS_NEW;
    }
    private static final int SO_TIMESTAMPING_NEW = (int)65L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPING_NEW 65
     * }
     */
    public static int SO_TIMESTAMPING_NEW() {
        return SO_TIMESTAMPING_NEW;
    }
    private static final int SO_RCVTIMEO_NEW = (int)66L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVTIMEO_NEW 66
     * }
     */
    public static int SO_RCVTIMEO_NEW() {
        return SO_RCVTIMEO_NEW;
    }
    private static final int SO_SNDTIMEO_NEW = (int)67L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDTIMEO_NEW 67
     * }
     */
    public static int SO_SNDTIMEO_NEW() {
        return SO_SNDTIMEO_NEW;
    }
    private static final int SO_DETACH_REUSEPORT_BPF = (int)68L;
    /**
     * {@snippet lang=c :
     * #define SO_DETACH_REUSEPORT_BPF 68
     * }
     */
    public static int SO_DETACH_REUSEPORT_BPF() {
        return SO_DETACH_REUSEPORT_BPF;
    }
    private static final int SO_PREFER_BUSY_POLL = (int)69L;
    /**
     * {@snippet lang=c :
     * #define SO_PREFER_BUSY_POLL 69
     * }
     */
    public static int SO_PREFER_BUSY_POLL() {
        return SO_PREFER_BUSY_POLL;
    }
    private static final int SO_BUSY_POLL_BUDGET = (int)70L;
    /**
     * {@snippet lang=c :
     * #define SO_BUSY_POLL_BUDGET 70
     * }
     */
    public static int SO_BUSY_POLL_BUDGET() {
        return SO_BUSY_POLL_BUDGET;
    }
    private static final int SO_NETNS_COOKIE = (int)71L;
    /**
     * {@snippet lang=c :
     * #define SO_NETNS_COOKIE 71
     * }
     */
    public static int SO_NETNS_COOKIE() {
        return SO_NETNS_COOKIE;
    }
    private static final int SO_BUF_LOCK = (int)72L;
    /**
     * {@snippet lang=c :
     * #define SO_BUF_LOCK 72
     * }
     */
    public static int SO_BUF_LOCK() {
        return SO_BUF_LOCK;
    }
    private static final int __osockaddr_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __osockaddr_defined 1
     * }
     */
    public static int __osockaddr_defined() {
        return __osockaddr_defined;
    }
    private static final int _STDINT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDINT_H 1
     * }
     */
    public static int _STDINT_H() {
        return _STDINT_H;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int _BITS_WCHAR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_WCHAR_H 1
     * }
     */
    public static int _BITS_WCHAR_H() {
        return _BITS_WCHAR_H;
    }
    private static final int _BITS_STDINT_UINTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_UINTN_H 1
     * }
     */
    public static int _BITS_STDINT_UINTN_H() {
        return _BITS_STDINT_UINTN_H;
    }
    private static final int UCP_ENTITY_NAME_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define UCP_ENTITY_NAME_MAX 32
     * }
     */
    public static int UCP_ENTITY_NAME_MAX() {
        return UCP_ENTITY_NAME_MAX;
    }
    private static final int UCP_VERSION_MAJOR_SHIFT = (int)24L;
    /**
     * {@snippet lang=c :
     * #define UCP_VERSION_MAJOR_SHIFT 24
     * }
     */
    public static int UCP_VERSION_MAJOR_SHIFT() {
        return UCP_VERSION_MAJOR_SHIFT;
    }
    private static final int UCP_VERSION_MINOR_SHIFT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define UCP_VERSION_MINOR_SHIFT 16
     * }
     */
    public static int UCP_VERSION_MINOR_SHIFT() {
        return UCP_VERSION_MINOR_SHIFT;
    }
    private static final int UCP_API_MAJOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define UCP_API_MAJOR 1
     * }
     */
    public static int UCP_API_MAJOR() {
        return UCP_API_MAJOR;
    }
    private static final int UCP_API_MINOR = (int)21L;
    /**
     * {@snippet lang=c :
     * #define UCP_API_MINOR 21
     * }
     */
    public static int UCP_API_MINOR() {
        return UCP_API_MINOR;
    }
    private static final int UCS_CPU_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define UCS_CPU_SETSIZE 1024
     * }
     */
    public static int UCS_CPU_SETSIZE() {
        return UCS_CPU_SETSIZE;
    }
    private static final int _STDIO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDIO_H 1
     * }
     */
    public static int _STDIO_H() {
        return _STDIO_H;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _____fpos_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos_t_defined 1
     * }
     */
    public static int _____fpos_t_defined() {
        return _____fpos_t_defined;
    }
    private static final int ____mbstate_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____mbstate_t_defined 1
     * }
     */
    public static int ____mbstate_t_defined() {
        return ____mbstate_t_defined;
    }
    private static final int _____fpos64_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos64_t_defined 1
     * }
     */
    public static int _____fpos64_t_defined() {
        return _____fpos64_t_defined;
    }
    private static final int ____FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____FILE_defined 1
     * }
     */
    public static int ____FILE_defined() {
        return ____FILE_defined;
    }
    private static final int __FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __FILE_defined 1
     * }
     */
    public static int __FILE_defined() {
        return __FILE_defined;
    }
    private static final int __struct_FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_FILE_defined 1
     * }
     */
    public static int __struct_FILE_defined() {
        return __struct_FILE_defined;
    }
    private static final int _IO_EOF_SEEN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IO_EOF_SEEN 16
     * }
     */
    public static int _IO_EOF_SEEN() {
        return _IO_EOF_SEEN;
    }
    private static final int _IO_ERR_SEEN = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _IO_ERR_SEEN 32
     * }
     */
    public static int _IO_ERR_SEEN() {
        return _IO_ERR_SEEN;
    }
    private static final int _IO_USER_LOCK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _IO_USER_LOCK 32768
     * }
     */
    public static int _IO_USER_LOCK() {
        return _IO_USER_LOCK;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int BUFSIZ = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 8192
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int _BITS_STDIO_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDIO_LIM_H 1
     * }
     */
    public static int _BITS_STDIO_LIM_H() {
        return _BITS_STDIO_LIM_H;
    }
    private static final int L_tmpnam = (int)20L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 20
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)238328L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 238328
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int FILENAME_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 4096
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_ctermid = (int)9L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 9
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int FOPEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 16
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int __HAVE_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128 0
     * }
     */
    public static int __HAVE_FLOAT128() {
        return __HAVE_FLOAT128;
    }
    private static final int __HAVE_DISTINCT_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128() {
        return __HAVE_DISTINCT_FLOAT128;
    }
    private static final int __HAVE_FLOAT64X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X 1
     * }
     */
    public static int __HAVE_FLOAT64X() {
        return __HAVE_FLOAT64X;
    }
    private static final int __HAVE_FLOAT64X_LONG_DOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X_LONG_DOUBLE 1
     * }
     */
    public static int __HAVE_FLOAT64X_LONG_DOUBLE() {
        return __HAVE_FLOAT64X_LONG_DOUBLE;
    }
    private static final int __HAVE_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT16 0
     * }
     */
    public static int __HAVE_FLOAT16() {
        return __HAVE_FLOAT16;
    }
    private static final int __HAVE_FLOAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32 1
     * }
     */
    public static int __HAVE_FLOAT32() {
        return __HAVE_FLOAT32;
    }
    private static final int __HAVE_FLOAT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64 1
     * }
     */
    public static int __HAVE_FLOAT64() {
        return __HAVE_FLOAT64;
    }
    private static final int __HAVE_FLOAT32X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32X 1
     * }
     */
    public static int __HAVE_FLOAT32X() {
        return __HAVE_FLOAT32X;
    }
    private static final int __HAVE_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128X 0
     * }
     */
    public static int __HAVE_FLOAT128X() {
        return __HAVE_FLOAT128X;
    }
    private static final int __HAVE_DISTINCT_FLOAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32() {
        return __HAVE_DISTINCT_FLOAT32;
    }
    private static final int __HAVE_DISTINCT_FLOAT64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64() {
        return __HAVE_DISTINCT_FLOAT64;
    }
    private static final int __HAVE_DISTINCT_FLOAT32X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32X() {
        return __HAVE_DISTINCT_FLOAT32X;
    }
    private static final int __HAVE_DISTINCT_FLOAT64X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64X() {
        return __HAVE_DISTINCT_FLOAT64X;
    }
    private static final int __HAVE_FLOATN_NOT_TYPEDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOATN_NOT_TYPEDEF 0
     * }
     */
    public static int __HAVE_FLOATN_NOT_TYPEDEF() {
        return __HAVE_FLOATN_NOT_TYPEDEF;
    }
    private static final int UCS_MEMORY_TYPE_HOST = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ucs_memory_type.UCS_MEMORY_TYPE_HOST = 0
     * }
     */
    public static int UCS_MEMORY_TYPE_HOST() {
        return UCS_MEMORY_TYPE_HOST;
    }
    private static final int UCS_MEMORY_TYPE_CUDA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucs_memory_type.UCS_MEMORY_TYPE_CUDA = 1
     * }
     */
    public static int UCS_MEMORY_TYPE_CUDA() {
        return UCS_MEMORY_TYPE_CUDA;
    }
    private static final int UCS_MEMORY_TYPE_CUDA_MANAGED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucs_memory_type.UCS_MEMORY_TYPE_CUDA_MANAGED = 2
     * }
     */
    public static int UCS_MEMORY_TYPE_CUDA_MANAGED() {
        return UCS_MEMORY_TYPE_CUDA_MANAGED;
    }
    private static final int UCS_MEMORY_TYPE_ROCM = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ucs_memory_type.UCS_MEMORY_TYPE_ROCM = 3
     * }
     */
    public static int UCS_MEMORY_TYPE_ROCM() {
        return UCS_MEMORY_TYPE_ROCM;
    }
    private static final int UCS_MEMORY_TYPE_ROCM_MANAGED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucs_memory_type.UCS_MEMORY_TYPE_ROCM_MANAGED = 4
     * }
     */
    public static int UCS_MEMORY_TYPE_ROCM_MANAGED() {
        return UCS_MEMORY_TYPE_ROCM_MANAGED;
    }
    private static final int UCS_MEMORY_TYPE_RDMA = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ucs_memory_type.UCS_MEMORY_TYPE_RDMA = 5
     * }
     */
    public static int UCS_MEMORY_TYPE_RDMA() {
        return UCS_MEMORY_TYPE_RDMA;
    }
    private static final int UCS_MEMORY_TYPE_ZE_HOST = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ucs_memory_type.UCS_MEMORY_TYPE_ZE_HOST = 6
     * }
     */
    public static int UCS_MEMORY_TYPE_ZE_HOST() {
        return UCS_MEMORY_TYPE_ZE_HOST;
    }
    private static final int UCS_MEMORY_TYPE_ZE_DEVICE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ucs_memory_type.UCS_MEMORY_TYPE_ZE_DEVICE = 7
     * }
     */
    public static int UCS_MEMORY_TYPE_ZE_DEVICE() {
        return UCS_MEMORY_TYPE_ZE_DEVICE;
    }
    private static final int UCS_MEMORY_TYPE_ZE_MANAGED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucs_memory_type.UCS_MEMORY_TYPE_ZE_MANAGED = 8
     * }
     */
    public static int UCS_MEMORY_TYPE_ZE_MANAGED() {
        return UCS_MEMORY_TYPE_ZE_MANAGED;
    }
    private static final int UCS_MEMORY_TYPE_GAUDI = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ucs_memory_type.UCS_MEMORY_TYPE_GAUDI = 9
     * }
     */
    public static int UCS_MEMORY_TYPE_GAUDI() {
        return UCS_MEMORY_TYPE_GAUDI;
    }
    private static final int UCS_MEMORY_TYPE_LAST = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ucs_memory_type.UCS_MEMORY_TYPE_LAST = 10
     * }
     */
    public static int UCS_MEMORY_TYPE_LAST() {
        return UCS_MEMORY_TYPE_LAST;
    }
    private static final int UCS_MEMORY_TYPE_UNKNOWN = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ucs_memory_type.UCS_MEMORY_TYPE_UNKNOWN = 10
     * }
     */
    public static int UCS_MEMORY_TYPE_UNKNOWN() {
        return UCS_MEMORY_TYPE_UNKNOWN;
    }

    private static class ucs_memory_type_names$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, Ucx.C_POINTER);
        public static final MemorySegment SEGMENT = Ucx.findOrThrow("ucs_memory_type_names").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *ucs_memory_type_names[]
     * }
     */
    public static SequenceLayout ucs_memory_type_names$layout() {
        return ucs_memory_type_names$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char *ucs_memory_type_names[]
     * }
     */
    public static long[] ucs_memory_type_names$dimensions() {
        return ucs_memory_type_names$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *ucs_memory_type_names[]
     * }
     */
    public static MemorySegment ucs_memory_type_names() {
        return ucs_memory_type_names$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *ucs_memory_type_names[]
     * }
     */
    public static void ucs_memory_type_names(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, ucs_memory_type_names$constants.SEGMENT, 0L, ucs_memory_type_names$constants.LAYOUT.byteSize());
    }

    private static class ucs_memory_type_descs$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, Ucx.C_POINTER);
        public static final MemorySegment SEGMENT = Ucx.findOrThrow("ucs_memory_type_descs").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *ucs_memory_type_descs[]
     * }
     */
    public static SequenceLayout ucs_memory_type_descs$layout() {
        return ucs_memory_type_descs$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char *ucs_memory_type_descs[]
     * }
     */
    public static long[] ucs_memory_type_descs$dimensions() {
        return ucs_memory_type_descs$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *ucs_memory_type_descs[]
     * }
     */
    public static MemorySegment ucs_memory_type_descs() {
        return ucs_memory_type_descs$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *ucs_memory_type_descs[]
     * }
     */
    public static void ucs_memory_type_descs(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, ucs_memory_type_descs$constants.SEGMENT, 0L, ucs_memory_type_descs$constants.LAYOUT.byteSize());
    }
    private static final int UCS_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_OK = 0
     * }
     */
    public static int UCS_OK() {
        return UCS_OK;
    }
    private static final int UCS_INPROGRESS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_INPROGRESS = 1
     * }
     */
    public static int UCS_INPROGRESS() {
        return UCS_INPROGRESS;
    }
    private static final int UCS_ERR_NO_MESSAGE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_NO_MESSAGE = -1
     * }
     */
    public static int UCS_ERR_NO_MESSAGE() {
        return UCS_ERR_NO_MESSAGE;
    }
    private static final int UCS_ERR_NO_RESOURCE = (int)-2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_NO_RESOURCE = -2
     * }
     */
    public static int UCS_ERR_NO_RESOURCE() {
        return UCS_ERR_NO_RESOURCE;
    }
    private static final int UCS_ERR_IO_ERROR = (int)-3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_IO_ERROR = -3
     * }
     */
    public static int UCS_ERR_IO_ERROR() {
        return UCS_ERR_IO_ERROR;
    }
    private static final int UCS_ERR_NO_MEMORY = (int)-4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_NO_MEMORY = -4
     * }
     */
    public static int UCS_ERR_NO_MEMORY() {
        return UCS_ERR_NO_MEMORY;
    }
    private static final int UCS_ERR_INVALID_PARAM = (int)-5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_INVALID_PARAM = -5
     * }
     */
    public static int UCS_ERR_INVALID_PARAM() {
        return UCS_ERR_INVALID_PARAM;
    }
    private static final int UCS_ERR_UNREACHABLE = (int)-6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_UNREACHABLE = -6
     * }
     */
    public static int UCS_ERR_UNREACHABLE() {
        return UCS_ERR_UNREACHABLE;
    }
    private static final int UCS_ERR_INVALID_ADDR = (int)-7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_INVALID_ADDR = -7
     * }
     */
    public static int UCS_ERR_INVALID_ADDR() {
        return UCS_ERR_INVALID_ADDR;
    }
    private static final int UCS_ERR_NOT_IMPLEMENTED = (int)-8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_NOT_IMPLEMENTED = -8
     * }
     */
    public static int UCS_ERR_NOT_IMPLEMENTED() {
        return UCS_ERR_NOT_IMPLEMENTED;
    }
    private static final int UCS_ERR_MESSAGE_TRUNCATED = (int)-9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_MESSAGE_TRUNCATED = -9
     * }
     */
    public static int UCS_ERR_MESSAGE_TRUNCATED() {
        return UCS_ERR_MESSAGE_TRUNCATED;
    }
    private static final int UCS_ERR_NO_PROGRESS = (int)-10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_NO_PROGRESS = -10
     * }
     */
    public static int UCS_ERR_NO_PROGRESS() {
        return UCS_ERR_NO_PROGRESS;
    }
    private static final int UCS_ERR_BUFFER_TOO_SMALL = (int)-11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_BUFFER_TOO_SMALL = -11
     * }
     */
    public static int UCS_ERR_BUFFER_TOO_SMALL() {
        return UCS_ERR_BUFFER_TOO_SMALL;
    }
    private static final int UCS_ERR_NO_ELEM = (int)-12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_NO_ELEM = -12
     * }
     */
    public static int UCS_ERR_NO_ELEM() {
        return UCS_ERR_NO_ELEM;
    }
    private static final int UCS_ERR_SOME_CONNECTS_FAILED = (int)-13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_SOME_CONNECTS_FAILED = -13
     * }
     */
    public static int UCS_ERR_SOME_CONNECTS_FAILED() {
        return UCS_ERR_SOME_CONNECTS_FAILED;
    }
    private static final int UCS_ERR_NO_DEVICE = (int)-14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_NO_DEVICE = -14
     * }
     */
    public static int UCS_ERR_NO_DEVICE() {
        return UCS_ERR_NO_DEVICE;
    }
    private static final int UCS_ERR_BUSY = (int)-15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_BUSY = -15
     * }
     */
    public static int UCS_ERR_BUSY() {
        return UCS_ERR_BUSY;
    }
    private static final int UCS_ERR_CANCELED = (int)-16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_CANCELED = -16
     * }
     */
    public static int UCS_ERR_CANCELED() {
        return UCS_ERR_CANCELED;
    }
    private static final int UCS_ERR_SHMEM_SEGMENT = (int)-17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_SHMEM_SEGMENT = -17
     * }
     */
    public static int UCS_ERR_SHMEM_SEGMENT() {
        return UCS_ERR_SHMEM_SEGMENT;
    }
    private static final int UCS_ERR_ALREADY_EXISTS = (int)-18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_ALREADY_EXISTS = -18
     * }
     */
    public static int UCS_ERR_ALREADY_EXISTS() {
        return UCS_ERR_ALREADY_EXISTS;
    }
    private static final int UCS_ERR_OUT_OF_RANGE = (int)-19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_OUT_OF_RANGE = -19
     * }
     */
    public static int UCS_ERR_OUT_OF_RANGE() {
        return UCS_ERR_OUT_OF_RANGE;
    }
    private static final int UCS_ERR_TIMED_OUT = (int)-20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_TIMED_OUT = -20
     * }
     */
    public static int UCS_ERR_TIMED_OUT() {
        return UCS_ERR_TIMED_OUT;
    }
    private static final int UCS_ERR_EXCEEDS_LIMIT = (int)-21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_EXCEEDS_LIMIT = -21
     * }
     */
    public static int UCS_ERR_EXCEEDS_LIMIT() {
        return UCS_ERR_EXCEEDS_LIMIT;
    }
    private static final int UCS_ERR_UNSUPPORTED = (int)-22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_UNSUPPORTED = -22
     * }
     */
    public static int UCS_ERR_UNSUPPORTED() {
        return UCS_ERR_UNSUPPORTED;
    }
    private static final int UCS_ERR_REJECTED = (int)-23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_REJECTED = -23
     * }
     */
    public static int UCS_ERR_REJECTED() {
        return UCS_ERR_REJECTED;
    }
    private static final int UCS_ERR_NOT_CONNECTED = (int)-24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_NOT_CONNECTED = -24
     * }
     */
    public static int UCS_ERR_NOT_CONNECTED() {
        return UCS_ERR_NOT_CONNECTED;
    }
    private static final int UCS_ERR_CONNECTION_RESET = (int)-25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_CONNECTION_RESET = -25
     * }
     */
    public static int UCS_ERR_CONNECTION_RESET() {
        return UCS_ERR_CONNECTION_RESET;
    }
    private static final int UCS_ERR_FIRST_LINK_FAILURE = (int)-40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_FIRST_LINK_FAILURE = -40
     * }
     */
    public static int UCS_ERR_FIRST_LINK_FAILURE() {
        return UCS_ERR_FIRST_LINK_FAILURE;
    }
    private static final int UCS_ERR_LAST_LINK_FAILURE = (int)-59L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_LAST_LINK_FAILURE = -59
     * }
     */
    public static int UCS_ERR_LAST_LINK_FAILURE() {
        return UCS_ERR_LAST_LINK_FAILURE;
    }
    private static final int UCS_ERR_FIRST_ENDPOINT_FAILURE = (int)-60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_FIRST_ENDPOINT_FAILURE = -60
     * }
     */
    public static int UCS_ERR_FIRST_ENDPOINT_FAILURE() {
        return UCS_ERR_FIRST_ENDPOINT_FAILURE;
    }
    private static final int UCS_ERR_ENDPOINT_TIMEOUT = (int)-80L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_ENDPOINT_TIMEOUT = -80
     * }
     */
    public static int UCS_ERR_ENDPOINT_TIMEOUT() {
        return UCS_ERR_ENDPOINT_TIMEOUT;
    }
    private static final int UCS_ERR_LAST_ENDPOINT_FAILURE = (int)-89L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_LAST_ENDPOINT_FAILURE = -89
     * }
     */
    public static int UCS_ERR_LAST_ENDPOINT_FAILURE() {
        return UCS_ERR_LAST_ENDPOINT_FAILURE;
    }
    private static final int UCS_ERR_LAST = (int)-100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ERR_LAST = -100
     * }
     */
    public static int UCS_ERR_LAST() {
        return UCS_ERR_LAST;
    }
    /**
     * {@snippet lang=c :
     * typedef void *ucs_status_ptr_t
     * }
     */
    public static final AddressLayout ucs_status_ptr_t = Ucx.C_POINTER;

    private static class ucs_status_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucs_status_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ucs_status_string(ucs_status_t status)
     * }
     */
    public static FunctionDescriptor ucs_status_string$descriptor() {
        return ucs_status_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ucs_status_string(ucs_status_t status)
     * }
     */
    public static MethodHandle ucs_status_string$handle() {
        return ucs_status_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ucs_status_string(ucs_status_t status)
     * }
     */
    public static MemorySegment ucs_status_string$address() {
        return ucs_status_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ucs_status_string(ucs_status_t status)
     * }
     */
    public static MemorySegment ucs_status_string(int status) {
        var mh$ = ucs_status_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucs_status_string", status);
            }
            return (MemorySegment)mh$.invokeExact(status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = Ucx.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = Ucx.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = Ucx.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = Ucx.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = Ucx.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = Ucx.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = Ucx.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = Ucx.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = Ucx.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = Ucx.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = Ucx.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = Ucx.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = Ucx.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = Ucx.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = Ucx.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = Ucx.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = Ucx.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = Ucx.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = Ucx.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = Ucx.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = Ucx.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = Ucx.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __socklen_t socklen_t
     * }
     */
    public static final OfInt socklen_t = Ucx.C_INT;
    private static final int SOCK_STREAM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_STREAM = 1
     * }
     */
    public static int SOCK_STREAM() {
        return SOCK_STREAM;
    }
    private static final int SOCK_DGRAM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_DGRAM = 2
     * }
     */
    public static int SOCK_DGRAM() {
        return SOCK_DGRAM;
    }
    private static final int SOCK_RAW = (int)3L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_RAW = 3
     * }
     */
    public static int SOCK_RAW() {
        return SOCK_RAW;
    }
    private static final int SOCK_RDM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_RDM = 4
     * }
     */
    public static int SOCK_RDM() {
        return SOCK_RDM;
    }
    private static final int SOCK_SEQPACKET = (int)5L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_SEQPACKET = 5
     * }
     */
    public static int SOCK_SEQPACKET() {
        return SOCK_SEQPACKET;
    }
    private static final int SOCK_DCCP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_DCCP = 6
     * }
     */
    public static int SOCK_DCCP() {
        return SOCK_DCCP;
    }
    private static final int SOCK_PACKET = (int)10L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_PACKET = 10
     * }
     */
    public static int SOCK_PACKET() {
        return SOCK_PACKET;
    }
    private static final int SOCK_CLOEXEC = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_CLOEXEC = 524288
     * }
     */
    public static int SOCK_CLOEXEC() {
        return SOCK_CLOEXEC;
    }
    private static final int SOCK_NONBLOCK = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_NONBLOCK = 2048
     * }
     */
    public static int SOCK_NONBLOCK() {
        return SOCK_NONBLOCK;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned short sa_family_t
     * }
     */
    public static final OfShort sa_family_t = Ucx.C_SHORT;
    private static final int MSG_OOB = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_OOB = 1
     * }
     */
    public static int MSG_OOB() {
        return MSG_OOB;
    }
    private static final int MSG_PEEK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_PEEK = 2
     * }
     */
    public static int MSG_PEEK() {
        return MSG_PEEK;
    }
    private static final int MSG_DONTROUTE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_DONTROUTE = 4
     * }
     */
    public static int MSG_DONTROUTE() {
        return MSG_DONTROUTE;
    }
    private static final int MSG_CTRUNC = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_CTRUNC = 8
     * }
     */
    public static int MSG_CTRUNC() {
        return MSG_CTRUNC;
    }
    private static final int MSG_PROXY = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_PROXY = 16
     * }
     */
    public static int MSG_PROXY() {
        return MSG_PROXY;
    }
    private static final int MSG_TRUNC = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_TRUNC = 32
     * }
     */
    public static int MSG_TRUNC() {
        return MSG_TRUNC;
    }
    private static final int MSG_DONTWAIT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_DONTWAIT = 64
     * }
     */
    public static int MSG_DONTWAIT() {
        return MSG_DONTWAIT;
    }
    private static final int MSG_EOR = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_EOR = 128
     * }
     */
    public static int MSG_EOR() {
        return MSG_EOR;
    }
    private static final int MSG_WAITALL = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_WAITALL = 256
     * }
     */
    public static int MSG_WAITALL() {
        return MSG_WAITALL;
    }
    private static final int MSG_FIN = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_FIN = 512
     * }
     */
    public static int MSG_FIN() {
        return MSG_FIN;
    }
    private static final int MSG_SYN = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_SYN = 1024
     * }
     */
    public static int MSG_SYN() {
        return MSG_SYN;
    }
    private static final int MSG_CONFIRM = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_CONFIRM = 2048
     * }
     */
    public static int MSG_CONFIRM() {
        return MSG_CONFIRM;
    }
    private static final int MSG_RST = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_RST = 4096
     * }
     */
    public static int MSG_RST() {
        return MSG_RST;
    }
    private static final int MSG_ERRQUEUE = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_ERRQUEUE = 8192
     * }
     */
    public static int MSG_ERRQUEUE() {
        return MSG_ERRQUEUE;
    }
    private static final int MSG_NOSIGNAL = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_NOSIGNAL = 16384
     * }
     */
    public static int MSG_NOSIGNAL() {
        return MSG_NOSIGNAL;
    }
    private static final int MSG_MORE = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_MORE = 32768
     * }
     */
    public static int MSG_MORE() {
        return MSG_MORE;
    }
    private static final int MSG_WAITFORONE = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_WAITFORONE = 65536
     * }
     */
    public static int MSG_WAITFORONE() {
        return MSG_WAITFORONE;
    }
    private static final int MSG_BATCH = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_BATCH = 262144
     * }
     */
    public static int MSG_BATCH() {
        return MSG_BATCH;
    }
    private static final int MSG_ZEROCOPY = (int)67108864L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_ZEROCOPY = 67108864
     * }
     */
    public static int MSG_ZEROCOPY() {
        return MSG_ZEROCOPY;
    }
    private static final int MSG_FASTOPEN = (int)536870912L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_FASTOPEN = 536870912
     * }
     */
    public static int MSG_FASTOPEN() {
        return MSG_FASTOPEN;
    }
    private static final int MSG_CMSG_CLOEXEC = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_CMSG_CLOEXEC = 1073741824
     * }
     */
    public static int MSG_CMSG_CLOEXEC() {
        return MSG_CMSG_CLOEXEC;
    }

    private static class __cmsg_nxthdr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("__cmsg_nxthdr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static FunctionDescriptor __cmsg_nxthdr$descriptor() {
        return __cmsg_nxthdr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static MethodHandle __cmsg_nxthdr$handle() {
        return __cmsg_nxthdr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static MemorySegment __cmsg_nxthdr$address() {
        return __cmsg_nxthdr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static MemorySegment __cmsg_nxthdr(MemorySegment __mhdr, MemorySegment __cmsg) {
        var mh$ = __cmsg_nxthdr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cmsg_nxthdr", __mhdr, __cmsg);
            }
            return (MemorySegment)mh$.invokeExact(__mhdr, __cmsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SCM_RIGHTS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCM_RIGHTS = 1
     * }
     */
    public static int SCM_RIGHTS() {
        return SCM_RIGHTS;
    }
    /**
     * {@snippet lang=c :
     * typedef int __kernel_key_t
     * }
     */
    public static final OfInt __kernel_key_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_mqd_t
     * }
     */
    public static final OfInt __kernel_mqd_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_old_uid_t
     * }
     */
    public static final OfShort __kernel_old_uid_t = Ucx.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_old_gid_t
     * }
     */
    public static final OfShort __kernel_old_gid_t = Ucx.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __kernel_old_dev_t
     * }
     */
    public static final OfLong __kernel_old_dev_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __kernel_long_t
     * }
     */
    public static final OfLong __kernel_long_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __kernel_ulong_t
     * }
     */
    public static final OfLong __kernel_ulong_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_ulong_t __kernel_ino_t
     * }
     */
    public static final OfLong __kernel_ino_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_mode_t
     * }
     */
    public static final OfInt __kernel_mode_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_pid_t
     * }
     */
    public static final OfInt __kernel_pid_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_ipc_pid_t
     * }
     */
    public static final OfInt __kernel_ipc_pid_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_uid_t
     * }
     */
    public static final OfInt __kernel_uid_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_gid_t
     * }
     */
    public static final OfInt __kernel_gid_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_suseconds_t
     * }
     */
    public static final OfLong __kernel_suseconds_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_daddr_t
     * }
     */
    public static final OfInt __kernel_daddr_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_uid32_t
     * }
     */
    public static final OfInt __kernel_uid32_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_gid32_t
     * }
     */
    public static final OfInt __kernel_gid32_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __kernel_ulong_t __kernel_size_t
     * }
     */
    public static final OfLong __kernel_size_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_ssize_t
     * }
     */
    public static final OfLong __kernel_ssize_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_ptrdiff_t
     * }
     */
    public static final OfLong __kernel_ptrdiff_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_off_t
     * }
     */
    public static final OfLong __kernel_off_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __kernel_loff_t
     * }
     */
    public static final OfLong __kernel_loff_t = Ucx.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_old_time_t
     * }
     */
    public static final OfLong __kernel_old_time_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_time_t
     * }
     */
    public static final OfLong __kernel_time_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __kernel_time64_t
     * }
     */
    public static final OfLong __kernel_time64_t = Ucx.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_clock_t
     * }
     */
    public static final OfLong __kernel_clock_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_timer_t
     * }
     */
    public static final OfInt __kernel_timer_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_clockid_t
     * }
     */
    public static final OfInt __kernel_clockid_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef char *__kernel_caddr_t
     * }
     */
    public static final AddressLayout __kernel_caddr_t = Ucx.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_uid16_t
     * }
     */
    public static final OfShort __kernel_uid16_t = Ucx.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_gid16_t
     * }
     */
    public static final OfShort __kernel_gid16_t = Ucx.C_SHORT;
    private static final int SHUT_RD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHUT_RD = 0
     * }
     */
    public static int SHUT_RD() {
        return SHUT_RD;
    }
    private static final int SHUT_WR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHUT_WR = 1
     * }
     */
    public static int SHUT_WR() {
        return SHUT_WR;
    }
    private static final int SHUT_RDWR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHUT_RDWR = 2
     * }
     */
    public static int SHUT_RDWR() {
        return SHUT_RDWR;
    }

    private static class socket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("socket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static FunctionDescriptor socket$descriptor() {
        return socket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static MethodHandle socket$handle() {
        return socket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static MemorySegment socket$address() {
        return socket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static int socket(int __domain, int __type, int __protocol) {
        var mh$ = socket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socket", __domain, __type, __protocol);
            }
            return (int)mh$.invokeExact(__domain, __type, __protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class socketpair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("socketpair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static FunctionDescriptor socketpair$descriptor() {
        return socketpair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static MethodHandle socketpair$handle() {
        return socketpair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static MemorySegment socketpair$address() {
        return socketpair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static int socketpair(int __domain, int __type, int __protocol, MemorySegment __fds) {
        var mh$ = socketpair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socketpair", __domain, __type, __protocol, __fds);
            }
            return (int)mh$.invokeExact(__domain, __type, __protocol, __fds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("bind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static FunctionDescriptor bind$descriptor() {
        return bind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MethodHandle bind$handle() {
        return bind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MemorySegment bind$address() {
        return bind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static int bind(int __fd, MemorySegment __addr, int __len) {
        var mh$ = bind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bind", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("getsockname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static FunctionDescriptor getsockname$descriptor() {
        return getsockname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MethodHandle getsockname$handle() {
        return getsockname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MemorySegment getsockname$address() {
        return getsockname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static int getsockname(int __fd, MemorySegment __addr, MemorySegment __len) {
        var mh$ = getsockname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockname", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class connect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("connect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static FunctionDescriptor connect$descriptor() {
        return connect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MethodHandle connect$handle() {
        return connect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MemorySegment connect$address() {
        return connect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static int connect(int __fd, MemorySegment __addr, int __len) {
        var mh$ = connect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("connect", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpeername {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("getpeername");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static FunctionDescriptor getpeername$descriptor() {
        return getpeername.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MethodHandle getpeername$handle() {
        return getpeername.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MemorySegment getpeername$address() {
        return getpeername.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static int getpeername(int __fd, MemorySegment __addr, MemorySegment __len) {
        var mh$ = getpeername.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpeername", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class send {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("send");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static FunctionDescriptor send$descriptor() {
        return send.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static MethodHandle send$handle() {
        return send.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static MemorySegment send$address() {
        return send.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static long send(int __fd, MemorySegment __buf, long __n, int __flags) {
        var mh$ = send.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("send", __fd, __buf, __n, __flags);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("recv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static FunctionDescriptor recv$descriptor() {
        return recv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static MethodHandle recv$handle() {
        return recv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static MemorySegment recv$address() {
        return recv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static long recv(int __fd, MemorySegment __buf, long __n, int __flags) {
        var mh$ = recv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recv", __fd, __buf, __n, __flags);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("sendto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static FunctionDescriptor sendto$descriptor() {
        return sendto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static MethodHandle sendto$handle() {
        return sendto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static MemorySegment sendto$address() {
        return sendto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static long sendto(int __fd, MemorySegment __buf, long __n, int __flags, MemorySegment __addr, int __addr_len) {
        var mh$ = sendto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendto", __fd, __buf, __n, __flags, __addr, __addr_len);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags, __addr, __addr_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvfrom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("recvfrom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static FunctionDescriptor recvfrom$descriptor() {
        return recvfrom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MethodHandle recvfrom$handle() {
        return recvfrom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MemorySegment recvfrom$address() {
        return recvfrom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static long recvfrom(int __fd, MemorySegment __buf, long __n, int __flags, MemorySegment __addr, MemorySegment __addr_len) {
        var mh$ = recvfrom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvfrom", __fd, __buf, __n, __flags, __addr, __addr_len);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags, __addr, __addr_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendmsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("sendmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static FunctionDescriptor sendmsg$descriptor() {
        return sendmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static MethodHandle sendmsg$handle() {
        return sendmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static MemorySegment sendmsg$address() {
        return sendmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static long sendmsg(int __fd, MemorySegment __message, int __flags) {
        var mh$ = sendmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendmsg", __fd, __message, __flags);
            }
            return (long)mh$.invokeExact(__fd, __message, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvmsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("recvmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static FunctionDescriptor recvmsg$descriptor() {
        return recvmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static MethodHandle recvmsg$handle() {
        return recvmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static MemorySegment recvmsg$address() {
        return recvmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static long recvmsg(int __fd, MemorySegment __message, int __flags) {
        var mh$ = recvmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvmsg", __fd, __message, __flags);
            }
            return (long)mh$.invokeExact(__fd, __message, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("getsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static FunctionDescriptor getsockopt$descriptor() {
        return getsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static MethodHandle getsockopt$handle() {
        return getsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static MemorySegment getsockopt$address() {
        return getsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static int getsockopt(int __fd, int __level, int __optname, MemorySegment __optval, MemorySegment __optlen) {
        var mh$ = getsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockopt", __fd, __level, __optname, __optval, __optlen);
            }
            return (int)mh$.invokeExact(__fd, __level, __optname, __optval, __optlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("setsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static FunctionDescriptor setsockopt$descriptor() {
        return setsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static MethodHandle setsockopt$handle() {
        return setsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static MemorySegment setsockopt$address() {
        return setsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static int setsockopt(int __fd, int __level, int __optname, MemorySegment __optval, int __optlen) {
        var mh$ = setsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsockopt", __fd, __level, __optname, __optval, __optlen);
            }
            return (int)mh$.invokeExact(__fd, __level, __optname, __optval, __optlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class listen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("listen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static FunctionDescriptor listen$descriptor() {
        return listen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static MethodHandle listen$handle() {
        return listen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static MemorySegment listen$address() {
        return listen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static int listen(int __fd, int __n) {
        var mh$ = listen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("listen", __fd, __n);
            }
            return (int)mh$.invokeExact(__fd, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class accept {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("accept");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static FunctionDescriptor accept$descriptor() {
        return accept.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MethodHandle accept$handle() {
        return accept.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MemorySegment accept$address() {
        return accept.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static int accept(int __fd, MemorySegment __addr, MemorySegment __addr_len) {
        var mh$ = accept.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("accept", __fd, __addr, __addr_len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __addr_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("shutdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static FunctionDescriptor shutdown$descriptor() {
        return shutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static MethodHandle shutdown$handle() {
        return shutdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static MemorySegment shutdown$address() {
        return shutdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static int shutdown(int __fd, int __how) {
        var mh$ = shutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shutdown", __fd, __how);
            }
            return (int)mh$.invokeExact(__fd, __how);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sockatmark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("sockatmark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static FunctionDescriptor sockatmark$descriptor() {
        return sockatmark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static MethodHandle sockatmark$handle() {
        return sockatmark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static MemorySegment sockatmark$address() {
        return sockatmark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static int sockatmark(int __fd) {
        var mh$ = sockatmark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sockatmark", __fd);
            }
            return (int)mh$.invokeExact(__fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isfdtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("isfdtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static FunctionDescriptor isfdtype$descriptor() {
        return isfdtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static MethodHandle isfdtype$handle() {
        return isfdtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static MemorySegment isfdtype$address() {
        return isfdtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static int isfdtype(int __fd, int __fdtype) {
        var mh$ = isfdtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isfdtype", __fd, __fdtype);
            }
            return (int)mh$.invokeExact(__fd, __fdtype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UCS_LOG_LEVEL_FATAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_LOG_LEVEL_FATAL = 0
     * }
     */
    public static int UCS_LOG_LEVEL_FATAL() {
        return UCS_LOG_LEVEL_FATAL;
    }
    private static final int UCS_LOG_LEVEL_ERROR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_LOG_LEVEL_ERROR = 1
     * }
     */
    public static int UCS_LOG_LEVEL_ERROR() {
        return UCS_LOG_LEVEL_ERROR;
    }
    private static final int UCS_LOG_LEVEL_WARN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_LOG_LEVEL_WARN = 2
     * }
     */
    public static int UCS_LOG_LEVEL_WARN() {
        return UCS_LOG_LEVEL_WARN;
    }
    private static final int UCS_LOG_LEVEL_DIAG = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_LOG_LEVEL_DIAG = 3
     * }
     */
    public static int UCS_LOG_LEVEL_DIAG() {
        return UCS_LOG_LEVEL_DIAG;
    }
    private static final int UCS_LOG_LEVEL_INFO = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_LOG_LEVEL_INFO = 4
     * }
     */
    public static int UCS_LOG_LEVEL_INFO() {
        return UCS_LOG_LEVEL_INFO;
    }
    private static final int UCS_LOG_LEVEL_DEBUG = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_LOG_LEVEL_DEBUG = 5
     * }
     */
    public static int UCS_LOG_LEVEL_DEBUG() {
        return UCS_LOG_LEVEL_DEBUG;
    }
    private static final int UCS_LOG_LEVEL_TRACE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_LOG_LEVEL_TRACE = 6
     * }
     */
    public static int UCS_LOG_LEVEL_TRACE() {
        return UCS_LOG_LEVEL_TRACE;
    }
    private static final int UCS_LOG_LEVEL_TRACE_REQ = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_LOG_LEVEL_TRACE_REQ = 7
     * }
     */
    public static int UCS_LOG_LEVEL_TRACE_REQ() {
        return UCS_LOG_LEVEL_TRACE_REQ;
    }
    private static final int UCS_LOG_LEVEL_TRACE_DATA = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_LOG_LEVEL_TRACE_DATA = 8
     * }
     */
    public static int UCS_LOG_LEVEL_TRACE_DATA() {
        return UCS_LOG_LEVEL_TRACE_DATA;
    }
    private static final int UCS_LOG_LEVEL_TRACE_ASYNC = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_LOG_LEVEL_TRACE_ASYNC = 9
     * }
     */
    public static int UCS_LOG_LEVEL_TRACE_ASYNC() {
        return UCS_LOG_LEVEL_TRACE_ASYNC;
    }
    private static final int UCS_LOG_LEVEL_TRACE_FUNC = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_LOG_LEVEL_TRACE_FUNC = 10
     * }
     */
    public static int UCS_LOG_LEVEL_TRACE_FUNC() {
        return UCS_LOG_LEVEL_TRACE_FUNC;
    }
    private static final int UCS_LOG_LEVEL_TRACE_POLL = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_LOG_LEVEL_TRACE_POLL = 11
     * }
     */
    public static int UCS_LOG_LEVEL_TRACE_POLL() {
        return UCS_LOG_LEVEL_TRACE_POLL;
    }
    private static final int UCS_LOG_LEVEL_LAST = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_LOG_LEVEL_LAST = 12
     * }
     */
    public static int UCS_LOG_LEVEL_LAST() {
        return UCS_LOG_LEVEL_LAST;
    }
    private static final int UCS_LOG_LEVEL_PRINT = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_LOG_LEVEL_PRINT = 13
     * }
     */
    public static int UCS_LOG_LEVEL_PRINT() {
        return UCS_LOG_LEVEL_PRINT;
    }
    private static final int UCS_ASYNC_MODE_SIGNAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ASYNC_MODE_SIGNAL = 0
     * }
     */
    public static int UCS_ASYNC_MODE_SIGNAL() {
        return UCS_ASYNC_MODE_SIGNAL;
    }
    private static final int UCS_ASYNC_MODE_THREAD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ASYNC_MODE_THREAD = 1
     * }
     */
    public static int UCS_ASYNC_MODE_THREAD() {
        return UCS_ASYNC_MODE_THREAD;
    }
    private static final int UCS_ASYNC_MODE_THREAD_SPINLOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ASYNC_MODE_THREAD_SPINLOCK = 1
     * }
     */
    public static int UCS_ASYNC_MODE_THREAD_SPINLOCK() {
        return UCS_ASYNC_MODE_THREAD_SPINLOCK;
    }
    private static final int UCS_ASYNC_MODE_THREAD_MUTEX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ASYNC_MODE_THREAD_MUTEX = 2
     * }
     */
    public static int UCS_ASYNC_MODE_THREAD_MUTEX() {
        return UCS_ASYNC_MODE_THREAD_MUTEX;
    }
    private static final int UCS_ASYNC_MODE_POLL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ASYNC_MODE_POLL = 3
     * }
     */
    public static int UCS_ASYNC_MODE_POLL() {
        return UCS_ASYNC_MODE_POLL;
    }
    private static final int UCS_ASYNC_MODE_LAST = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_ASYNC_MODE_LAST = 4
     * }
     */
    public static int UCS_ASYNC_MODE_LAST() {
        return UCS_ASYNC_MODE_LAST;
    }

    private static class ucs_async_mode_names$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, Ucx.C_POINTER);
        public static final MemorySegment SEGMENT = Ucx.findOrThrow("ucs_async_mode_names").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *ucs_async_mode_names[]
     * }
     */
    public static SequenceLayout ucs_async_mode_names$layout() {
        return ucs_async_mode_names$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char *ucs_async_mode_names[]
     * }
     */
    public static long[] ucs_async_mode_names$dimensions() {
        return ucs_async_mode_names$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *ucs_async_mode_names[]
     * }
     */
    public static MemorySegment ucs_async_mode_names() {
        return ucs_async_mode_names$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *ucs_async_mode_names[]
     * }
     */
    public static void ucs_async_mode_names(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, ucs_async_mode_names$constants.SEGMENT, 0L, ucs_async_mode_names$constants.LAYOUT.byteSize());
    }
    private static final int UCS_NO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ucs_ternary_auto_value.UCS_NO = 0
     * }
     */
    public static int UCS_NO() {
        return UCS_NO;
    }
    private static final int UCS_YES = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucs_ternary_auto_value.UCS_YES = 1
     * }
     */
    public static int UCS_YES() {
        return UCS_YES;
    }
    private static final int UCS_TRY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucs_ternary_auto_value.UCS_TRY = 2
     * }
     */
    public static int UCS_TRY() {
        return UCS_TRY;
    }
    private static final int UCS_AUTO = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ucs_ternary_auto_value.UCS_AUTO = 3
     * }
     */
    public static int UCS_AUTO() {
        return UCS_AUTO;
    }
    private static final int UCS_TERNARY_LAST = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucs_ternary_auto_value.UCS_TERNARY_LAST = 4
     * }
     */
    public static int UCS_TERNARY_LAST() {
        return UCS_TERNARY_LAST;
    }
    private static final int UCS_CONFIG_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ucs_on_off_auto_value.UCS_CONFIG_OFF = 0
     * }
     */
    public static int UCS_CONFIG_OFF() {
        return UCS_CONFIG_OFF;
    }
    private static final int UCS_CONFIG_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucs_on_off_auto_value.UCS_CONFIG_ON = 1
     * }
     */
    public static int UCS_CONFIG_ON() {
        return UCS_CONFIG_ON;
    }
    private static final int UCS_CONFIG_AUTO = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucs_on_off_auto_value.UCS_CONFIG_AUTO = 2
     * }
     */
    public static int UCS_CONFIG_AUTO() {
        return UCS_CONFIG_AUTO;
    }
    private static final int UCS_CONFIG_ON_OFF_LAST = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ucs_on_off_auto_value.UCS_CONFIG_ON_OFF_LAST = 3
     * }
     */
    public static int UCS_CONFIG_ON_OFF_LAST() {
        return UCS_CONFIG_ON_OFF_LAST;
    }
    private static final int UCS_HANDLE_ERROR_BACKTRACE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_HANDLE_ERROR_BACKTRACE = 0
     * }
     */
    public static int UCS_HANDLE_ERROR_BACKTRACE() {
        return UCS_HANDLE_ERROR_BACKTRACE;
    }
    private static final int UCS_HANDLE_ERROR_FREEZE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_HANDLE_ERROR_FREEZE = 1
     * }
     */
    public static int UCS_HANDLE_ERROR_FREEZE() {
        return UCS_HANDLE_ERROR_FREEZE;
    }
    private static final int UCS_HANDLE_ERROR_DEBUG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_HANDLE_ERROR_DEBUG = 2
     * }
     */
    public static int UCS_HANDLE_ERROR_DEBUG() {
        return UCS_HANDLE_ERROR_DEBUG;
    }
    private static final int UCS_HANDLE_ERROR_NONE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_HANDLE_ERROR_NONE = 3
     * }
     */
    public static int UCS_HANDLE_ERROR_NONE() {
        return UCS_HANDLE_ERROR_NONE;
    }
    private static final int UCS_HANDLE_ERROR_LAST = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_HANDLE_ERROR_LAST = 4
     * }
     */
    public static int UCS_HANDLE_ERROR_LAST() {
        return UCS_HANDLE_ERROR_LAST;
    }
    private static final int UCS_CONFIG_PRINT_CONFIG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_CONFIG_PRINT_CONFIG = 1
     * }
     */
    public static int UCS_CONFIG_PRINT_CONFIG() {
        return UCS_CONFIG_PRINT_CONFIG;
    }
    private static final int UCS_CONFIG_PRINT_HEADER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_CONFIG_PRINT_HEADER = 2
     * }
     */
    public static int UCS_CONFIG_PRINT_HEADER() {
        return UCS_CONFIG_PRINT_HEADER;
    }
    private static final int UCS_CONFIG_PRINT_DOC = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_CONFIG_PRINT_DOC = 4
     * }
     */
    public static int UCS_CONFIG_PRINT_DOC() {
        return UCS_CONFIG_PRINT_DOC;
    }
    private static final int UCS_CONFIG_PRINT_HIDDEN = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_CONFIG_PRINT_HIDDEN = 8
     * }
     */
    public static int UCS_CONFIG_PRINT_HIDDEN() {
        return UCS_CONFIG_PRINT_HIDDEN;
    }
    private static final int UCS_CONFIG_PRINT_COMMENT_DEFAULT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_CONFIG_PRINT_COMMENT_DEFAULT = 16
     * }
     */
    public static int UCS_CONFIG_PRINT_COMMENT_DEFAULT() {
        return UCS_CONFIG_PRINT_COMMENT_DEFAULT;
    }
    private static final int UCS_CONFIG_ALLOW_LIST_ALLOW_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_CONFIG_ALLOW_LIST_ALLOW_ALL = 0
     * }
     */
    public static int UCS_CONFIG_ALLOW_LIST_ALLOW_ALL() {
        return UCS_CONFIG_ALLOW_LIST_ALLOW_ALL;
    }
    private static final int UCS_CONFIG_ALLOW_LIST_ALLOW = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_CONFIG_ALLOW_LIST_ALLOW = 1
     * }
     */
    public static int UCS_CONFIG_ALLOW_LIST_ALLOW() {
        return UCS_CONFIG_ALLOW_LIST_ALLOW;
    }
    private static final int UCS_CONFIG_ALLOW_LIST_NEGATE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_CONFIG_ALLOW_LIST_NEGATE = 2
     * }
     */
    public static int UCS_CONFIG_ALLOW_LIST_NEGATE() {
        return UCS_CONFIG_ALLOW_LIST_NEGATE;
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = Ucx.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = Ucx.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = Ucx.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = Ucx.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = Ucx.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = Ucx.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = Ucx.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = Ucx.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = Ucx.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct ucp_context *ucp_context_h
     * }
     */
    public static final AddressLayout ucp_context_h = Ucx.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ucp_ep *ucp_ep_h
     * }
     */
    public static final AddressLayout ucp_ep_h = Ucx.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ucp_conn_request *ucp_conn_request_h
     * }
     */
    public static final AddressLayout ucp_conn_request_h = Ucx.C_POINTER;
    private static final int UCP_ERR_HANDLING_MODE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ERR_HANDLING_MODE_NONE = 0
     * }
     */
    public static int UCP_ERR_HANDLING_MODE_NONE() {
        return UCP_ERR_HANDLING_MODE_NONE;
    }
    private static final int UCP_ERR_HANDLING_MODE_PEER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ERR_HANDLING_MODE_PEER = 1
     * }
     */
    public static int UCP_ERR_HANDLING_MODE_PEER() {
        return UCP_ERR_HANDLING_MODE_PEER;
    }
    private static final int UCP_ERR_HANDLING_MODE_FAILOVER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ERR_HANDLING_MODE_FAILOVER = 2
     * }
     */
    public static int UCP_ERR_HANDLING_MODE_FAILOVER() {
        return UCP_ERR_HANDLING_MODE_FAILOVER;
    }
    /**
     * {@snippet lang=c :
     * typedef struct ucp_rkey *ucp_rkey_h
     * }
     */
    public static final AddressLayout ucp_rkey_h = Ucx.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ucp_mem *ucp_mem_h
     * }
     */
    public static final AddressLayout ucp_mem_h = Ucx.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ucp_listener *ucp_listener_h
     * }
     */
    public static final AddressLayout ucp_listener_h = Ucx.C_POINTER;
    private static final int UCP_MEM_ATTR_FIELD_ADDRESS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_mem_attr_field.UCP_MEM_ATTR_FIELD_ADDRESS = 1
     * }
     */
    public static int UCP_MEM_ATTR_FIELD_ADDRESS() {
        return UCP_MEM_ATTR_FIELD_ADDRESS;
    }
    private static final int UCP_MEM_ATTR_FIELD_LENGTH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_mem_attr_field.UCP_MEM_ATTR_FIELD_LENGTH = 2
     * }
     */
    public static int UCP_MEM_ATTR_FIELD_LENGTH() {
        return UCP_MEM_ATTR_FIELD_LENGTH;
    }
    private static final int UCP_MEM_ATTR_FIELD_MEM_TYPE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_mem_attr_field.UCP_MEM_ATTR_FIELD_MEM_TYPE = 4
     * }
     */
    public static int UCP_MEM_ATTR_FIELD_MEM_TYPE() {
        return UCP_MEM_ATTR_FIELD_MEM_TYPE;
    }
    /**
     * {@snippet lang=c :
     * typedef struct ucp_worker *ucp_worker_h
     * }
     */
    public static final AddressLayout ucp_worker_h = Ucx.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef uint64_t ucp_tag_t
     * }
     */
    public static final OfLong ucp_tag_t = Ucx.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct ucp_recv_desc *ucp_tag_message_h
     * }
     */
    public static final AddressLayout ucp_tag_message_h = Ucx.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef uint64_t ucp_datatype_t
     * }
     */
    public static final OfLong ucp_datatype_t = Ucx.C_LONG;
    private static final int UCP_WAKEUP_RMA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_wakeup_event_types.UCP_WAKEUP_RMA = 1
     * }
     */
    public static int UCP_WAKEUP_RMA() {
        return UCP_WAKEUP_RMA;
    }
    private static final int UCP_WAKEUP_AMO = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_wakeup_event_types.UCP_WAKEUP_AMO = 2
     * }
     */
    public static int UCP_WAKEUP_AMO() {
        return UCP_WAKEUP_AMO;
    }
    private static final int UCP_WAKEUP_TAG_SEND = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_wakeup_event_types.UCP_WAKEUP_TAG_SEND = 4
     * }
     */
    public static int UCP_WAKEUP_TAG_SEND() {
        return UCP_WAKEUP_TAG_SEND;
    }
    private static final int UCP_WAKEUP_TAG_RECV = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucp_wakeup_event_types.UCP_WAKEUP_TAG_RECV = 8
     * }
     */
    public static int UCP_WAKEUP_TAG_RECV() {
        return UCP_WAKEUP_TAG_RECV;
    }
    private static final int UCP_WAKEUP_TX = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum ucp_wakeup_event_types.UCP_WAKEUP_TX = 1024
     * }
     */
    public static int UCP_WAKEUP_TX() {
        return UCP_WAKEUP_TX;
    }
    private static final int UCP_WAKEUP_RX = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum ucp_wakeup_event_types.UCP_WAKEUP_RX = 2048
     * }
     */
    public static int UCP_WAKEUP_RX() {
        return UCP_WAKEUP_RX;
    }
    private static final int UCP_WAKEUP_EDGE = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum ucp_wakeup_event_types.UCP_WAKEUP_EDGE = 65536
     * }
     */
    public static int UCP_WAKEUP_EDGE() {
        return UCP_WAKEUP_EDGE;
    }
    /**
     * {@snippet lang=c :
     * typedef struct ucp_device_mem_list_handle *ucp_device_mem_list_handle_h
     * }
     */
    public static final AddressLayout ucp_device_mem_list_handle_h = Ucx.C_POINTER;

    private static class ucp_request_is_completed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_request_is_completed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ucp_request_is_completed(void *request)
     * }
     */
    public static FunctionDescriptor ucp_request_is_completed$descriptor() {
        return ucp_request_is_completed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ucp_request_is_completed(void *request)
     * }
     */
    public static MethodHandle ucp_request_is_completed$handle() {
        return ucp_request_is_completed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ucp_request_is_completed(void *request)
     * }
     */
    public static MemorySegment ucp_request_is_completed$address() {
        return ucp_request_is_completed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ucp_request_is_completed(void *request)
     * }
     */
    public static int ucp_request_is_completed(MemorySegment request) {
        var mh$ = ucp_request_is_completed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_request_is_completed", request);
            }
            return (int)mh$.invokeExact(request);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_request_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_request_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_request_release(void *request)
     * }
     */
    public static FunctionDescriptor ucp_request_release$descriptor() {
        return ucp_request_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_request_release(void *request)
     * }
     */
    public static MethodHandle ucp_request_release$handle() {
        return ucp_request_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_request_release(void *request)
     * }
     */
    public static MemorySegment ucp_request_release$address() {
        return ucp_request_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_request_release(void *request)
     * }
     */
    public static void ucp_request_release(MemorySegment request) {
        var mh$ = ucp_request_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_request_release", request);
            }
            mh$.invokeExact(request);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_ep_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_ep_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_ep_destroy(ucp_ep_h ep)
     * }
     */
    public static FunctionDescriptor ucp_ep_destroy$descriptor() {
        return ucp_ep_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_ep_destroy(ucp_ep_h ep)
     * }
     */
    public static MethodHandle ucp_ep_destroy$handle() {
        return ucp_ep_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_ep_destroy(ucp_ep_h ep)
     * }
     */
    public static MemorySegment ucp_ep_destroy$address() {
        return ucp_ep_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_ep_destroy(ucp_ep_h ep)
     * }
     */
    public static void ucp_ep_destroy(MemorySegment ep) {
        var mh$ = ucp_ep_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_ep_destroy", ep);
            }
            mh$.invokeExact(ep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_disconnect_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_disconnect_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_disconnect_nb(ucp_ep_h ep)
     * }
     */
    public static FunctionDescriptor ucp_disconnect_nb$descriptor() {
        return ucp_disconnect_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_disconnect_nb(ucp_ep_h ep)
     * }
     */
    public static MethodHandle ucp_disconnect_nb$handle() {
        return ucp_disconnect_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_disconnect_nb(ucp_ep_h ep)
     * }
     */
    public static MemorySegment ucp_disconnect_nb$address() {
        return ucp_disconnect_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_disconnect_nb(ucp_ep_h ep)
     * }
     */
    public static MemorySegment ucp_disconnect_nb(MemorySegment ep) {
        var mh$ = ucp_disconnect_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_disconnect_nb", ep);
            }
            return (MemorySegment)mh$.invokeExact(ep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_request_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_request_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *ucp_request_alloc(ucp_worker_h worker)
     * }
     */
    public static FunctionDescriptor ucp_request_alloc$descriptor() {
        return ucp_request_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *ucp_request_alloc(ucp_worker_h worker)
     * }
     */
    public static MethodHandle ucp_request_alloc$handle() {
        return ucp_request_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *ucp_request_alloc(ucp_worker_h worker)
     * }
     */
    public static MemorySegment ucp_request_alloc$address() {
        return ucp_request_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *ucp_request_alloc(ucp_worker_h worker)
     * }
     */
    public static MemorySegment ucp_request_alloc(MemorySegment worker) {
        var mh$ = ucp_request_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_request_alloc", worker);
            }
            return (MemorySegment)mh$.invokeExact(worker);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_request_test {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_request_test");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_request_test(void *request, ucp_tag_recv_info_t *info)
     * }
     */
    public static FunctionDescriptor ucp_request_test$descriptor() {
        return ucp_request_test.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_request_test(void *request, ucp_tag_recv_info_t *info)
     * }
     */
    public static MethodHandle ucp_request_test$handle() {
        return ucp_request_test.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_request_test(void *request, ucp_tag_recv_info_t *info)
     * }
     */
    public static MemorySegment ucp_request_test$address() {
        return ucp_request_test.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_request_test(void *request, ucp_tag_recv_info_t *info)
     * }
     */
    public static int ucp_request_test(MemorySegment request, MemorySegment info) {
        var mh$ = ucp_request_test.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_request_test", request, info);
            }
            return (int)mh$.invokeExact(request, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_rkey_pack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_rkey_pack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_rkey_pack(ucp_context_h context, ucp_mem_h memh, void **rkey_buffer_p, size_t *size_p)
     * }
     */
    public static FunctionDescriptor ucp_rkey_pack$descriptor() {
        return ucp_rkey_pack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_rkey_pack(ucp_context_h context, ucp_mem_h memh, void **rkey_buffer_p, size_t *size_p)
     * }
     */
    public static MethodHandle ucp_rkey_pack$handle() {
        return ucp_rkey_pack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_rkey_pack(ucp_context_h context, ucp_mem_h memh, void **rkey_buffer_p, size_t *size_p)
     * }
     */
    public static MemorySegment ucp_rkey_pack$address() {
        return ucp_rkey_pack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_rkey_pack(ucp_context_h context, ucp_mem_h memh, void **rkey_buffer_p, size_t *size_p)
     * }
     */
    public static int ucp_rkey_pack(MemorySegment context, MemorySegment memh, MemorySegment rkey_buffer_p, MemorySegment size_p) {
        var mh$ = ucp_rkey_pack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_rkey_pack", context, memh, rkey_buffer_p, size_p);
            }
            return (int)mh$.invokeExact(context, memh, rkey_buffer_p, size_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_rkey_buffer_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_rkey_buffer_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_rkey_buffer_release(void *rkey_buffer)
     * }
     */
    public static FunctionDescriptor ucp_rkey_buffer_release$descriptor() {
        return ucp_rkey_buffer_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_rkey_buffer_release(void *rkey_buffer)
     * }
     */
    public static MethodHandle ucp_rkey_buffer_release$handle() {
        return ucp_rkey_buffer_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_rkey_buffer_release(void *rkey_buffer)
     * }
     */
    public static MemorySegment ucp_rkey_buffer_release$address() {
        return ucp_rkey_buffer_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_rkey_buffer_release(void *rkey_buffer)
     * }
     */
    public static void ucp_rkey_buffer_release(MemorySegment rkey_buffer) {
        var mh$ = ucp_rkey_buffer_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_rkey_buffer_release", rkey_buffer);
            }
            mh$.invokeExact(rkey_buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_ep_flush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_ep_flush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_flush(ucp_ep_h ep)
     * }
     */
    public static FunctionDescriptor ucp_ep_flush$descriptor() {
        return ucp_ep_flush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_flush(ucp_ep_h ep)
     * }
     */
    public static MethodHandle ucp_ep_flush$handle() {
        return ucp_ep_flush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_flush(ucp_ep_h ep)
     * }
     */
    public static MemorySegment ucp_ep_flush$address() {
        return ucp_ep_flush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_flush(ucp_ep_h ep)
     * }
     */
    public static int ucp_ep_flush(MemorySegment ep) {
        var mh$ = ucp_ep_flush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_ep_flush", ep);
            }
            return (int)mh$.invokeExact(ep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_flush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_flush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_flush(ucp_worker_h worker)
     * }
     */
    public static FunctionDescriptor ucp_worker_flush$descriptor() {
        return ucp_worker_flush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_flush(ucp_worker_h worker)
     * }
     */
    public static MethodHandle ucp_worker_flush$handle() {
        return ucp_worker_flush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_flush(ucp_worker_h worker)
     * }
     */
    public static MemorySegment ucp_worker_flush$address() {
        return ucp_worker_flush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_flush(ucp_worker_h worker)
     * }
     */
    public static int ucp_worker_flush(MemorySegment worker) {
        var mh$ = ucp_worker_flush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_flush", worker);
            }
            return (int)mh$.invokeExact(worker);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_put {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_put");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_put(ucp_ep_h ep, const void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static FunctionDescriptor ucp_put$descriptor() {
        return ucp_put.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_put(ucp_ep_h ep, const void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static MethodHandle ucp_put$handle() {
        return ucp_put.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_put(ucp_ep_h ep, const void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static MemorySegment ucp_put$address() {
        return ucp_put.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_put(ucp_ep_h ep, const void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static int ucp_put(MemorySegment ep, MemorySegment buffer, long length, long remote_addr, MemorySegment rkey) {
        var mh$ = ucp_put.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_put", ep, buffer, length, remote_addr, rkey);
            }
            return (int)mh$.invokeExact(ep, buffer, length, remote_addr, rkey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_get(ucp_ep_h ep, void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static FunctionDescriptor ucp_get$descriptor() {
        return ucp_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_get(ucp_ep_h ep, void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static MethodHandle ucp_get$handle() {
        return ucp_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_get(ucp_ep_h ep, void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static MemorySegment ucp_get$address() {
        return ucp_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_get(ucp_ep_h ep, void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static int ucp_get(MemorySegment ep, MemorySegment buffer, long length, long remote_addr, MemorySegment rkey) {
        var mh$ = ucp_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_get", ep, buffer, length, remote_addr, rkey);
            }
            return (int)mh$.invokeExact(ep, buffer, length, remote_addr, rkey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_atomic_add32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_atomic_add32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_add32(ucp_ep_h ep, uint32_t add, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static FunctionDescriptor ucp_atomic_add32$descriptor() {
        return ucp_atomic_add32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_add32(ucp_ep_h ep, uint32_t add, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static MethodHandle ucp_atomic_add32$handle() {
        return ucp_atomic_add32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_add32(ucp_ep_h ep, uint32_t add, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static MemorySegment ucp_atomic_add32$address() {
        return ucp_atomic_add32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_add32(ucp_ep_h ep, uint32_t add, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static int ucp_atomic_add32(MemorySegment ep, int add, long remote_addr, MemorySegment rkey) {
        var mh$ = ucp_atomic_add32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_atomic_add32", ep, add, remote_addr, rkey);
            }
            return (int)mh$.invokeExact(ep, add, remote_addr, rkey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_atomic_add64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_atomic_add64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_add64(ucp_ep_h ep, uint64_t add, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static FunctionDescriptor ucp_atomic_add64$descriptor() {
        return ucp_atomic_add64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_add64(ucp_ep_h ep, uint64_t add, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static MethodHandle ucp_atomic_add64$handle() {
        return ucp_atomic_add64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_add64(ucp_ep_h ep, uint64_t add, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static MemorySegment ucp_atomic_add64$address() {
        return ucp_atomic_add64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_add64(ucp_ep_h ep, uint64_t add, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static int ucp_atomic_add64(MemorySegment ep, long add, long remote_addr, MemorySegment rkey) {
        var mh$ = ucp_atomic_add64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_atomic_add64", ep, add, remote_addr, rkey);
            }
            return (int)mh$.invokeExact(ep, add, remote_addr, rkey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_atomic_fadd32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_atomic_fadd32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_fadd32(ucp_ep_h ep, uint32_t add, uint64_t remote_addr, ucp_rkey_h rkey, uint32_t *result)
     * }
     */
    public static FunctionDescriptor ucp_atomic_fadd32$descriptor() {
        return ucp_atomic_fadd32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_fadd32(ucp_ep_h ep, uint32_t add, uint64_t remote_addr, ucp_rkey_h rkey, uint32_t *result)
     * }
     */
    public static MethodHandle ucp_atomic_fadd32$handle() {
        return ucp_atomic_fadd32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_fadd32(ucp_ep_h ep, uint32_t add, uint64_t remote_addr, ucp_rkey_h rkey, uint32_t *result)
     * }
     */
    public static MemorySegment ucp_atomic_fadd32$address() {
        return ucp_atomic_fadd32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_fadd32(ucp_ep_h ep, uint32_t add, uint64_t remote_addr, ucp_rkey_h rkey, uint32_t *result)
     * }
     */
    public static int ucp_atomic_fadd32(MemorySegment ep, int add, long remote_addr, MemorySegment rkey, MemorySegment result) {
        var mh$ = ucp_atomic_fadd32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_atomic_fadd32", ep, add, remote_addr, rkey, result);
            }
            return (int)mh$.invokeExact(ep, add, remote_addr, rkey, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_atomic_fadd64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_atomic_fadd64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_fadd64(ucp_ep_h ep, uint64_t add, uint64_t remote_addr, ucp_rkey_h rkey, uint64_t *result)
     * }
     */
    public static FunctionDescriptor ucp_atomic_fadd64$descriptor() {
        return ucp_atomic_fadd64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_fadd64(ucp_ep_h ep, uint64_t add, uint64_t remote_addr, ucp_rkey_h rkey, uint64_t *result)
     * }
     */
    public static MethodHandle ucp_atomic_fadd64$handle() {
        return ucp_atomic_fadd64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_fadd64(ucp_ep_h ep, uint64_t add, uint64_t remote_addr, ucp_rkey_h rkey, uint64_t *result)
     * }
     */
    public static MemorySegment ucp_atomic_fadd64$address() {
        return ucp_atomic_fadd64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_fadd64(ucp_ep_h ep, uint64_t add, uint64_t remote_addr, ucp_rkey_h rkey, uint64_t *result)
     * }
     */
    public static int ucp_atomic_fadd64(MemorySegment ep, long add, long remote_addr, MemorySegment rkey, MemorySegment result) {
        var mh$ = ucp_atomic_fadd64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_atomic_fadd64", ep, add, remote_addr, rkey, result);
            }
            return (int)mh$.invokeExact(ep, add, remote_addr, rkey, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_atomic_swap32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_atomic_swap32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_swap32(ucp_ep_h ep, uint32_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint32_t *result)
     * }
     */
    public static FunctionDescriptor ucp_atomic_swap32$descriptor() {
        return ucp_atomic_swap32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_swap32(ucp_ep_h ep, uint32_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint32_t *result)
     * }
     */
    public static MethodHandle ucp_atomic_swap32$handle() {
        return ucp_atomic_swap32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_swap32(ucp_ep_h ep, uint32_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint32_t *result)
     * }
     */
    public static MemorySegment ucp_atomic_swap32$address() {
        return ucp_atomic_swap32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_swap32(ucp_ep_h ep, uint32_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint32_t *result)
     * }
     */
    public static int ucp_atomic_swap32(MemorySegment ep, int swap, long remote_addr, MemorySegment rkey, MemorySegment result) {
        var mh$ = ucp_atomic_swap32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_atomic_swap32", ep, swap, remote_addr, rkey, result);
            }
            return (int)mh$.invokeExact(ep, swap, remote_addr, rkey, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_atomic_swap64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_atomic_swap64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_swap64(ucp_ep_h ep, uint64_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint64_t *result)
     * }
     */
    public static FunctionDescriptor ucp_atomic_swap64$descriptor() {
        return ucp_atomic_swap64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_swap64(ucp_ep_h ep, uint64_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint64_t *result)
     * }
     */
    public static MethodHandle ucp_atomic_swap64$handle() {
        return ucp_atomic_swap64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_swap64(ucp_ep_h ep, uint64_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint64_t *result)
     * }
     */
    public static MemorySegment ucp_atomic_swap64$address() {
        return ucp_atomic_swap64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_swap64(ucp_ep_h ep, uint64_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint64_t *result)
     * }
     */
    public static int ucp_atomic_swap64(MemorySegment ep, long swap, long remote_addr, MemorySegment rkey, MemorySegment result) {
        var mh$ = ucp_atomic_swap64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_atomic_swap64", ep, swap, remote_addr, rkey, result);
            }
            return (int)mh$.invokeExact(ep, swap, remote_addr, rkey, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_atomic_cswap32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_atomic_cswap32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_cswap32(ucp_ep_h ep, uint32_t compare, uint32_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint32_t *result)
     * }
     */
    public static FunctionDescriptor ucp_atomic_cswap32$descriptor() {
        return ucp_atomic_cswap32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_cswap32(ucp_ep_h ep, uint32_t compare, uint32_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint32_t *result)
     * }
     */
    public static MethodHandle ucp_atomic_cswap32$handle() {
        return ucp_atomic_cswap32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_cswap32(ucp_ep_h ep, uint32_t compare, uint32_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint32_t *result)
     * }
     */
    public static MemorySegment ucp_atomic_cswap32$address() {
        return ucp_atomic_cswap32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_cswap32(ucp_ep_h ep, uint32_t compare, uint32_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint32_t *result)
     * }
     */
    public static int ucp_atomic_cswap32(MemorySegment ep, int compare, int swap, long remote_addr, MemorySegment rkey, MemorySegment result) {
        var mh$ = ucp_atomic_cswap32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_atomic_cswap32", ep, compare, swap, remote_addr, rkey, result);
            }
            return (int)mh$.invokeExact(ep, compare, swap, remote_addr, rkey, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_atomic_cswap64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_atomic_cswap64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_cswap64(ucp_ep_h ep, uint64_t compare, uint64_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint64_t *result)
     * }
     */
    public static FunctionDescriptor ucp_atomic_cswap64$descriptor() {
        return ucp_atomic_cswap64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_cswap64(ucp_ep_h ep, uint64_t compare, uint64_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint64_t *result)
     * }
     */
    public static MethodHandle ucp_atomic_cswap64$handle() {
        return ucp_atomic_cswap64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_cswap64(ucp_ep_h ep, uint64_t compare, uint64_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint64_t *result)
     * }
     */
    public static MemorySegment ucp_atomic_cswap64$address() {
        return ucp_atomic_cswap64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_cswap64(ucp_ep_h ep, uint64_t compare, uint64_t swap, uint64_t remote_addr, ucp_rkey_h rkey, uint64_t *result)
     * }
     */
    public static int ucp_atomic_cswap64(MemorySegment ep, long compare, long swap, long remote_addr, MemorySegment rkey, MemorySegment result) {
        var mh$ = ucp_atomic_cswap64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_atomic_cswap64", ep, compare, swap, remote_addr, rkey, result);
            }
            return (int)mh$.invokeExact(ep, compare, swap, remote_addr, rkey, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_ep_modify_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_ep_modify_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_modify_nb(ucp_ep_h ep, const ucp_ep_params_t *params)
     * }
     */
    public static FunctionDescriptor ucp_ep_modify_nb$descriptor() {
        return ucp_ep_modify_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_modify_nb(ucp_ep_h ep, const ucp_ep_params_t *params)
     * }
     */
    public static MethodHandle ucp_ep_modify_nb$handle() {
        return ucp_ep_modify_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_modify_nb(ucp_ep_h ep, const ucp_ep_params_t *params)
     * }
     */
    public static MemorySegment ucp_ep_modify_nb$address() {
        return ucp_ep_modify_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_modify_nb(ucp_ep_h ep, const ucp_ep_params_t *params)
     * }
     */
    public static MemorySegment ucp_ep_modify_nb(MemorySegment ep, MemorySegment params) {
        var mh$ = ucp_ep_modify_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_ep_modify_nb", ep, params);
            }
            return (MemorySegment)mh$.invokeExact(ep, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_get_address {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_get_address");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_get_address(ucp_worker_h worker, ucp_address_t **address_p, size_t *address_length_p)
     * }
     */
    public static FunctionDescriptor ucp_worker_get_address$descriptor() {
        return ucp_worker_get_address.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_get_address(ucp_worker_h worker, ucp_address_t **address_p, size_t *address_length_p)
     * }
     */
    public static MethodHandle ucp_worker_get_address$handle() {
        return ucp_worker_get_address.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_get_address(ucp_worker_h worker, ucp_address_t **address_p, size_t *address_length_p)
     * }
     */
    public static MemorySegment ucp_worker_get_address$address() {
        return ucp_worker_get_address.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_get_address(ucp_worker_h worker, ucp_address_t **address_p, size_t *address_length_p)
     * }
     */
    public static int ucp_worker_get_address(MemorySegment worker, MemorySegment address_p, MemorySegment address_length_p) {
        var mh$ = ucp_worker_get_address.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_get_address", worker, address_p, address_length_p);
            }
            return (int)mh$.invokeExact(worker, address_p, address_length_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_ep_close_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_ep_close_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_close_nb(ucp_ep_h ep, unsigned int mode)
     * }
     */
    public static FunctionDescriptor ucp_ep_close_nb$descriptor() {
        return ucp_ep_close_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_close_nb(ucp_ep_h ep, unsigned int mode)
     * }
     */
    public static MethodHandle ucp_ep_close_nb$handle() {
        return ucp_ep_close_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_close_nb(ucp_ep_h ep, unsigned int mode)
     * }
     */
    public static MemorySegment ucp_ep_close_nb$address() {
        return ucp_ep_close_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_close_nb(ucp_ep_h ep, unsigned int mode)
     * }
     */
    public static MemorySegment ucp_ep_close_nb(MemorySegment ep, int mode) {
        var mh$ = ucp_ep_close_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_ep_close_nb", ep, mode);
            }
            return (MemorySegment)mh$.invokeExact(ep, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_ep_flush_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_ep_flush_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_flush_nb(ucp_ep_h ep, unsigned int flags, ucp_send_callback_t cb)
     * }
     */
    public static FunctionDescriptor ucp_ep_flush_nb$descriptor() {
        return ucp_ep_flush_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_flush_nb(ucp_ep_h ep, unsigned int flags, ucp_send_callback_t cb)
     * }
     */
    public static MethodHandle ucp_ep_flush_nb$handle() {
        return ucp_ep_flush_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_flush_nb(ucp_ep_h ep, unsigned int flags, ucp_send_callback_t cb)
     * }
     */
    public static MemorySegment ucp_ep_flush_nb$address() {
        return ucp_ep_flush_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_flush_nb(ucp_ep_h ep, unsigned int flags, ucp_send_callback_t cb)
     * }
     */
    public static MemorySegment ucp_ep_flush_nb(MemorySegment ep, int flags, MemorySegment cb) {
        var mh$ = ucp_ep_flush_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_ep_flush_nb", ep, flags, cb);
            }
            return (MemorySegment)mh$.invokeExact(ep, flags, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_set_am_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_SHORT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_set_am_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_set_am_handler(ucp_worker_h worker, uint16_t id, ucp_am_callback_t cb, void *arg, uint32_t flags)
     * }
     */
    public static FunctionDescriptor ucp_worker_set_am_handler$descriptor() {
        return ucp_worker_set_am_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_set_am_handler(ucp_worker_h worker, uint16_t id, ucp_am_callback_t cb, void *arg, uint32_t flags)
     * }
     */
    public static MethodHandle ucp_worker_set_am_handler$handle() {
        return ucp_worker_set_am_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_set_am_handler(ucp_worker_h worker, uint16_t id, ucp_am_callback_t cb, void *arg, uint32_t flags)
     * }
     */
    public static MemorySegment ucp_worker_set_am_handler$address() {
        return ucp_worker_set_am_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_set_am_handler(ucp_worker_h worker, uint16_t id, ucp_am_callback_t cb, void *arg, uint32_t flags)
     * }
     */
    public static int ucp_worker_set_am_handler(MemorySegment worker, short id, MemorySegment cb, MemorySegment arg, int flags) {
        var mh$ = ucp_worker_set_am_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_set_am_handler", worker, id, cb, arg, flags);
            }
            return (int)mh$.invokeExact(worker, id, cb, arg, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_am_send_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_SHORT,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_am_send_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_am_send_nb(ucp_ep_h ep, uint16_t id, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_send_callback_t cb, unsigned int flags)
     * }
     */
    public static FunctionDescriptor ucp_am_send_nb$descriptor() {
        return ucp_am_send_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_am_send_nb(ucp_ep_h ep, uint16_t id, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_send_callback_t cb, unsigned int flags)
     * }
     */
    public static MethodHandle ucp_am_send_nb$handle() {
        return ucp_am_send_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_am_send_nb(ucp_ep_h ep, uint16_t id, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_send_callback_t cb, unsigned int flags)
     * }
     */
    public static MemorySegment ucp_am_send_nb$address() {
        return ucp_am_send_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_am_send_nb(ucp_ep_h ep, uint16_t id, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_send_callback_t cb, unsigned int flags)
     * }
     */
    public static MemorySegment ucp_am_send_nb(MemorySegment ep, short id, MemorySegment buffer, long count, long datatype, MemorySegment cb, int flags) {
        var mh$ = ucp_am_send_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_am_send_nb", ep, id, buffer, count, datatype, cb, flags);
            }
            return (MemorySegment)mh$.invokeExact(ep, id, buffer, count, datatype, cb, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_stream_send_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_stream_send_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_send_nb(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_send_callback_t cb, unsigned int flags)
     * }
     */
    public static FunctionDescriptor ucp_stream_send_nb$descriptor() {
        return ucp_stream_send_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_send_nb(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_send_callback_t cb, unsigned int flags)
     * }
     */
    public static MethodHandle ucp_stream_send_nb$handle() {
        return ucp_stream_send_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_send_nb(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_send_callback_t cb, unsigned int flags)
     * }
     */
    public static MemorySegment ucp_stream_send_nb$address() {
        return ucp_stream_send_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_send_nb(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_send_callback_t cb, unsigned int flags)
     * }
     */
    public static MemorySegment ucp_stream_send_nb(MemorySegment ep, MemorySegment buffer, long count, long datatype, MemorySegment cb, int flags) {
        var mh$ = ucp_stream_send_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_stream_send_nb", ep, buffer, count, datatype, cb, flags);
            }
            return (MemorySegment)mh$.invokeExact(ep, buffer, count, datatype, cb, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_stream_recv_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_stream_recv_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_recv_nb(ucp_ep_h ep, void *buffer, size_t count, ucp_datatype_t datatype, ucp_stream_recv_callback_t cb, size_t *length, unsigned int flags)
     * }
     */
    public static FunctionDescriptor ucp_stream_recv_nb$descriptor() {
        return ucp_stream_recv_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_recv_nb(ucp_ep_h ep, void *buffer, size_t count, ucp_datatype_t datatype, ucp_stream_recv_callback_t cb, size_t *length, unsigned int flags)
     * }
     */
    public static MethodHandle ucp_stream_recv_nb$handle() {
        return ucp_stream_recv_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_recv_nb(ucp_ep_h ep, void *buffer, size_t count, ucp_datatype_t datatype, ucp_stream_recv_callback_t cb, size_t *length, unsigned int flags)
     * }
     */
    public static MemorySegment ucp_stream_recv_nb$address() {
        return ucp_stream_recv_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_recv_nb(ucp_ep_h ep, void *buffer, size_t count, ucp_datatype_t datatype, ucp_stream_recv_callback_t cb, size_t *length, unsigned int flags)
     * }
     */
    public static MemorySegment ucp_stream_recv_nb(MemorySegment ep, MemorySegment buffer, long count, long datatype, MemorySegment cb, MemorySegment length, int flags) {
        var mh$ = ucp_stream_recv_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_stream_recv_nb", ep, buffer, count, datatype, cb, length, flags);
            }
            return (MemorySegment)mh$.invokeExact(ep, buffer, count, datatype, cb, length, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_tag_send_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_tag_send_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_nb(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_send_callback_t cb)
     * }
     */
    public static FunctionDescriptor ucp_tag_send_nb$descriptor() {
        return ucp_tag_send_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_nb(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_send_callback_t cb)
     * }
     */
    public static MethodHandle ucp_tag_send_nb$handle() {
        return ucp_tag_send_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_nb(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_send_callback_t cb)
     * }
     */
    public static MemorySegment ucp_tag_send_nb$address() {
        return ucp_tag_send_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_nb(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_send_callback_t cb)
     * }
     */
    public static MemorySegment ucp_tag_send_nb(MemorySegment ep, MemorySegment buffer, long count, long datatype, long tag, MemorySegment cb) {
        var mh$ = ucp_tag_send_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_tag_send_nb", ep, buffer, count, datatype, tag, cb);
            }
            return (MemorySegment)mh$.invokeExact(ep, buffer, count, datatype, tag, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_tag_send_nbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_tag_send_nbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_tag_send_nbr(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, void *req)
     * }
     */
    public static FunctionDescriptor ucp_tag_send_nbr$descriptor() {
        return ucp_tag_send_nbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_tag_send_nbr(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, void *req)
     * }
     */
    public static MethodHandle ucp_tag_send_nbr$handle() {
        return ucp_tag_send_nbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_tag_send_nbr(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, void *req)
     * }
     */
    public static MemorySegment ucp_tag_send_nbr$address() {
        return ucp_tag_send_nbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_tag_send_nbr(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, void *req)
     * }
     */
    public static int ucp_tag_send_nbr(MemorySegment ep, MemorySegment buffer, long count, long datatype, long tag, MemorySegment req) {
        var mh$ = ucp_tag_send_nbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_tag_send_nbr", ep, buffer, count, datatype, tag, req);
            }
            return (int)mh$.invokeExact(ep, buffer, count, datatype, tag, req);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_tag_send_sync_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_tag_send_sync_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_sync_nb(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_send_callback_t cb)
     * }
     */
    public static FunctionDescriptor ucp_tag_send_sync_nb$descriptor() {
        return ucp_tag_send_sync_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_sync_nb(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_send_callback_t cb)
     * }
     */
    public static MethodHandle ucp_tag_send_sync_nb$handle() {
        return ucp_tag_send_sync_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_sync_nb(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_send_callback_t cb)
     * }
     */
    public static MemorySegment ucp_tag_send_sync_nb$address() {
        return ucp_tag_send_sync_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_sync_nb(ucp_ep_h ep, const void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_send_callback_t cb)
     * }
     */
    public static MemorySegment ucp_tag_send_sync_nb(MemorySegment ep, MemorySegment buffer, long count, long datatype, long tag, MemorySegment cb) {
        var mh$ = ucp_tag_send_sync_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_tag_send_sync_nb", ep, buffer, count, datatype, tag, cb);
            }
            return (MemorySegment)mh$.invokeExact(ep, buffer, count, datatype, tag, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_tag_recv_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_tag_recv_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_recv_nb(ucp_worker_h worker, void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_tag_t tag_mask, ucp_tag_recv_callback_t cb)
     * }
     */
    public static FunctionDescriptor ucp_tag_recv_nb$descriptor() {
        return ucp_tag_recv_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_recv_nb(ucp_worker_h worker, void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_tag_t tag_mask, ucp_tag_recv_callback_t cb)
     * }
     */
    public static MethodHandle ucp_tag_recv_nb$handle() {
        return ucp_tag_recv_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_recv_nb(ucp_worker_h worker, void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_tag_t tag_mask, ucp_tag_recv_callback_t cb)
     * }
     */
    public static MemorySegment ucp_tag_recv_nb$address() {
        return ucp_tag_recv_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_recv_nb(ucp_worker_h worker, void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_tag_t tag_mask, ucp_tag_recv_callback_t cb)
     * }
     */
    public static MemorySegment ucp_tag_recv_nb(MemorySegment worker, MemorySegment buffer, long count, long datatype, long tag, long tag_mask, MemorySegment cb) {
        var mh$ = ucp_tag_recv_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_tag_recv_nb", worker, buffer, count, datatype, tag, tag_mask, cb);
            }
            return (MemorySegment)mh$.invokeExact(worker, buffer, count, datatype, tag, tag_mask, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_tag_recv_nbr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_tag_recv_nbr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_tag_recv_nbr(ucp_worker_h worker, void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_tag_t tag_mask, void *req)
     * }
     */
    public static FunctionDescriptor ucp_tag_recv_nbr$descriptor() {
        return ucp_tag_recv_nbr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_tag_recv_nbr(ucp_worker_h worker, void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_tag_t tag_mask, void *req)
     * }
     */
    public static MethodHandle ucp_tag_recv_nbr$handle() {
        return ucp_tag_recv_nbr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_tag_recv_nbr(ucp_worker_h worker, void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_tag_t tag_mask, void *req)
     * }
     */
    public static MemorySegment ucp_tag_recv_nbr$address() {
        return ucp_tag_recv_nbr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_tag_recv_nbr(ucp_worker_h worker, void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_t tag, ucp_tag_t tag_mask, void *req)
     * }
     */
    public static int ucp_tag_recv_nbr(MemorySegment worker, MemorySegment buffer, long count, long datatype, long tag, long tag_mask, MemorySegment req) {
        var mh$ = ucp_tag_recv_nbr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_tag_recv_nbr", worker, buffer, count, datatype, tag, tag_mask, req);
            }
            return (int)mh$.invokeExact(worker, buffer, count, datatype, tag, tag_mask, req);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_tag_msg_recv_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_tag_msg_recv_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_msg_recv_nb(ucp_worker_h worker, void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_message_h message, ucp_tag_recv_callback_t cb)
     * }
     */
    public static FunctionDescriptor ucp_tag_msg_recv_nb$descriptor() {
        return ucp_tag_msg_recv_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_msg_recv_nb(ucp_worker_h worker, void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_message_h message, ucp_tag_recv_callback_t cb)
     * }
     */
    public static MethodHandle ucp_tag_msg_recv_nb$handle() {
        return ucp_tag_msg_recv_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_msg_recv_nb(ucp_worker_h worker, void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_message_h message, ucp_tag_recv_callback_t cb)
     * }
     */
    public static MemorySegment ucp_tag_msg_recv_nb$address() {
        return ucp_tag_msg_recv_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_msg_recv_nb(ucp_worker_h worker, void *buffer, size_t count, ucp_datatype_t datatype, ucp_tag_message_h message, ucp_tag_recv_callback_t cb)
     * }
     */
    public static MemorySegment ucp_tag_msg_recv_nb(MemorySegment worker, MemorySegment buffer, long count, long datatype, MemorySegment message, MemorySegment cb) {
        var mh$ = ucp_tag_msg_recv_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_tag_msg_recv_nb", worker, buffer, count, datatype, message, cb);
            }
            return (MemorySegment)mh$.invokeExact(worker, buffer, count, datatype, message, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_put_nbi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_put_nbi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_put_nbi(ucp_ep_h ep, const void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static FunctionDescriptor ucp_put_nbi$descriptor() {
        return ucp_put_nbi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_put_nbi(ucp_ep_h ep, const void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static MethodHandle ucp_put_nbi$handle() {
        return ucp_put_nbi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_put_nbi(ucp_ep_h ep, const void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static MemorySegment ucp_put_nbi$address() {
        return ucp_put_nbi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_put_nbi(ucp_ep_h ep, const void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static int ucp_put_nbi(MemorySegment ep, MemorySegment buffer, long length, long remote_addr, MemorySegment rkey) {
        var mh$ = ucp_put_nbi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_put_nbi", ep, buffer, length, remote_addr, rkey);
            }
            return (int)mh$.invokeExact(ep, buffer, length, remote_addr, rkey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_put_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_put_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_put_nb(ucp_ep_h ep, const void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey, ucp_send_callback_t cb)
     * }
     */
    public static FunctionDescriptor ucp_put_nb$descriptor() {
        return ucp_put_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_put_nb(ucp_ep_h ep, const void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey, ucp_send_callback_t cb)
     * }
     */
    public static MethodHandle ucp_put_nb$handle() {
        return ucp_put_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_put_nb(ucp_ep_h ep, const void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey, ucp_send_callback_t cb)
     * }
     */
    public static MemorySegment ucp_put_nb$address() {
        return ucp_put_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_put_nb(ucp_ep_h ep, const void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey, ucp_send_callback_t cb)
     * }
     */
    public static MemorySegment ucp_put_nb(MemorySegment ep, MemorySegment buffer, long length, long remote_addr, MemorySegment rkey, MemorySegment cb) {
        var mh$ = ucp_put_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_put_nb", ep, buffer, length, remote_addr, rkey, cb);
            }
            return (MemorySegment)mh$.invokeExact(ep, buffer, length, remote_addr, rkey, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_get_nbi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_get_nbi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_get_nbi(ucp_ep_h ep, void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static FunctionDescriptor ucp_get_nbi$descriptor() {
        return ucp_get_nbi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_get_nbi(ucp_ep_h ep, void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static MethodHandle ucp_get_nbi$handle() {
        return ucp_get_nbi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_get_nbi(ucp_ep_h ep, void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static MemorySegment ucp_get_nbi$address() {
        return ucp_get_nbi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_get_nbi(ucp_ep_h ep, void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static int ucp_get_nbi(MemorySegment ep, MemorySegment buffer, long length, long remote_addr, MemorySegment rkey) {
        var mh$ = ucp_get_nbi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_get_nbi", ep, buffer, length, remote_addr, rkey);
            }
            return (int)mh$.invokeExact(ep, buffer, length, remote_addr, rkey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_get_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_get_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_get_nb(ucp_ep_h ep, void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey, ucp_send_callback_t cb)
     * }
     */
    public static FunctionDescriptor ucp_get_nb$descriptor() {
        return ucp_get_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_get_nb(ucp_ep_h ep, void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey, ucp_send_callback_t cb)
     * }
     */
    public static MethodHandle ucp_get_nb$handle() {
        return ucp_get_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_get_nb(ucp_ep_h ep, void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey, ucp_send_callback_t cb)
     * }
     */
    public static MemorySegment ucp_get_nb$address() {
        return ucp_get_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_get_nb(ucp_ep_h ep, void *buffer, size_t length, uint64_t remote_addr, ucp_rkey_h rkey, ucp_send_callback_t cb)
     * }
     */
    public static MemorySegment ucp_get_nb(MemorySegment ep, MemorySegment buffer, long length, long remote_addr, MemorySegment rkey, MemorySegment cb) {
        var mh$ = ucp_get_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_get_nb", ep, buffer, length, remote_addr, rkey, cb);
            }
            return (MemorySegment)mh$.invokeExact(ep, buffer, length, remote_addr, rkey, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UCP_ATOMIC_POST_OP_ADD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_POST_OP_ADD = 0
     * }
     */
    public static int UCP_ATOMIC_POST_OP_ADD() {
        return UCP_ATOMIC_POST_OP_ADD;
    }
    private static final int UCP_ATOMIC_POST_OP_AND = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_POST_OP_AND = 1
     * }
     */
    public static int UCP_ATOMIC_POST_OP_AND() {
        return UCP_ATOMIC_POST_OP_AND;
    }
    private static final int UCP_ATOMIC_POST_OP_OR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_POST_OP_OR = 2
     * }
     */
    public static int UCP_ATOMIC_POST_OP_OR() {
        return UCP_ATOMIC_POST_OP_OR;
    }
    private static final int UCP_ATOMIC_POST_OP_XOR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_POST_OP_XOR = 3
     * }
     */
    public static int UCP_ATOMIC_POST_OP_XOR() {
        return UCP_ATOMIC_POST_OP_XOR;
    }
    private static final int UCP_ATOMIC_POST_OP_LAST = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_POST_OP_LAST = 4
     * }
     */
    public static int UCP_ATOMIC_POST_OP_LAST() {
        return UCP_ATOMIC_POST_OP_LAST;
    }

    private static class ucp_atomic_post {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_atomic_post");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_post(ucp_ep_h ep, ucp_atomic_post_op_t opcode, uint64_t value, size_t op_size, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static FunctionDescriptor ucp_atomic_post$descriptor() {
        return ucp_atomic_post.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_post(ucp_ep_h ep, ucp_atomic_post_op_t opcode, uint64_t value, size_t op_size, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static MethodHandle ucp_atomic_post$handle() {
        return ucp_atomic_post.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_post(ucp_ep_h ep, ucp_atomic_post_op_t opcode, uint64_t value, size_t op_size, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static MemorySegment ucp_atomic_post$address() {
        return ucp_atomic_post.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_atomic_post(ucp_ep_h ep, ucp_atomic_post_op_t opcode, uint64_t value, size_t op_size, uint64_t remote_addr, ucp_rkey_h rkey)
     * }
     */
    public static int ucp_atomic_post(MemorySegment ep, int opcode, long value, long op_size, long remote_addr, MemorySegment rkey) {
        var mh$ = ucp_atomic_post.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_atomic_post", ep, opcode, value, op_size, remote_addr, rkey);
            }
            return (int)mh$.invokeExact(ep, opcode, value, op_size, remote_addr, rkey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UCP_ATOMIC_FETCH_OP_FADD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_FETCH_OP_FADD = 0
     * }
     */
    public static int UCP_ATOMIC_FETCH_OP_FADD() {
        return UCP_ATOMIC_FETCH_OP_FADD;
    }
    private static final int UCP_ATOMIC_FETCH_OP_SWAP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_FETCH_OP_SWAP = 1
     * }
     */
    public static int UCP_ATOMIC_FETCH_OP_SWAP() {
        return UCP_ATOMIC_FETCH_OP_SWAP;
    }
    private static final int UCP_ATOMIC_FETCH_OP_CSWAP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_FETCH_OP_CSWAP = 2
     * }
     */
    public static int UCP_ATOMIC_FETCH_OP_CSWAP() {
        return UCP_ATOMIC_FETCH_OP_CSWAP;
    }
    private static final int UCP_ATOMIC_FETCH_OP_FAND = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_FETCH_OP_FAND = 3
     * }
     */
    public static int UCP_ATOMIC_FETCH_OP_FAND() {
        return UCP_ATOMIC_FETCH_OP_FAND;
    }
    private static final int UCP_ATOMIC_FETCH_OP_FOR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_FETCH_OP_FOR = 4
     * }
     */
    public static int UCP_ATOMIC_FETCH_OP_FOR() {
        return UCP_ATOMIC_FETCH_OP_FOR;
    }
    private static final int UCP_ATOMIC_FETCH_OP_FXOR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_FETCH_OP_FXOR = 5
     * }
     */
    public static int UCP_ATOMIC_FETCH_OP_FXOR() {
        return UCP_ATOMIC_FETCH_OP_FXOR;
    }
    private static final int UCP_ATOMIC_FETCH_OP_LAST = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_FETCH_OP_LAST = 6
     * }
     */
    public static int UCP_ATOMIC_FETCH_OP_LAST() {
        return UCP_ATOMIC_FETCH_OP_LAST;
    }

    private static class ucp_atomic_fetch_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_atomic_fetch_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_atomic_fetch_nb(ucp_ep_h ep, ucp_atomic_fetch_op_t opcode, uint64_t value, void *result, size_t op_size, uint64_t remote_addr, ucp_rkey_h rkey, ucp_send_callback_t cb)
     * }
     */
    public static FunctionDescriptor ucp_atomic_fetch_nb$descriptor() {
        return ucp_atomic_fetch_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_atomic_fetch_nb(ucp_ep_h ep, ucp_atomic_fetch_op_t opcode, uint64_t value, void *result, size_t op_size, uint64_t remote_addr, ucp_rkey_h rkey, ucp_send_callback_t cb)
     * }
     */
    public static MethodHandle ucp_atomic_fetch_nb$handle() {
        return ucp_atomic_fetch_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_atomic_fetch_nb(ucp_ep_h ep, ucp_atomic_fetch_op_t opcode, uint64_t value, void *result, size_t op_size, uint64_t remote_addr, ucp_rkey_h rkey, ucp_send_callback_t cb)
     * }
     */
    public static MemorySegment ucp_atomic_fetch_nb$address() {
        return ucp_atomic_fetch_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_atomic_fetch_nb(ucp_ep_h ep, ucp_atomic_fetch_op_t opcode, uint64_t value, void *result, size_t op_size, uint64_t remote_addr, ucp_rkey_h rkey, ucp_send_callback_t cb)
     * }
     */
    public static MemorySegment ucp_atomic_fetch_nb(MemorySegment ep, int opcode, long value, MemorySegment result, long op_size, long remote_addr, MemorySegment rkey, MemorySegment cb) {
        var mh$ = ucp_atomic_fetch_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_atomic_fetch_nb", ep, opcode, value, result, op_size, remote_addr, rkey, cb);
            }
            return (MemorySegment)mh$.invokeExact(ep, opcode, value, result, op_size, remote_addr, rkey, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_flush_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_flush_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_worker_flush_nb(ucp_worker_h worker, unsigned int flags, ucp_send_callback_t cb)
     * }
     */
    public static FunctionDescriptor ucp_worker_flush_nb$descriptor() {
        return ucp_worker_flush_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_worker_flush_nb(ucp_worker_h worker, unsigned int flags, ucp_send_callback_t cb)
     * }
     */
    public static MethodHandle ucp_worker_flush_nb$handle() {
        return ucp_worker_flush_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_worker_flush_nb(ucp_worker_h worker, unsigned int flags, ucp_send_callback_t cb)
     * }
     */
    public static MemorySegment ucp_worker_flush_nb$address() {
        return ucp_worker_flush_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_worker_flush_nb(ucp_worker_h worker, unsigned int flags, ucp_send_callback_t cb)
     * }
     */
    public static MemorySegment ucp_worker_flush_nb(MemorySegment worker, int flags, MemorySegment cb) {
        var mh$ = ucp_worker_flush_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_flush_nb", worker, flags, cb);
            }
            return (MemorySegment)mh$.invokeExact(worker, flags, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UCP_EP_CLOSE_MODE_FORCE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_close_mode.UCP_EP_CLOSE_MODE_FORCE = 0
     * }
     */
    public static int UCP_EP_CLOSE_MODE_FORCE() {
        return UCP_EP_CLOSE_MODE_FORCE;
    }
    private static final int UCP_EP_CLOSE_MODE_FLUSH = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_close_mode.UCP_EP_CLOSE_MODE_FLUSH = 1
     * }
     */
    public static int UCP_EP_CLOSE_MODE_FLUSH() {
        return UCP_EP_CLOSE_MODE_FLUSH;
    }
    private static final int UCS_THREAD_MODE_SINGLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_THREAD_MODE_SINGLE = 0
     * }
     */
    public static int UCS_THREAD_MODE_SINGLE() {
        return UCS_THREAD_MODE_SINGLE;
    }
    private static final int UCS_THREAD_MODE_SERIALIZED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_THREAD_MODE_SERIALIZED = 1
     * }
     */
    public static int UCS_THREAD_MODE_SERIALIZED() {
        return UCS_THREAD_MODE_SERIALIZED;
    }
    private static final int UCS_THREAD_MODE_MULTI = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_THREAD_MODE_MULTI = 2
     * }
     */
    public static int UCS_THREAD_MODE_MULTI() {
        return UCS_THREAD_MODE_MULTI;
    }
    private static final int UCS_THREAD_MODE_LAST = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCS_THREAD_MODE_LAST = 3
     * }
     */
    public static int UCS_THREAD_MODE_LAST() {
        return UCS_THREAD_MODE_LAST;
    }

    private static class ucs_thread_mode_names$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, Ucx.C_POINTER);
        public static final MemorySegment SEGMENT = Ucx.findOrThrow("ucs_thread_mode_names").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *ucs_thread_mode_names[]
     * }
     */
    public static SequenceLayout ucs_thread_mode_names$layout() {
        return ucs_thread_mode_names$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char *ucs_thread_mode_names[]
     * }
     */
    public static long[] ucs_thread_mode_names$dimensions() {
        return ucs_thread_mode_names$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *ucs_thread_mode_names[]
     * }
     */
    public static MemorySegment ucs_thread_mode_names() {
        return ucs_thread_mode_names$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *ucs_thread_mode_names[]
     * }
     */
    public static void ucs_thread_mode_names(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, ucs_thread_mode_names$constants.SEGMENT, 0L, ucs_thread_mode_names$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long ucs_cpu_mask_t
     * }
     */
    public static final OfLong ucs_cpu_mask_t = Ucx.C_LONG;

    private static class stdin$constants {
        public static final AddressLayout LAYOUT = Ucx.C_POINTER;
        public static final MemorySegment SEGMENT = Ucx.findOrThrow("stdin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static AddressLayout stdin$layout() {
        return stdin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin$segment() {
        return stdin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin() {
        return stdin$constants.SEGMENT.get(stdin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static void stdin(MemorySegment varValue) {
        stdin$constants.SEGMENT.set(stdin$constants.LAYOUT, 0L, varValue);
    }

    private static class stdout$constants {
        public static final AddressLayout LAYOUT = Ucx.C_POINTER;
        public static final MemorySegment SEGMENT = Ucx.findOrThrow("stdout").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static AddressLayout stdout$layout() {
        return stdout$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout$segment() {
        return stdout$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout() {
        return stdout$constants.SEGMENT.get(stdout$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static void stdout(MemorySegment varValue) {
        stdout$constants.SEGMENT.set(stdout$constants.LAYOUT, 0L, varValue);
    }

    private static class stderr$constants {
        public static final AddressLayout LAYOUT = Ucx.C_POINTER;
        public static final MemorySegment SEGMENT = Ucx.findOrThrow("stderr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static AddressLayout stderr$layout() {
        return stderr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr$segment() {
        return stderr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr() {
        return stderr$constants.SEGMENT.get(stderr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static void stderr(MemorySegment varValue) {
        stderr$constants.SEGMENT.set(stderr$constants.LAYOUT, 0L, varValue);
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static int remove(MemorySegment __filename) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", __filename);
            }
            return (int)mh$.invokeExact(__filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static int renameat(int __oldfd, MemorySegment __old, int __newfd, MemorySegment __new) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", __oldfd, __old, __newfd, __new);
            }
            return (int)mh$.invokeExact(__oldfd, __old, __newfd, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static int fclose(MemorySegment __stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER    );

        public static final MemorySegment ADDR = Ucx.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("tmpnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static FunctionDescriptor tmpnam_r$descriptor() {
        return tmpnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MethodHandle tmpnam_r$handle() {
        return tmpnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r$address() {
        return tmpnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r(MemorySegment __s) {
        var mh$ = tmpnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_r", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __pfx) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __pfx);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __pfx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static int fflush(MemorySegment __stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fflush_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush_unlocked$descriptor() {
        return fflush_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fflush_unlocked$handle() {
        return fflush_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fflush_unlocked$address() {
        return fflush_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static int fflush_unlocked(MemorySegment __stream) {
        var mh$ = fflush_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __modes) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment __filename, MemorySegment __modes, MemorySegment __stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", __filename, __modes, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen(int __fd, MemorySegment __modes) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", __fd, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__fd, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __s, long __len, MemorySegment __modes) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __s, __len, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__s, __len, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufloc, MemorySegment __sizeloc) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufloc, __sizeloc);
            }
            return (MemorySegment)mh$.invokeExact(__bufloc, __sizeloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static void setbuf(MemorySegment __stream, MemorySegment __buf) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", __stream, __buf);
            }
            mh$.invokeExact(__stream, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_LONG
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static int setvbuf(MemorySegment __stream, MemorySegment __buf, int __modes, long __n) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", __stream, __buf, __modes, __n);
            }
            return (int)mh$.invokeExact(__stream, __buf, __modes, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static void setbuffer(MemorySegment __stream, MemorySegment __buf, long __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", __stream, __buf, __size);
            }
            mh$.invokeExact(__stream, __buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static void setlinebuf(MemorySegment __stream) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucx.C_INT,
                Ucx.C_POINTER,
                Ucx.C_POINTER
            );
        private static final MemorySegment ADDR = Ucx.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", __stream, __format, x2);
                }
                return (int)spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int printf(const char *restrict __format, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucx.C_INT,
                Ucx.C_POINTER
            );
        private static final MemorySegment ADDR = Ucx.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int printf(const char *restrict __format, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", __format, x1);
                }
                return (int)spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucx.C_INT,
                Ucx.C_POINTER,
                Ucx.C_POINTER
            );
        private static final MemorySegment ADDR = Ucx.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", __s, __format, x2);
                }
                return (int)spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vprintf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucx.C_INT,
                Ucx.C_POINTER,
                Ucx.C_LONG,
                Ucx.C_POINTER
            );
        private static final MemorySegment ADDR = Ucx.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, long __maxlen, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __s, __maxlen, __format, x3);
                }
                return (int)spreader.invokeExact(__s, __maxlen, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsnprintf(MemorySegment __s, long __maxlen, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __s, __maxlen, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __maxlen, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static int vdprintf(int __fd, MemorySegment __fmt, MemorySegment __arg) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", __fd, __fmt, __arg);
            }
            return (int)mh$.invokeExact(__fd, __fmt, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int dprintf(int __fd, const char *restrict __fmt, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucx.C_INT,
                Ucx.C_INT,
                Ucx.C_POINTER
            );
        private static final MemorySegment ADDR = Ucx.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int dprintf(int __fd, const char *restrict __fmt, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", __fd, __fmt, x2);
                }
                return (int)spreader.invokeExact(__fd, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucx.C_INT,
                Ucx.C_POINTER,
                Ucx.C_POINTER
            );
        private static final MemorySegment ADDR = Ucx.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", __stream, __format, x2);
                }
                return (int)spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int scanf(const char *restrict __format, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucx.C_INT,
                Ucx.C_POINTER
            );
        private static final MemorySegment ADDR = Ucx.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int scanf(const char *restrict __format, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", __format, x1);
                }
                return (int)spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucx.C_INT,
                Ucx.C_POINTER,
                Ucx.C_POINTER
            );
        private static final MemorySegment ADDR = Ucx.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", __s, __format, x2);
                }
                return (int)spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = Ucx.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = Ucx.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = Ucx.C_DOUBLE;

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static int fgetc(MemorySegment __stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static int getc(MemorySegment __stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT    );

        public static final MemorySegment ADDR = Ucx.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static int getc_unlocked(MemorySegment __stream) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT    );

        public static final MemorySegment ADDR = Ucx.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fgetc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc_unlocked$descriptor() {
        return fgetc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc_unlocked$handle() {
        return fgetc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc_unlocked$address() {
        return fgetc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static int fgetc_unlocked(MemorySegment __stream) {
        var mh$ = fgetc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static int fputc(int __c, MemorySegment __stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static int putc(int __c, MemorySegment __stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static int putchar(int __c) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fputc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc_unlocked$descriptor() {
        return fputc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc_unlocked$handle() {
        return fputc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc_unlocked$address() {
        return fputc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int fputc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = fputc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int putc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static int putchar_unlocked(int __c) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static int getw(MemorySegment __stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static int putw(int __w, MemorySegment __stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", __w, __stream);
            }
            return (int)mh$.invokeExact(__w, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment __s, int __n, MemorySegment __stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", __s, __n, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__s, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("__getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor __getdelim$descriptor() {
        return __getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle __getdelim$handle() {
        return __getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment __getdelim$address() {
        return __getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long __getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = __getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __lineptr, MemorySegment __n, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __lineptr, __n, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static int fputs(MemorySegment __s, MemorySegment __stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", __s, __stream);
            }
            return (int)mh$.invokeExact(__s, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static int puts(MemorySegment __s) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", __s);
            }
            return (int)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static int ungetc(int __c, MemorySegment __stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __n, MemorySegment __s) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __n, __s);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fread_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread_unlocked$descriptor() {
        return fread_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread_unlocked$handle() {
        return fread_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread_unlocked$address() {
        return fread_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fwrite_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite_unlocked$descriptor() {
        return fwrite_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite_unlocked$handle() {
        return fwrite_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite_unlocked$address() {
        return fwrite_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fwrite_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fwrite_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static int fseek(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static long ftell(MemorySegment __stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static void rewind(MemorySegment __stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static int fgetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static int fsetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static void clearerr(MemorySegment __stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static int feof(MemorySegment __stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static int ferror(MemorySegment __stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("clearerr_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr_unlocked$descriptor() {
        return clearerr_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr_unlocked$handle() {
        return clearerr_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr_unlocked$address() {
        return clearerr_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static void clearerr_unlocked(MemorySegment __stream) {
        var mh$ = clearerr_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_unlocked", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("feof_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof_unlocked$descriptor() {
        return feof_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle feof_unlocked$handle() {
        return feof_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment feof_unlocked$address() {
        return feof_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static int feof_unlocked(MemorySegment __stream) {
        var mh$ = feof_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ferror_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror_unlocked$descriptor() {
        return ferror_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle ferror_unlocked$handle() {
        return ferror_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment ferror_unlocked$address() {
        return ferror_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static int ferror_unlocked(MemorySegment __stream) {
        var mh$ = ferror_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static void perror(MemorySegment __s) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", __s);
            }
            mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static int fileno(MemorySegment __stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("fileno_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno_unlocked$descriptor() {
        return fileno_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fileno_unlocked$handle() {
        return fileno_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fileno_unlocked$address() {
        return fileno_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static int fileno_unlocked(MemorySegment __stream) {
        var mh$ = fileno_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static int pclose(MemorySegment __stream) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen(MemorySegment __command, MemorySegment __modes) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", __command, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__command, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid(MemorySegment __s) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static void flockfile(MemorySegment __stream) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static int ftrylockfile(MemorySegment __stream) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static void funlockfile(MemorySegment __stream) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __uflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("__uflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static FunctionDescriptor __uflow$descriptor() {
        return __uflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MethodHandle __uflow$handle() {
        return __uflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MemorySegment __uflow$address() {
        return __uflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static int __uflow(MemorySegment x0) {
        var mh$ = __uflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__uflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("__overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static FunctionDescriptor __overflow$descriptor() {
        return __overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MethodHandle __overflow$handle() {
        return __overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MemorySegment __overflow$address() {
        return __overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static int __overflow(MemorySegment x0, int x1) {
        var mh$ = __overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__overflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UCP_PARAM_FIELD_FEATURES = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_params_field.UCP_PARAM_FIELD_FEATURES = 1
     * }
     */
    public static int UCP_PARAM_FIELD_FEATURES() {
        return UCP_PARAM_FIELD_FEATURES;
    }
    private static final int UCP_PARAM_FIELD_REQUEST_SIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_params_field.UCP_PARAM_FIELD_REQUEST_SIZE = 2
     * }
     */
    public static int UCP_PARAM_FIELD_REQUEST_SIZE() {
        return UCP_PARAM_FIELD_REQUEST_SIZE;
    }
    private static final int UCP_PARAM_FIELD_REQUEST_INIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_params_field.UCP_PARAM_FIELD_REQUEST_INIT = 4
     * }
     */
    public static int UCP_PARAM_FIELD_REQUEST_INIT() {
        return UCP_PARAM_FIELD_REQUEST_INIT;
    }
    private static final int UCP_PARAM_FIELD_REQUEST_CLEANUP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucp_params_field.UCP_PARAM_FIELD_REQUEST_CLEANUP = 8
     * }
     */
    public static int UCP_PARAM_FIELD_REQUEST_CLEANUP() {
        return UCP_PARAM_FIELD_REQUEST_CLEANUP;
    }
    private static final int UCP_PARAM_FIELD_TAG_SENDER_MASK = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ucp_params_field.UCP_PARAM_FIELD_TAG_SENDER_MASK = 16
     * }
     */
    public static int UCP_PARAM_FIELD_TAG_SENDER_MASK() {
        return UCP_PARAM_FIELD_TAG_SENDER_MASK;
    }
    private static final int UCP_PARAM_FIELD_MT_WORKERS_SHARED = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ucp_params_field.UCP_PARAM_FIELD_MT_WORKERS_SHARED = 32
     * }
     */
    public static int UCP_PARAM_FIELD_MT_WORKERS_SHARED() {
        return UCP_PARAM_FIELD_MT_WORKERS_SHARED;
    }
    private static final int UCP_PARAM_FIELD_ESTIMATED_NUM_EPS = (int)64L;
    /**
     * {@snippet lang=c :
     * enum ucp_params_field.UCP_PARAM_FIELD_ESTIMATED_NUM_EPS = 64
     * }
     */
    public static int UCP_PARAM_FIELD_ESTIMATED_NUM_EPS() {
        return UCP_PARAM_FIELD_ESTIMATED_NUM_EPS;
    }
    private static final int UCP_PARAM_FIELD_ESTIMATED_NUM_PPN = (int)128L;
    /**
     * {@snippet lang=c :
     * enum ucp_params_field.UCP_PARAM_FIELD_ESTIMATED_NUM_PPN = 128
     * }
     */
    public static int UCP_PARAM_FIELD_ESTIMATED_NUM_PPN() {
        return UCP_PARAM_FIELD_ESTIMATED_NUM_PPN;
    }
    private static final int UCP_PARAM_FIELD_NAME = (int)256L;
    /**
     * {@snippet lang=c :
     * enum ucp_params_field.UCP_PARAM_FIELD_NAME = 256
     * }
     */
    public static int UCP_PARAM_FIELD_NAME() {
        return UCP_PARAM_FIELD_NAME;
    }
    private static final int UCP_PARAM_FIELD_NODE_LOCAL_ID = (int)512L;
    /**
     * {@snippet lang=c :
     * enum ucp_params_field.UCP_PARAM_FIELD_NODE_LOCAL_ID = 512
     * }
     */
    public static int UCP_PARAM_FIELD_NODE_LOCAL_ID() {
        return UCP_PARAM_FIELD_NODE_LOCAL_ID;
    }
    private static final int UCP_FEATURE_TAG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_feature.UCP_FEATURE_TAG = 1
     * }
     */
    public static int UCP_FEATURE_TAG() {
        return UCP_FEATURE_TAG;
    }
    private static final int UCP_FEATURE_RMA = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_feature.UCP_FEATURE_RMA = 2
     * }
     */
    public static int UCP_FEATURE_RMA() {
        return UCP_FEATURE_RMA;
    }
    private static final int UCP_FEATURE_AMO32 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_feature.UCP_FEATURE_AMO32 = 4
     * }
     */
    public static int UCP_FEATURE_AMO32() {
        return UCP_FEATURE_AMO32;
    }
    private static final int UCP_FEATURE_AMO64 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucp_feature.UCP_FEATURE_AMO64 = 8
     * }
     */
    public static int UCP_FEATURE_AMO64() {
        return UCP_FEATURE_AMO64;
    }
    private static final int UCP_FEATURE_WAKEUP = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ucp_feature.UCP_FEATURE_WAKEUP = 16
     * }
     */
    public static int UCP_FEATURE_WAKEUP() {
        return UCP_FEATURE_WAKEUP;
    }
    private static final int UCP_FEATURE_STREAM = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ucp_feature.UCP_FEATURE_STREAM = 32
     * }
     */
    public static int UCP_FEATURE_STREAM() {
        return UCP_FEATURE_STREAM;
    }
    private static final int UCP_FEATURE_AM = (int)64L;
    /**
     * {@snippet lang=c :
     * enum ucp_feature.UCP_FEATURE_AM = 64
     * }
     */
    public static int UCP_FEATURE_AM() {
        return UCP_FEATURE_AM;
    }
    private static final int UCP_FEATURE_EXPORTED_MEMH = (int)128L;
    /**
     * {@snippet lang=c :
     * enum ucp_feature.UCP_FEATURE_EXPORTED_MEMH = 128
     * }
     */
    public static int UCP_FEATURE_EXPORTED_MEMH() {
        return UCP_FEATURE_EXPORTED_MEMH;
    }
    private static final int UCP_FEATURE_DEVICE = (int)256L;
    /**
     * {@snippet lang=c :
     * enum ucp_feature.UCP_FEATURE_DEVICE = 256
     * }
     */
    public static int UCP_FEATURE_DEVICE() {
        return UCP_FEATURE_DEVICE;
    }
    private static final int UCP_WORKER_PARAM_FIELD_THREAD_MODE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_params_field.UCP_WORKER_PARAM_FIELD_THREAD_MODE = 1
     * }
     */
    public static int UCP_WORKER_PARAM_FIELD_THREAD_MODE() {
        return UCP_WORKER_PARAM_FIELD_THREAD_MODE;
    }
    private static final int UCP_WORKER_PARAM_FIELD_CPU_MASK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_params_field.UCP_WORKER_PARAM_FIELD_CPU_MASK = 2
     * }
     */
    public static int UCP_WORKER_PARAM_FIELD_CPU_MASK() {
        return UCP_WORKER_PARAM_FIELD_CPU_MASK;
    }
    private static final int UCP_WORKER_PARAM_FIELD_EVENTS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_params_field.UCP_WORKER_PARAM_FIELD_EVENTS = 4
     * }
     */
    public static int UCP_WORKER_PARAM_FIELD_EVENTS() {
        return UCP_WORKER_PARAM_FIELD_EVENTS;
    }
    private static final int UCP_WORKER_PARAM_FIELD_USER_DATA = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_params_field.UCP_WORKER_PARAM_FIELD_USER_DATA = 8
     * }
     */
    public static int UCP_WORKER_PARAM_FIELD_USER_DATA() {
        return UCP_WORKER_PARAM_FIELD_USER_DATA;
    }
    private static final int UCP_WORKER_PARAM_FIELD_EVENT_FD = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_params_field.UCP_WORKER_PARAM_FIELD_EVENT_FD = 16
     * }
     */
    public static int UCP_WORKER_PARAM_FIELD_EVENT_FD() {
        return UCP_WORKER_PARAM_FIELD_EVENT_FD;
    }
    private static final int UCP_WORKER_PARAM_FIELD_FLAGS = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_params_field.UCP_WORKER_PARAM_FIELD_FLAGS = 32
     * }
     */
    public static int UCP_WORKER_PARAM_FIELD_FLAGS() {
        return UCP_WORKER_PARAM_FIELD_FLAGS;
    }
    private static final int UCP_WORKER_PARAM_FIELD_NAME = (int)64L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_params_field.UCP_WORKER_PARAM_FIELD_NAME = 64
     * }
     */
    public static int UCP_WORKER_PARAM_FIELD_NAME() {
        return UCP_WORKER_PARAM_FIELD_NAME;
    }
    private static final int UCP_WORKER_PARAM_FIELD_AM_ALIGNMENT = (int)128L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_params_field.UCP_WORKER_PARAM_FIELD_AM_ALIGNMENT = 128
     * }
     */
    public static int UCP_WORKER_PARAM_FIELD_AM_ALIGNMENT() {
        return UCP_WORKER_PARAM_FIELD_AM_ALIGNMENT;
    }
    private static final int UCP_WORKER_PARAM_FIELD_CLIENT_ID = (int)256L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_params_field.UCP_WORKER_PARAM_FIELD_CLIENT_ID = 256
     * }
     */
    public static int UCP_WORKER_PARAM_FIELD_CLIENT_ID() {
        return UCP_WORKER_PARAM_FIELD_CLIENT_ID;
    }
    private static final int UCP_WORKER_FLAG_IGNORE_REQUEST_LEAK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_WORKER_FLAG_IGNORE_REQUEST_LEAK = 1
     * }
     */
    public static int UCP_WORKER_FLAG_IGNORE_REQUEST_LEAK() {
        return UCP_WORKER_FLAG_IGNORE_REQUEST_LEAK;
    }
    private static final int UCP_LISTENER_PARAM_FIELD_SOCK_ADDR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_listener_params_field.UCP_LISTENER_PARAM_FIELD_SOCK_ADDR = 1
     * }
     */
    public static int UCP_LISTENER_PARAM_FIELD_SOCK_ADDR() {
        return UCP_LISTENER_PARAM_FIELD_SOCK_ADDR;
    }
    private static final int UCP_LISTENER_PARAM_FIELD_ACCEPT_HANDLER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_listener_params_field.UCP_LISTENER_PARAM_FIELD_ACCEPT_HANDLER = 2
     * }
     */
    public static int UCP_LISTENER_PARAM_FIELD_ACCEPT_HANDLER() {
        return UCP_LISTENER_PARAM_FIELD_ACCEPT_HANDLER;
    }
    private static final int UCP_LISTENER_PARAM_FIELD_CONN_HANDLER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_listener_params_field.UCP_LISTENER_PARAM_FIELD_CONN_HANDLER = 4
     * }
     */
    public static int UCP_LISTENER_PARAM_FIELD_CONN_HANDLER() {
        return UCP_LISTENER_PARAM_FIELD_CONN_HANDLER;
    }
    private static final int UCP_WORKER_ADDRESS_FLAG_NET_ONLY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_WORKER_ADDRESS_FLAG_NET_ONLY = 1
     * }
     */
    public static int UCP_WORKER_ADDRESS_FLAG_NET_ONLY() {
        return UCP_WORKER_ADDRESS_FLAG_NET_ONLY;
    }
    private static final int UCP_EP_PARAM_FIELD_REMOTE_ADDRESS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_params_field.UCP_EP_PARAM_FIELD_REMOTE_ADDRESS = 1
     * }
     */
    public static int UCP_EP_PARAM_FIELD_REMOTE_ADDRESS() {
        return UCP_EP_PARAM_FIELD_REMOTE_ADDRESS;
    }
    private static final int UCP_EP_PARAM_FIELD_ERR_HANDLING_MODE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_params_field.UCP_EP_PARAM_FIELD_ERR_HANDLING_MODE = 2
     * }
     */
    public static int UCP_EP_PARAM_FIELD_ERR_HANDLING_MODE() {
        return UCP_EP_PARAM_FIELD_ERR_HANDLING_MODE;
    }
    private static final int UCP_EP_PARAM_FIELD_ERR_HANDLER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_params_field.UCP_EP_PARAM_FIELD_ERR_HANDLER = 4
     * }
     */
    public static int UCP_EP_PARAM_FIELD_ERR_HANDLER() {
        return UCP_EP_PARAM_FIELD_ERR_HANDLER;
    }
    private static final int UCP_EP_PARAM_FIELD_USER_DATA = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_params_field.UCP_EP_PARAM_FIELD_USER_DATA = 8
     * }
     */
    public static int UCP_EP_PARAM_FIELD_USER_DATA() {
        return UCP_EP_PARAM_FIELD_USER_DATA;
    }
    private static final int UCP_EP_PARAM_FIELD_SOCK_ADDR = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_params_field.UCP_EP_PARAM_FIELD_SOCK_ADDR = 16
     * }
     */
    public static int UCP_EP_PARAM_FIELD_SOCK_ADDR() {
        return UCP_EP_PARAM_FIELD_SOCK_ADDR;
    }
    private static final int UCP_EP_PARAM_FIELD_FLAGS = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_params_field.UCP_EP_PARAM_FIELD_FLAGS = 32
     * }
     */
    public static int UCP_EP_PARAM_FIELD_FLAGS() {
        return UCP_EP_PARAM_FIELD_FLAGS;
    }
    private static final int UCP_EP_PARAM_FIELD_CONN_REQUEST = (int)64L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_params_field.UCP_EP_PARAM_FIELD_CONN_REQUEST = 64
     * }
     */
    public static int UCP_EP_PARAM_FIELD_CONN_REQUEST() {
        return UCP_EP_PARAM_FIELD_CONN_REQUEST;
    }
    private static final int UCP_EP_PARAM_FIELD_NAME = (int)128L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_params_field.UCP_EP_PARAM_FIELD_NAME = 128
     * }
     */
    public static int UCP_EP_PARAM_FIELD_NAME() {
        return UCP_EP_PARAM_FIELD_NAME;
    }
    private static final int UCP_EP_PARAM_FIELD_LOCAL_SOCK_ADDR = (int)256L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_params_field.UCP_EP_PARAM_FIELD_LOCAL_SOCK_ADDR = 256
     * }
     */
    public static int UCP_EP_PARAM_FIELD_LOCAL_SOCK_ADDR() {
        return UCP_EP_PARAM_FIELD_LOCAL_SOCK_ADDR;
    }
    private static final int UCP_EP_PARAMS_FLAGS_CLIENT_SERVER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_params_flags_field.UCP_EP_PARAMS_FLAGS_CLIENT_SERVER = 1
     * }
     */
    public static int UCP_EP_PARAMS_FLAGS_CLIENT_SERVER() {
        return UCP_EP_PARAMS_FLAGS_CLIENT_SERVER;
    }
    private static final int UCP_EP_PARAMS_FLAGS_NO_LOOPBACK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_params_flags_field.UCP_EP_PARAMS_FLAGS_NO_LOOPBACK = 2
     * }
     */
    public static int UCP_EP_PARAMS_FLAGS_NO_LOOPBACK() {
        return UCP_EP_PARAMS_FLAGS_NO_LOOPBACK;
    }
    private static final int UCP_EP_PARAMS_FLAGS_SEND_CLIENT_ID = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_params_flags_field.UCP_EP_PARAMS_FLAGS_SEND_CLIENT_ID = 4
     * }
     */
    public static int UCP_EP_PARAMS_FLAGS_SEND_CLIENT_ID() {
        return UCP_EP_PARAMS_FLAGS_SEND_CLIENT_ID;
    }
    private static final int UCP_EP_CLOSE_FLAG_FORCE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_EP_CLOSE_FLAG_FORCE = 1
     * }
     */
    public static int UCP_EP_CLOSE_FLAG_FORCE() {
        return UCP_EP_CLOSE_FLAG_FORCE;
    }
    private static final int UCP_EP_PERF_PARAM_FIELD_MESSAGE_SIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_perf_param_field.UCP_EP_PERF_PARAM_FIELD_MESSAGE_SIZE = 1
     * }
     */
    public static int UCP_EP_PERF_PARAM_FIELD_MESSAGE_SIZE() {
        return UCP_EP_PERF_PARAM_FIELD_MESSAGE_SIZE;
    }
    private static final int UCP_EP_PERF_ATTR_FIELD_ESTIMATED_TIME = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_perf_attr_field.UCP_EP_PERF_ATTR_FIELD_ESTIMATED_TIME = 1
     * }
     */
    public static int UCP_EP_PERF_ATTR_FIELD_ESTIMATED_TIME() {
        return UCP_EP_PERF_ATTR_FIELD_ESTIMATED_TIME;
    }
    private static final int UCP_MEM_MAP_PARAM_FIELD_ADDRESS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_mem_map_params_field.UCP_MEM_MAP_PARAM_FIELD_ADDRESS = 1
     * }
     */
    public static int UCP_MEM_MAP_PARAM_FIELD_ADDRESS() {
        return UCP_MEM_MAP_PARAM_FIELD_ADDRESS;
    }
    private static final int UCP_MEM_MAP_PARAM_FIELD_LENGTH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_mem_map_params_field.UCP_MEM_MAP_PARAM_FIELD_LENGTH = 2
     * }
     */
    public static int UCP_MEM_MAP_PARAM_FIELD_LENGTH() {
        return UCP_MEM_MAP_PARAM_FIELD_LENGTH;
    }
    private static final int UCP_MEM_MAP_PARAM_FIELD_FLAGS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_mem_map_params_field.UCP_MEM_MAP_PARAM_FIELD_FLAGS = 4
     * }
     */
    public static int UCP_MEM_MAP_PARAM_FIELD_FLAGS() {
        return UCP_MEM_MAP_PARAM_FIELD_FLAGS;
    }
    private static final int UCP_MEM_MAP_PARAM_FIELD_PROT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucp_mem_map_params_field.UCP_MEM_MAP_PARAM_FIELD_PROT = 8
     * }
     */
    public static int UCP_MEM_MAP_PARAM_FIELD_PROT() {
        return UCP_MEM_MAP_PARAM_FIELD_PROT;
    }
    private static final int UCP_MEM_MAP_PARAM_FIELD_MEMORY_TYPE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ucp_mem_map_params_field.UCP_MEM_MAP_PARAM_FIELD_MEMORY_TYPE = 16
     * }
     */
    public static int UCP_MEM_MAP_PARAM_FIELD_MEMORY_TYPE() {
        return UCP_MEM_MAP_PARAM_FIELD_MEMORY_TYPE;
    }
    private static final int UCP_MEM_MAP_PARAM_FIELD_EXPORTED_MEMH_BUFFER = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ucp_mem_map_params_field.UCP_MEM_MAP_PARAM_FIELD_EXPORTED_MEMH_BUFFER = 32
     * }
     */
    public static int UCP_MEM_MAP_PARAM_FIELD_EXPORTED_MEMH_BUFFER() {
        return UCP_MEM_MAP_PARAM_FIELD_EXPORTED_MEMH_BUFFER;
    }
    private static final int UCP_MEM_ADVISE_PARAM_FIELD_ADDRESS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_mem_advise_params_field.UCP_MEM_ADVISE_PARAM_FIELD_ADDRESS = 1
     * }
     */
    public static int UCP_MEM_ADVISE_PARAM_FIELD_ADDRESS() {
        return UCP_MEM_ADVISE_PARAM_FIELD_ADDRESS;
    }
    private static final int UCP_MEM_ADVISE_PARAM_FIELD_LENGTH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_mem_advise_params_field.UCP_MEM_ADVISE_PARAM_FIELD_LENGTH = 2
     * }
     */
    public static int UCP_MEM_ADVISE_PARAM_FIELD_LENGTH() {
        return UCP_MEM_ADVISE_PARAM_FIELD_LENGTH;
    }
    private static final int UCP_MEM_ADVISE_PARAM_FIELD_ADVICE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_mem_advise_params_field.UCP_MEM_ADVISE_PARAM_FIELD_ADVICE = 4
     * }
     */
    public static int UCP_MEM_ADVISE_PARAM_FIELD_ADVICE() {
        return UCP_MEM_ADVISE_PARAM_FIELD_ADVICE;
    }
    private static final int UCP_LIB_ATTR_FIELD_MAX_THREAD_LEVEL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_lib_attr_field.UCP_LIB_ATTR_FIELD_MAX_THREAD_LEVEL = 1
     * }
     */
    public static int UCP_LIB_ATTR_FIELD_MAX_THREAD_LEVEL() {
        return UCP_LIB_ATTR_FIELD_MAX_THREAD_LEVEL;
    }
    private static final int UCP_ATTR_FIELD_REQUEST_SIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_context_attr_field.UCP_ATTR_FIELD_REQUEST_SIZE = 1
     * }
     */
    public static int UCP_ATTR_FIELD_REQUEST_SIZE() {
        return UCP_ATTR_FIELD_REQUEST_SIZE;
    }
    private static final int UCP_ATTR_FIELD_THREAD_MODE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_context_attr_field.UCP_ATTR_FIELD_THREAD_MODE = 2
     * }
     */
    public static int UCP_ATTR_FIELD_THREAD_MODE() {
        return UCP_ATTR_FIELD_THREAD_MODE;
    }
    private static final int UCP_ATTR_FIELD_MEMORY_TYPES = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_context_attr_field.UCP_ATTR_FIELD_MEMORY_TYPES = 4
     * }
     */
    public static int UCP_ATTR_FIELD_MEMORY_TYPES() {
        return UCP_ATTR_FIELD_MEMORY_TYPES;
    }
    private static final int UCP_ATTR_FIELD_NAME = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucp_context_attr_field.UCP_ATTR_FIELD_NAME = 8
     * }
     */
    public static int UCP_ATTR_FIELD_NAME() {
        return UCP_ATTR_FIELD_NAME;
    }
    private static final int UCP_ATTR_FIELD_DEVICE_COUNTER_SIZE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ucp_context_attr_field.UCP_ATTR_FIELD_DEVICE_COUNTER_SIZE = 16
     * }
     */
    public static int UCP_ATTR_FIELD_DEVICE_COUNTER_SIZE() {
        return UCP_ATTR_FIELD_DEVICE_COUNTER_SIZE;
    }
    private static final int UCP_WORKER_ATTR_FIELD_THREAD_MODE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_attr_field.UCP_WORKER_ATTR_FIELD_THREAD_MODE = 1
     * }
     */
    public static int UCP_WORKER_ATTR_FIELD_THREAD_MODE() {
        return UCP_WORKER_ATTR_FIELD_THREAD_MODE;
    }
    private static final int UCP_WORKER_ATTR_FIELD_ADDRESS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_attr_field.UCP_WORKER_ATTR_FIELD_ADDRESS = 2
     * }
     */
    public static int UCP_WORKER_ATTR_FIELD_ADDRESS() {
        return UCP_WORKER_ATTR_FIELD_ADDRESS;
    }
    private static final int UCP_WORKER_ATTR_FIELD_ADDRESS_FLAGS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_attr_field.UCP_WORKER_ATTR_FIELD_ADDRESS_FLAGS = 4
     * }
     */
    public static int UCP_WORKER_ATTR_FIELD_ADDRESS_FLAGS() {
        return UCP_WORKER_ATTR_FIELD_ADDRESS_FLAGS;
    }
    private static final int UCP_WORKER_ATTR_FIELD_MAX_AM_HEADER = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_attr_field.UCP_WORKER_ATTR_FIELD_MAX_AM_HEADER = 8
     * }
     */
    public static int UCP_WORKER_ATTR_FIELD_MAX_AM_HEADER() {
        return UCP_WORKER_ATTR_FIELD_MAX_AM_HEADER;
    }
    private static final int UCP_WORKER_ATTR_FIELD_NAME = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_attr_field.UCP_WORKER_ATTR_FIELD_NAME = 16
     * }
     */
    public static int UCP_WORKER_ATTR_FIELD_NAME() {
        return UCP_WORKER_ATTR_FIELD_NAME;
    }
    private static final int UCP_WORKER_ATTR_FIELD_MAX_INFO_STRING = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_attr_field.UCP_WORKER_ATTR_FIELD_MAX_INFO_STRING = 32
     * }
     */
    public static int UCP_WORKER_ATTR_FIELD_MAX_INFO_STRING() {
        return UCP_WORKER_ATTR_FIELD_MAX_INFO_STRING;
    }
    private static final int UCP_WORKER_ADDRESS_ATTR_FIELD_UID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_worker_address_attr_field.UCP_WORKER_ADDRESS_ATTR_FIELD_UID = 1
     * }
     */
    public static int UCP_WORKER_ADDRESS_ATTR_FIELD_UID() {
        return UCP_WORKER_ADDRESS_ATTR_FIELD_UID;
    }
    private static final int UCP_LISTENER_ATTR_FIELD_SOCKADDR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_listener_attr_field.UCP_LISTENER_ATTR_FIELD_SOCKADDR = 1
     * }
     */
    public static int UCP_LISTENER_ATTR_FIELD_SOCKADDR() {
        return UCP_LISTENER_ATTR_FIELD_SOCKADDR;
    }
    private static final int UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ADDR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_conn_request_attr_field.UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ADDR = 1
     * }
     */
    public static int UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ADDR() {
        return UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ADDR;
    }
    private static final int UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_conn_request_attr_field.UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ID = 2
     * }
     */
    public static int UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ID() {
        return UCP_CONN_REQUEST_ATTR_FIELD_CLIENT_ID;
    }
    private static final int UCP_DATATYPE_CONTIG = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ucp_dt_type.UCP_DATATYPE_CONTIG = 0
     * }
     */
    public static int UCP_DATATYPE_CONTIG() {
        return UCP_DATATYPE_CONTIG;
    }
    private static final int UCP_DATATYPE_STRIDED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_dt_type.UCP_DATATYPE_STRIDED = 1
     * }
     */
    public static int UCP_DATATYPE_STRIDED() {
        return UCP_DATATYPE_STRIDED;
    }
    private static final int UCP_DATATYPE_IOV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_dt_type.UCP_DATATYPE_IOV = 2
     * }
     */
    public static int UCP_DATATYPE_IOV() {
        return UCP_DATATYPE_IOV;
    }
    private static final int UCP_DATATYPE_GENERIC = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ucp_dt_type.UCP_DATATYPE_GENERIC = 7
     * }
     */
    public static int UCP_DATATYPE_GENERIC() {
        return UCP_DATATYPE_GENERIC;
    }
    private static final int UCP_DATATYPE_SHIFT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ucp_dt_type.UCP_DATATYPE_SHIFT = 3
     * }
     */
    public static int UCP_DATATYPE_SHIFT() {
        return UCP_DATATYPE_SHIFT;
    }
    private static final int UCP_DATATYPE_CLASS_MASK = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ucp_dt_type.UCP_DATATYPE_CLASS_MASK = 7
     * }
     */
    public static int UCP_DATATYPE_CLASS_MASK() {
        return UCP_DATATYPE_CLASS_MASK;
    }
    private static final int UCP_DATATYPE_ATTR_FIELD_PACKED_SIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_datatype_attr_field.UCP_DATATYPE_ATTR_FIELD_PACKED_SIZE = 1
     * }
     */
    public static int UCP_DATATYPE_ATTR_FIELD_PACKED_SIZE() {
        return UCP_DATATYPE_ATTR_FIELD_PACKED_SIZE;
    }
    private static final int UCP_DATATYPE_ATTR_FIELD_BUFFER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_datatype_attr_field.UCP_DATATYPE_ATTR_FIELD_BUFFER = 2
     * }
     */
    public static int UCP_DATATYPE_ATTR_FIELD_BUFFER() {
        return UCP_DATATYPE_ATTR_FIELD_BUFFER;
    }
    private static final int UCP_DATATYPE_ATTR_FIELD_COUNT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_datatype_attr_field.UCP_DATATYPE_ATTR_FIELD_COUNT = 4
     * }
     */
    public static int UCP_DATATYPE_ATTR_FIELD_COUNT() {
        return UCP_DATATYPE_ATTR_FIELD_COUNT;
    }
    private static final int UCP_MEM_MAP_NONBLOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_MEM_MAP_NONBLOCK = 1
     * }
     */
    public static int UCP_MEM_MAP_NONBLOCK() {
        return UCP_MEM_MAP_NONBLOCK;
    }
    private static final int UCP_MEM_MAP_ALLOCATE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_MEM_MAP_ALLOCATE = 2
     * }
     */
    public static int UCP_MEM_MAP_ALLOCATE() {
        return UCP_MEM_MAP_ALLOCATE;
    }
    private static final int UCP_MEM_MAP_FIXED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_MEM_MAP_FIXED = 4
     * }
     */
    public static int UCP_MEM_MAP_FIXED() {
        return UCP_MEM_MAP_FIXED;
    }
    private static final int UCP_MEM_MAP_SYMMETRIC_RKEY = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_MEM_MAP_SYMMETRIC_RKEY = 8
     * }
     */
    public static int UCP_MEM_MAP_SYMMETRIC_RKEY() {
        return UCP_MEM_MAP_SYMMETRIC_RKEY;
    }
    private static final int UCP_MEM_MAP_LOCK = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_MEM_MAP_LOCK = 16
     * }
     */
    public static int UCP_MEM_MAP_LOCK() {
        return UCP_MEM_MAP_LOCK;
    }
    private static final int UCP_MEM_MAP_PROT_LOCAL_READ = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_MEM_MAP_PROT_LOCAL_READ = 1
     * }
     */
    public static int UCP_MEM_MAP_PROT_LOCAL_READ() {
        return UCP_MEM_MAP_PROT_LOCAL_READ;
    }
    private static final int UCP_MEM_MAP_PROT_LOCAL_WRITE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_MEM_MAP_PROT_LOCAL_WRITE = 2
     * }
     */
    public static int UCP_MEM_MAP_PROT_LOCAL_WRITE() {
        return UCP_MEM_MAP_PROT_LOCAL_WRITE;
    }
    private static final int UCP_MEM_MAP_PROT_REMOTE_READ = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_MEM_MAP_PROT_REMOTE_READ = 256
     * }
     */
    public static int UCP_MEM_MAP_PROT_REMOTE_READ() {
        return UCP_MEM_MAP_PROT_REMOTE_READ;
    }
    private static final int UCP_MEM_MAP_PROT_REMOTE_WRITE = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_MEM_MAP_PROT_REMOTE_WRITE = 512
     * }
     */
    public static int UCP_MEM_MAP_PROT_REMOTE_WRITE() {
        return UCP_MEM_MAP_PROT_REMOTE_WRITE;
    }
    private static final int UCP_AM_FLAG_WHOLE_MSG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_am_cb_flags.UCP_AM_FLAG_WHOLE_MSG = 1
     * }
     */
    public static int UCP_AM_FLAG_WHOLE_MSG() {
        return UCP_AM_FLAG_WHOLE_MSG;
    }
    private static final int UCP_AM_FLAG_PERSISTENT_DATA = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_am_cb_flags.UCP_AM_FLAG_PERSISTENT_DATA = 2
     * }
     */
    public static int UCP_AM_FLAG_PERSISTENT_DATA() {
        return UCP_AM_FLAG_PERSISTENT_DATA;
    }
    private static final int UCP_AM_SEND_FLAG_REPLY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_send_am_flags.UCP_AM_SEND_FLAG_REPLY = 1
     * }
     */
    public static int UCP_AM_SEND_FLAG_REPLY() {
        return UCP_AM_SEND_FLAG_REPLY;
    }
    private static final int UCP_AM_SEND_FLAG_EAGER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_send_am_flags.UCP_AM_SEND_FLAG_EAGER = 2
     * }
     */
    public static int UCP_AM_SEND_FLAG_EAGER() {
        return UCP_AM_SEND_FLAG_EAGER;
    }
    private static final int UCP_AM_SEND_FLAG_RNDV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_send_am_flags.UCP_AM_SEND_FLAG_RNDV = 4
     * }
     */
    public static int UCP_AM_SEND_FLAG_RNDV() {
        return UCP_AM_SEND_FLAG_RNDV;
    }
    private static final int UCP_AM_SEND_FLAG_COPY_HEADER = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucp_send_am_flags.UCP_AM_SEND_FLAG_COPY_HEADER = 8
     * }
     */
    public static int UCP_AM_SEND_FLAG_COPY_HEADER() {
        return UCP_AM_SEND_FLAG_COPY_HEADER;
    }
    private static final int UCP_AM_SEND_REPLY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_send_am_flags.UCP_AM_SEND_REPLY = 1
     * }
     */
    public static int UCP_AM_SEND_REPLY() {
        return UCP_AM_SEND_REPLY;
    }
    private static final int UCP_CB_PARAM_FLAG_DATA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_cb_param_flags.UCP_CB_PARAM_FLAG_DATA = 1
     * }
     */
    public static int UCP_CB_PARAM_FLAG_DATA() {
        return UCP_CB_PARAM_FLAG_DATA;
    }
    private static final int UCP_ATOMIC_OP_ADD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_OP_ADD = 0
     * }
     */
    public static int UCP_ATOMIC_OP_ADD() {
        return UCP_ATOMIC_OP_ADD;
    }
    private static final int UCP_ATOMIC_OP_SWAP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_OP_SWAP = 1
     * }
     */
    public static int UCP_ATOMIC_OP_SWAP() {
        return UCP_ATOMIC_OP_SWAP;
    }
    private static final int UCP_ATOMIC_OP_CSWAP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_OP_CSWAP = 2
     * }
     */
    public static int UCP_ATOMIC_OP_CSWAP() {
        return UCP_ATOMIC_OP_CSWAP;
    }
    private static final int UCP_ATOMIC_OP_AND = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_OP_AND = 3
     * }
     */
    public static int UCP_ATOMIC_OP_AND() {
        return UCP_ATOMIC_OP_AND;
    }
    private static final int UCP_ATOMIC_OP_OR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_OP_OR = 4
     * }
     */
    public static int UCP_ATOMIC_OP_OR() {
        return UCP_ATOMIC_OP_OR;
    }
    private static final int UCP_ATOMIC_OP_XOR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_OP_XOR = 5
     * }
     */
    public static int UCP_ATOMIC_OP_XOR() {
        return UCP_ATOMIC_OP_XOR;
    }
    private static final int UCP_ATOMIC_OP_LAST = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_ATOMIC_OP_LAST = 6
     * }
     */
    public static int UCP_ATOMIC_OP_LAST() {
        return UCP_ATOMIC_OP_LAST;
    }
    private static final int UCP_STREAM_RECV_FLAG_WAITALL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_STREAM_RECV_FLAG_WAITALL = 1
     * }
     */
    public static int UCP_STREAM_RECV_FLAG_WAITALL() {
        return UCP_STREAM_RECV_FLAG_WAITALL;
    }
    private static final int UCP_OP_ATTR_FIELD_REQUEST = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_OP_ATTR_FIELD_REQUEST = 1
     * }
     */
    public static int UCP_OP_ATTR_FIELD_REQUEST() {
        return UCP_OP_ATTR_FIELD_REQUEST;
    }
    private static final int UCP_OP_ATTR_FIELD_CALLBACK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_OP_ATTR_FIELD_CALLBACK = 2
     * }
     */
    public static int UCP_OP_ATTR_FIELD_CALLBACK() {
        return UCP_OP_ATTR_FIELD_CALLBACK;
    }
    private static final int UCP_OP_ATTR_FIELD_USER_DATA = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_OP_ATTR_FIELD_USER_DATA = 4
     * }
     */
    public static int UCP_OP_ATTR_FIELD_USER_DATA() {
        return UCP_OP_ATTR_FIELD_USER_DATA;
    }
    private static final int UCP_OP_ATTR_FIELD_DATATYPE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_OP_ATTR_FIELD_DATATYPE = 8
     * }
     */
    public static int UCP_OP_ATTR_FIELD_DATATYPE() {
        return UCP_OP_ATTR_FIELD_DATATYPE;
    }
    private static final int UCP_OP_ATTR_FIELD_FLAGS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_OP_ATTR_FIELD_FLAGS = 16
     * }
     */
    public static int UCP_OP_ATTR_FIELD_FLAGS() {
        return UCP_OP_ATTR_FIELD_FLAGS;
    }
    private static final int UCP_OP_ATTR_FIELD_REPLY_BUFFER = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_OP_ATTR_FIELD_REPLY_BUFFER = 32
     * }
     */
    public static int UCP_OP_ATTR_FIELD_REPLY_BUFFER() {
        return UCP_OP_ATTR_FIELD_REPLY_BUFFER;
    }
    private static final int UCP_OP_ATTR_FIELD_MEMORY_TYPE = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_OP_ATTR_FIELD_MEMORY_TYPE = 64
     * }
     */
    public static int UCP_OP_ATTR_FIELD_MEMORY_TYPE() {
        return UCP_OP_ATTR_FIELD_MEMORY_TYPE;
    }
    private static final int UCP_OP_ATTR_FIELD_RECV_INFO = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_OP_ATTR_FIELD_RECV_INFO = 128
     * }
     */
    public static int UCP_OP_ATTR_FIELD_RECV_INFO() {
        return UCP_OP_ATTR_FIELD_RECV_INFO;
    }
    private static final int UCP_OP_ATTR_FIELD_MEMH = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_OP_ATTR_FIELD_MEMH = 256
     * }
     */
    public static int UCP_OP_ATTR_FIELD_MEMH() {
        return UCP_OP_ATTR_FIELD_MEMH;
    }
    private static final int UCP_OP_ATTR_FLAG_NO_IMM_CMPL = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_OP_ATTR_FLAG_NO_IMM_CMPL = 65536
     * }
     */
    public static int UCP_OP_ATTR_FLAG_NO_IMM_CMPL() {
        return UCP_OP_ATTR_FLAG_NO_IMM_CMPL;
    }
    private static final int UCP_OP_ATTR_FLAG_FAST_CMPL = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_OP_ATTR_FLAG_FAST_CMPL = 131072
     * }
     */
    public static int UCP_OP_ATTR_FLAG_FAST_CMPL() {
        return UCP_OP_ATTR_FLAG_FAST_CMPL;
    }
    private static final int UCP_OP_ATTR_FLAG_FORCE_IMM_CMPL = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_OP_ATTR_FLAG_FORCE_IMM_CMPL = 262144
     * }
     */
    public static int UCP_OP_ATTR_FLAG_FORCE_IMM_CMPL() {
        return UCP_OP_ATTR_FLAG_FORCE_IMM_CMPL;
    }
    private static final int UCP_OP_ATTR_FLAG_MULTI_SEND = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_OP_ATTR_FLAG_MULTI_SEND = 524288
     * }
     */
    public static int UCP_OP_ATTR_FLAG_MULTI_SEND() {
        return UCP_OP_ATTR_FLAG_MULTI_SEND;
    }
    private static final int UCP_REQUEST_ATTR_FIELD_INFO_STRING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_REQUEST_ATTR_FIELD_INFO_STRING = 1
     * }
     */
    public static int UCP_REQUEST_ATTR_FIELD_INFO_STRING() {
        return UCP_REQUEST_ATTR_FIELD_INFO_STRING;
    }
    private static final int UCP_REQUEST_ATTR_FIELD_INFO_STRING_SIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_REQUEST_ATTR_FIELD_INFO_STRING_SIZE = 2
     * }
     */
    public static int UCP_REQUEST_ATTR_FIELD_INFO_STRING_SIZE() {
        return UCP_REQUEST_ATTR_FIELD_INFO_STRING_SIZE;
    }
    private static final int UCP_REQUEST_ATTR_FIELD_STATUS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_REQUEST_ATTR_FIELD_STATUS = 4
     * }
     */
    public static int UCP_REQUEST_ATTR_FIELD_STATUS() {
        return UCP_REQUEST_ATTR_FIELD_STATUS;
    }
    private static final int UCP_REQUEST_ATTR_FIELD_MEM_TYPE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_REQUEST_ATTR_FIELD_MEM_TYPE = 8
     * }
     */
    public static int UCP_REQUEST_ATTR_FIELD_MEM_TYPE() {
        return UCP_REQUEST_ATTR_FIELD_MEM_TYPE;
    }
    private static final int UCP_AM_RECV_ATTR_FIELD_REPLY_EP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_AM_RECV_ATTR_FIELD_REPLY_EP = 1
     * }
     */
    public static int UCP_AM_RECV_ATTR_FIELD_REPLY_EP() {
        return UCP_AM_RECV_ATTR_FIELD_REPLY_EP;
    }
    private static final int UCP_AM_RECV_ATTR_FLAG_DATA = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_AM_RECV_ATTR_FLAG_DATA = 65536
     * }
     */
    public static int UCP_AM_RECV_ATTR_FLAG_DATA() {
        return UCP_AM_RECV_ATTR_FLAG_DATA;
    }
    private static final int UCP_AM_RECV_ATTR_FLAG_RNDV = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCP_AM_RECV_ATTR_FLAG_RNDV = 131072
     * }
     */
    public static int UCP_AM_RECV_ATTR_FLAG_RNDV() {
        return UCP_AM_RECV_ATTR_FLAG_RNDV;
    }
    private static final int UCP_AM_HANDLER_PARAM_FIELD_ID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_am_handler_param_field.UCP_AM_HANDLER_PARAM_FIELD_ID = 1
     * }
     */
    public static int UCP_AM_HANDLER_PARAM_FIELD_ID() {
        return UCP_AM_HANDLER_PARAM_FIELD_ID;
    }
    private static final int UCP_AM_HANDLER_PARAM_FIELD_FLAGS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_am_handler_param_field.UCP_AM_HANDLER_PARAM_FIELD_FLAGS = 2
     * }
     */
    public static int UCP_AM_HANDLER_PARAM_FIELD_FLAGS() {
        return UCP_AM_HANDLER_PARAM_FIELD_FLAGS;
    }
    private static final int UCP_AM_HANDLER_PARAM_FIELD_CB = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_am_handler_param_field.UCP_AM_HANDLER_PARAM_FIELD_CB = 4
     * }
     */
    public static int UCP_AM_HANDLER_PARAM_FIELD_CB() {
        return UCP_AM_HANDLER_PARAM_FIELD_CB;
    }
    private static final int UCP_AM_HANDLER_PARAM_FIELD_ARG = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucp_am_handler_param_field.UCP_AM_HANDLER_PARAM_FIELD_ARG = 8
     * }
     */
    public static int UCP_AM_HANDLER_PARAM_FIELD_ARG() {
        return UCP_AM_HANDLER_PARAM_FIELD_ARG;
    }

    private static class ucp_lib_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_lib_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_lib_query(ucp_lib_attr_t *attr)
     * }
     */
    public static FunctionDescriptor ucp_lib_query$descriptor() {
        return ucp_lib_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_lib_query(ucp_lib_attr_t *attr)
     * }
     */
    public static MethodHandle ucp_lib_query$handle() {
        return ucp_lib_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_lib_query(ucp_lib_attr_t *attr)
     * }
     */
    public static MemorySegment ucp_lib_query$address() {
        return ucp_lib_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_lib_query(ucp_lib_attr_t *attr)
     * }
     */
    public static int ucp_lib_query(MemorySegment attr) {
        var mh$ = ucp_lib_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_lib_query", attr);
            }
            return (int)mh$.invokeExact(attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_config_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_config_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_config_read(const char *env_prefix, const char *filename, ucp_config_t **config_p)
     * }
     */
    public static FunctionDescriptor ucp_config_read$descriptor() {
        return ucp_config_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_config_read(const char *env_prefix, const char *filename, ucp_config_t **config_p)
     * }
     */
    public static MethodHandle ucp_config_read$handle() {
        return ucp_config_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_config_read(const char *env_prefix, const char *filename, ucp_config_t **config_p)
     * }
     */
    public static MemorySegment ucp_config_read$address() {
        return ucp_config_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_config_read(const char *env_prefix, const char *filename, ucp_config_t **config_p)
     * }
     */
    public static int ucp_config_read(MemorySegment env_prefix, MemorySegment filename, MemorySegment config_p) {
        var mh$ = ucp_config_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_config_read", env_prefix, filename, config_p);
            }
            return (int)mh$.invokeExact(env_prefix, filename, config_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_config_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_config_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_config_release(ucp_config_t *config)
     * }
     */
    public static FunctionDescriptor ucp_config_release$descriptor() {
        return ucp_config_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_config_release(ucp_config_t *config)
     * }
     */
    public static MethodHandle ucp_config_release$handle() {
        return ucp_config_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_config_release(ucp_config_t *config)
     * }
     */
    public static MemorySegment ucp_config_release$address() {
        return ucp_config_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_config_release(ucp_config_t *config)
     * }
     */
    public static void ucp_config_release(MemorySegment config) {
        var mh$ = ucp_config_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_config_release", config);
            }
            mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_config_modify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_config_modify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_config_modify(ucp_config_t *config, const char *name, const char *value)
     * }
     */
    public static FunctionDescriptor ucp_config_modify$descriptor() {
        return ucp_config_modify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_config_modify(ucp_config_t *config, const char *name, const char *value)
     * }
     */
    public static MethodHandle ucp_config_modify$handle() {
        return ucp_config_modify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_config_modify(ucp_config_t *config, const char *name, const char *value)
     * }
     */
    public static MemorySegment ucp_config_modify$address() {
        return ucp_config_modify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_config_modify(ucp_config_t *config, const char *name, const char *value)
     * }
     */
    public static int ucp_config_modify(MemorySegment config, MemorySegment name, MemorySegment value) {
        var mh$ = ucp_config_modify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_config_modify", config, name, value);
            }
            return (int)mh$.invokeExact(config, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_config_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_config_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_config_print(const ucp_config_t *config, FILE *stream, const char *title, ucs_config_print_flags_t print_flags)
     * }
     */
    public static FunctionDescriptor ucp_config_print$descriptor() {
        return ucp_config_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_config_print(const ucp_config_t *config, FILE *stream, const char *title, ucs_config_print_flags_t print_flags)
     * }
     */
    public static MethodHandle ucp_config_print$handle() {
        return ucp_config_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_config_print(const ucp_config_t *config, FILE *stream, const char *title, ucs_config_print_flags_t print_flags)
     * }
     */
    public static MemorySegment ucp_config_print$address() {
        return ucp_config_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_config_print(const ucp_config_t *config, FILE *stream, const char *title, ucs_config_print_flags_t print_flags)
     * }
     */
    public static void ucp_config_print(MemorySegment config, MemorySegment stream, MemorySegment title, int print_flags) {
        var mh$ = ucp_config_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_config_print", config, stream, title, print_flags);
            }
            mh$.invokeExact(config, stream, title, print_flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_get_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_get_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_get_version(unsigned int *major_version, unsigned int *minor_version, unsigned int *release_number)
     * }
     */
    public static FunctionDescriptor ucp_get_version$descriptor() {
        return ucp_get_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_get_version(unsigned int *major_version, unsigned int *minor_version, unsigned int *release_number)
     * }
     */
    public static MethodHandle ucp_get_version$handle() {
        return ucp_get_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_get_version(unsigned int *major_version, unsigned int *minor_version, unsigned int *release_number)
     * }
     */
    public static MemorySegment ucp_get_version$address() {
        return ucp_get_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_get_version(unsigned int *major_version, unsigned int *minor_version, unsigned int *release_number)
     * }
     */
    public static void ucp_get_version(MemorySegment major_version, MemorySegment minor_version, MemorySegment release_number) {
        var mh$ = ucp_get_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_get_version", major_version, minor_version, release_number);
            }
            mh$.invokeExact(major_version, minor_version, release_number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_get_version_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER    );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_get_version_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ucp_get_version_string()
     * }
     */
    public static FunctionDescriptor ucp_get_version_string$descriptor() {
        return ucp_get_version_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ucp_get_version_string()
     * }
     */
    public static MethodHandle ucp_get_version_string$handle() {
        return ucp_get_version_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ucp_get_version_string()
     * }
     */
    public static MemorySegment ucp_get_version_string$address() {
        return ucp_get_version_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ucp_get_version_string()
     * }
     */
    public static MemorySegment ucp_get_version_string() {
        var mh$ = ucp_get_version_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_get_version_string");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_init_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_init_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_init_version(unsigned int api_major_version, unsigned int api_minor_version, const ucp_params_t *params, const ucp_config_t *config, ucp_context_h *context_p)
     * }
     */
    public static FunctionDescriptor ucp_init_version$descriptor() {
        return ucp_init_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_init_version(unsigned int api_major_version, unsigned int api_minor_version, const ucp_params_t *params, const ucp_config_t *config, ucp_context_h *context_p)
     * }
     */
    public static MethodHandle ucp_init_version$handle() {
        return ucp_init_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_init_version(unsigned int api_major_version, unsigned int api_minor_version, const ucp_params_t *params, const ucp_config_t *config, ucp_context_h *context_p)
     * }
     */
    public static MemorySegment ucp_init_version$address() {
        return ucp_init_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_init_version(unsigned int api_major_version, unsigned int api_minor_version, const ucp_params_t *params, const ucp_config_t *config, ucp_context_h *context_p)
     * }
     */
    public static int ucp_init_version(int api_major_version, int api_minor_version, MemorySegment params, MemorySegment config, MemorySegment context_p) {
        var mh$ = ucp_init_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_init_version", api_major_version, api_minor_version, params, config, context_p);
            }
            return (int)mh$.invokeExact(api_major_version, api_minor_version, params, config, context_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_cleanup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_cleanup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_cleanup(ucp_context_h context_p)
     * }
     */
    public static FunctionDescriptor ucp_cleanup$descriptor() {
        return ucp_cleanup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_cleanup(ucp_context_h context_p)
     * }
     */
    public static MethodHandle ucp_cleanup$handle() {
        return ucp_cleanup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_cleanup(ucp_context_h context_p)
     * }
     */
    public static MemorySegment ucp_cleanup$address() {
        return ucp_cleanup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_cleanup(ucp_context_h context_p)
     * }
     */
    public static void ucp_cleanup(MemorySegment context_p) {
        var mh$ = ucp_cleanup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_cleanup", context_p);
            }
            mh$.invokeExact(context_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_context_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_context_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_context_query(ucp_context_h context_p, ucp_context_attr_t *attr)
     * }
     */
    public static FunctionDescriptor ucp_context_query$descriptor() {
        return ucp_context_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_context_query(ucp_context_h context_p, ucp_context_attr_t *attr)
     * }
     */
    public static MethodHandle ucp_context_query$handle() {
        return ucp_context_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_context_query(ucp_context_h context_p, ucp_context_attr_t *attr)
     * }
     */
    public static MemorySegment ucp_context_query$address() {
        return ucp_context_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_context_query(ucp_context_h context_p, ucp_context_attr_t *attr)
     * }
     */
    public static int ucp_context_query(MemorySegment context_p, MemorySegment attr) {
        var mh$ = ucp_context_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_context_query", context_p, attr);
            }
            return (int)mh$.invokeExact(context_p, attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_rkey_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_rkey_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_rkey_compare(ucp_worker_h worker, ucp_rkey_h rkey1, ucp_rkey_h rkey2, const ucp_rkey_compare_params_t *params, int *result)
     * }
     */
    public static FunctionDescriptor ucp_rkey_compare$descriptor() {
        return ucp_rkey_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_rkey_compare(ucp_worker_h worker, ucp_rkey_h rkey1, ucp_rkey_h rkey2, const ucp_rkey_compare_params_t *params, int *result)
     * }
     */
    public static MethodHandle ucp_rkey_compare$handle() {
        return ucp_rkey_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_rkey_compare(ucp_worker_h worker, ucp_rkey_h rkey1, ucp_rkey_h rkey2, const ucp_rkey_compare_params_t *params, int *result)
     * }
     */
    public static MemorySegment ucp_rkey_compare$address() {
        return ucp_rkey_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_rkey_compare(ucp_worker_h worker, ucp_rkey_h rkey1, ucp_rkey_h rkey2, const ucp_rkey_compare_params_t *params, int *result)
     * }
     */
    public static int ucp_rkey_compare(MemorySegment worker, MemorySegment rkey1, MemorySegment rkey2, MemorySegment params, MemorySegment result) {
        var mh$ = ucp_rkey_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_rkey_compare", worker, rkey1, rkey2, params, result);
            }
            return (int)mh$.invokeExact(worker, rkey1, rkey2, params, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_context_print_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_context_print_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_context_print_info(const ucp_context_h context, FILE *stream)
     * }
     */
    public static FunctionDescriptor ucp_context_print_info$descriptor() {
        return ucp_context_print_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_context_print_info(const ucp_context_h context, FILE *stream)
     * }
     */
    public static MethodHandle ucp_context_print_info$handle() {
        return ucp_context_print_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_context_print_info(const ucp_context_h context, FILE *stream)
     * }
     */
    public static MemorySegment ucp_context_print_info$address() {
        return ucp_context_print_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_context_print_info(const ucp_context_h context, FILE *stream)
     * }
     */
    public static void ucp_context_print_info(MemorySegment context, MemorySegment stream) {
        var mh$ = ucp_context_print_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_context_print_info", context, stream);
            }
            mh$.invokeExact(context, stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_create(ucp_context_h context, const ucp_worker_params_t *params, ucp_worker_h *worker_p)
     * }
     */
    public static FunctionDescriptor ucp_worker_create$descriptor() {
        return ucp_worker_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_create(ucp_context_h context, const ucp_worker_params_t *params, ucp_worker_h *worker_p)
     * }
     */
    public static MethodHandle ucp_worker_create$handle() {
        return ucp_worker_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_create(ucp_context_h context, const ucp_worker_params_t *params, ucp_worker_h *worker_p)
     * }
     */
    public static MemorySegment ucp_worker_create$address() {
        return ucp_worker_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_create(ucp_context_h context, const ucp_worker_params_t *params, ucp_worker_h *worker_p)
     * }
     */
    public static int ucp_worker_create(MemorySegment context, MemorySegment params, MemorySegment worker_p) {
        var mh$ = ucp_worker_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_create", context, params, worker_p);
            }
            return (int)mh$.invokeExact(context, params, worker_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_worker_destroy(ucp_worker_h worker)
     * }
     */
    public static FunctionDescriptor ucp_worker_destroy$descriptor() {
        return ucp_worker_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_worker_destroy(ucp_worker_h worker)
     * }
     */
    public static MethodHandle ucp_worker_destroy$handle() {
        return ucp_worker_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_worker_destroy(ucp_worker_h worker)
     * }
     */
    public static MemorySegment ucp_worker_destroy$address() {
        return ucp_worker_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_worker_destroy(ucp_worker_h worker)
     * }
     */
    public static void ucp_worker_destroy(MemorySegment worker) {
        var mh$ = ucp_worker_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_destroy", worker);
            }
            mh$.invokeExact(worker);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_query(ucp_worker_h worker, ucp_worker_attr_t *attr)
     * }
     */
    public static FunctionDescriptor ucp_worker_query$descriptor() {
        return ucp_worker_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_query(ucp_worker_h worker, ucp_worker_attr_t *attr)
     * }
     */
    public static MethodHandle ucp_worker_query$handle() {
        return ucp_worker_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_query(ucp_worker_h worker, ucp_worker_attr_t *attr)
     * }
     */
    public static MemorySegment ucp_worker_query$address() {
        return ucp_worker_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_query(ucp_worker_h worker, ucp_worker_attr_t *attr)
     * }
     */
    public static int ucp_worker_query(MemorySegment worker, MemorySegment attr) {
        var mh$ = ucp_worker_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_query", worker, attr);
            }
            return (int)mh$.invokeExact(worker, attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_print_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_print_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_worker_print_info(ucp_worker_h worker, FILE *stream)
     * }
     */
    public static FunctionDescriptor ucp_worker_print_info$descriptor() {
        return ucp_worker_print_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_worker_print_info(ucp_worker_h worker, FILE *stream)
     * }
     */
    public static MethodHandle ucp_worker_print_info$handle() {
        return ucp_worker_print_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_worker_print_info(ucp_worker_h worker, FILE *stream)
     * }
     */
    public static MemorySegment ucp_worker_print_info$address() {
        return ucp_worker_print_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_worker_print_info(ucp_worker_h worker, FILE *stream)
     * }
     */
    public static void ucp_worker_print_info(MemorySegment worker, MemorySegment stream) {
        var mh$ = ucp_worker_print_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_print_info", worker, stream);
            }
            mh$.invokeExact(worker, stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_release_address {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_release_address");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_worker_release_address(ucp_worker_h worker, ucp_address_t *address)
     * }
     */
    public static FunctionDescriptor ucp_worker_release_address$descriptor() {
        return ucp_worker_release_address.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_worker_release_address(ucp_worker_h worker, ucp_address_t *address)
     * }
     */
    public static MethodHandle ucp_worker_release_address$handle() {
        return ucp_worker_release_address.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_worker_release_address(ucp_worker_h worker, ucp_address_t *address)
     * }
     */
    public static MemorySegment ucp_worker_release_address$address() {
        return ucp_worker_release_address.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_worker_release_address(ucp_worker_h worker, ucp_address_t *address)
     * }
     */
    public static void ucp_worker_release_address(MemorySegment worker, MemorySegment address) {
        var mh$ = ucp_worker_release_address.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_release_address", worker, address);
            }
            mh$.invokeExact(worker, address);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_address_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_address_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_address_query(ucp_address_t *address, ucp_worker_address_attr_t *attr)
     * }
     */
    public static FunctionDescriptor ucp_worker_address_query$descriptor() {
        return ucp_worker_address_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_address_query(ucp_address_t *address, ucp_worker_address_attr_t *attr)
     * }
     */
    public static MethodHandle ucp_worker_address_query$handle() {
        return ucp_worker_address_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_address_query(ucp_address_t *address, ucp_worker_address_attr_t *attr)
     * }
     */
    public static MemorySegment ucp_worker_address_query$address() {
        return ucp_worker_address_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_address_query(ucp_address_t *address, ucp_worker_address_attr_t *attr)
     * }
     */
    public static int ucp_worker_address_query(MemorySegment address, MemorySegment attr) {
        var mh$ = ucp_worker_address_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_address_query", address, attr);
            }
            return (int)mh$.invokeExact(address, attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_progress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_progress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int ucp_worker_progress(ucp_worker_h worker)
     * }
     */
    public static FunctionDescriptor ucp_worker_progress$descriptor() {
        return ucp_worker_progress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int ucp_worker_progress(ucp_worker_h worker)
     * }
     */
    public static MethodHandle ucp_worker_progress$handle() {
        return ucp_worker_progress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int ucp_worker_progress(ucp_worker_h worker)
     * }
     */
    public static MemorySegment ucp_worker_progress$address() {
        return ucp_worker_progress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int ucp_worker_progress(ucp_worker_h worker)
     * }
     */
    public static int ucp_worker_progress(MemorySegment worker) {
        var mh$ = ucp_worker_progress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_progress", worker);
            }
            return (int)mh$.invokeExact(worker);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_stream_worker_poll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_INT
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_stream_worker_poll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t ucp_stream_worker_poll(ucp_worker_h worker, ucp_stream_poll_ep_t *poll_eps, size_t max_eps, unsigned int flags)
     * }
     */
    public static FunctionDescriptor ucp_stream_worker_poll$descriptor() {
        return ucp_stream_worker_poll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t ucp_stream_worker_poll(ucp_worker_h worker, ucp_stream_poll_ep_t *poll_eps, size_t max_eps, unsigned int flags)
     * }
     */
    public static MethodHandle ucp_stream_worker_poll$handle() {
        return ucp_stream_worker_poll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t ucp_stream_worker_poll(ucp_worker_h worker, ucp_stream_poll_ep_t *poll_eps, size_t max_eps, unsigned int flags)
     * }
     */
    public static MemorySegment ucp_stream_worker_poll$address() {
        return ucp_stream_worker_poll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t ucp_stream_worker_poll(ucp_worker_h worker, ucp_stream_poll_ep_t *poll_eps, size_t max_eps, unsigned int flags)
     * }
     */
    public static long ucp_stream_worker_poll(MemorySegment worker, MemorySegment poll_eps, long max_eps, int flags) {
        var mh$ = ucp_stream_worker_poll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_stream_worker_poll", worker, poll_eps, max_eps, flags);
            }
            return (long)mh$.invokeExact(worker, poll_eps, max_eps, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_get_efd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_get_efd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_get_efd(ucp_worker_h worker, int *fd)
     * }
     */
    public static FunctionDescriptor ucp_worker_get_efd$descriptor() {
        return ucp_worker_get_efd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_get_efd(ucp_worker_h worker, int *fd)
     * }
     */
    public static MethodHandle ucp_worker_get_efd$handle() {
        return ucp_worker_get_efd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_get_efd(ucp_worker_h worker, int *fd)
     * }
     */
    public static MemorySegment ucp_worker_get_efd$address() {
        return ucp_worker_get_efd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_get_efd(ucp_worker_h worker, int *fd)
     * }
     */
    public static int ucp_worker_get_efd(MemorySegment worker, MemorySegment fd) {
        var mh$ = ucp_worker_get_efd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_get_efd", worker, fd);
            }
            return (int)mh$.invokeExact(worker, fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_wait(ucp_worker_h worker)
     * }
     */
    public static FunctionDescriptor ucp_worker_wait$descriptor() {
        return ucp_worker_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_wait(ucp_worker_h worker)
     * }
     */
    public static MethodHandle ucp_worker_wait$handle() {
        return ucp_worker_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_wait(ucp_worker_h worker)
     * }
     */
    public static MemorySegment ucp_worker_wait$address() {
        return ucp_worker_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_wait(ucp_worker_h worker)
     * }
     */
    public static int ucp_worker_wait(MemorySegment worker) {
        var mh$ = ucp_worker_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_wait", worker);
            }
            return (int)mh$.invokeExact(worker);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_wait_mem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_wait_mem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_worker_wait_mem(ucp_worker_h worker, void *address)
     * }
     */
    public static FunctionDescriptor ucp_worker_wait_mem$descriptor() {
        return ucp_worker_wait_mem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_worker_wait_mem(ucp_worker_h worker, void *address)
     * }
     */
    public static MethodHandle ucp_worker_wait_mem$handle() {
        return ucp_worker_wait_mem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_worker_wait_mem(ucp_worker_h worker, void *address)
     * }
     */
    public static MemorySegment ucp_worker_wait_mem$address() {
        return ucp_worker_wait_mem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_worker_wait_mem(ucp_worker_h worker, void *address)
     * }
     */
    public static void ucp_worker_wait_mem(MemorySegment worker, MemorySegment address) {
        var mh$ = ucp_worker_wait_mem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_wait_mem", worker, address);
            }
            mh$.invokeExact(worker, address);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_arm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_arm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_arm(ucp_worker_h worker)
     * }
     */
    public static FunctionDescriptor ucp_worker_arm$descriptor() {
        return ucp_worker_arm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_arm(ucp_worker_h worker)
     * }
     */
    public static MethodHandle ucp_worker_arm$handle() {
        return ucp_worker_arm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_arm(ucp_worker_h worker)
     * }
     */
    public static MemorySegment ucp_worker_arm$address() {
        return ucp_worker_arm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_arm(ucp_worker_h worker)
     * }
     */
    public static int ucp_worker_arm(MemorySegment worker) {
        var mh$ = ucp_worker_arm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_arm", worker);
            }
            return (int)mh$.invokeExact(worker);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_signal(ucp_worker_h worker)
     * }
     */
    public static FunctionDescriptor ucp_worker_signal$descriptor() {
        return ucp_worker_signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_signal(ucp_worker_h worker)
     * }
     */
    public static MethodHandle ucp_worker_signal$handle() {
        return ucp_worker_signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_signal(ucp_worker_h worker)
     * }
     */
    public static MemorySegment ucp_worker_signal$address() {
        return ucp_worker_signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_signal(ucp_worker_h worker)
     * }
     */
    public static int ucp_worker_signal(MemorySegment worker) {
        var mh$ = ucp_worker_signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_signal", worker);
            }
            return (int)mh$.invokeExact(worker);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_listener_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_listener_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_listener_create(ucp_worker_h worker, const ucp_listener_params_t *params, ucp_listener_h *listener_p)
     * }
     */
    public static FunctionDescriptor ucp_listener_create$descriptor() {
        return ucp_listener_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_listener_create(ucp_worker_h worker, const ucp_listener_params_t *params, ucp_listener_h *listener_p)
     * }
     */
    public static MethodHandle ucp_listener_create$handle() {
        return ucp_listener_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_listener_create(ucp_worker_h worker, const ucp_listener_params_t *params, ucp_listener_h *listener_p)
     * }
     */
    public static MemorySegment ucp_listener_create$address() {
        return ucp_listener_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_listener_create(ucp_worker_h worker, const ucp_listener_params_t *params, ucp_listener_h *listener_p)
     * }
     */
    public static int ucp_listener_create(MemorySegment worker, MemorySegment params, MemorySegment listener_p) {
        var mh$ = ucp_listener_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_listener_create", worker, params, listener_p);
            }
            return (int)mh$.invokeExact(worker, params, listener_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_listener_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_listener_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_listener_destroy(ucp_listener_h listener)
     * }
     */
    public static FunctionDescriptor ucp_listener_destroy$descriptor() {
        return ucp_listener_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_listener_destroy(ucp_listener_h listener)
     * }
     */
    public static MethodHandle ucp_listener_destroy$handle() {
        return ucp_listener_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_listener_destroy(ucp_listener_h listener)
     * }
     */
    public static MemorySegment ucp_listener_destroy$address() {
        return ucp_listener_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_listener_destroy(ucp_listener_h listener)
     * }
     */
    public static void ucp_listener_destroy(MemorySegment listener) {
        var mh$ = ucp_listener_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_listener_destroy", listener);
            }
            mh$.invokeExact(listener);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_listener_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_listener_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_listener_query(ucp_listener_h listener, ucp_listener_attr_t *attr)
     * }
     */
    public static FunctionDescriptor ucp_listener_query$descriptor() {
        return ucp_listener_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_listener_query(ucp_listener_h listener, ucp_listener_attr_t *attr)
     * }
     */
    public static MethodHandle ucp_listener_query$handle() {
        return ucp_listener_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_listener_query(ucp_listener_h listener, ucp_listener_attr_t *attr)
     * }
     */
    public static MemorySegment ucp_listener_query$address() {
        return ucp_listener_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_listener_query(ucp_listener_h listener, ucp_listener_attr_t *attr)
     * }
     */
    public static int ucp_listener_query(MemorySegment listener, MemorySegment attr) {
        var mh$ = ucp_listener_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_listener_query", listener, attr);
            }
            return (int)mh$.invokeExact(listener, attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_conn_request_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_conn_request_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_conn_request_query(ucp_conn_request_h conn_request, ucp_conn_request_attr_t *attr)
     * }
     */
    public static FunctionDescriptor ucp_conn_request_query$descriptor() {
        return ucp_conn_request_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_conn_request_query(ucp_conn_request_h conn_request, ucp_conn_request_attr_t *attr)
     * }
     */
    public static MethodHandle ucp_conn_request_query$handle() {
        return ucp_conn_request_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_conn_request_query(ucp_conn_request_h conn_request, ucp_conn_request_attr_t *attr)
     * }
     */
    public static MemorySegment ucp_conn_request_query$address() {
        return ucp_conn_request_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_conn_request_query(ucp_conn_request_h conn_request, ucp_conn_request_attr_t *attr)
     * }
     */
    public static int ucp_conn_request_query(MemorySegment conn_request, MemorySegment attr) {
        var mh$ = ucp_conn_request_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_conn_request_query", conn_request, attr);
            }
            return (int)mh$.invokeExact(conn_request, attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_request_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_request_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_request_query(void *request, ucp_request_attr_t *attr)
     * }
     */
    public static FunctionDescriptor ucp_request_query$descriptor() {
        return ucp_request_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_request_query(void *request, ucp_request_attr_t *attr)
     * }
     */
    public static MethodHandle ucp_request_query$handle() {
        return ucp_request_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_request_query(void *request, ucp_request_attr_t *attr)
     * }
     */
    public static MemorySegment ucp_request_query$address() {
        return ucp_request_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_request_query(void *request, ucp_request_attr_t *attr)
     * }
     */
    public static int ucp_request_query(MemorySegment request, MemorySegment attr) {
        var mh$ = ucp_request_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_request_query", request, attr);
            }
            return (int)mh$.invokeExact(request, attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_ep_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_ep_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_create(ucp_worker_h worker, const ucp_ep_params_t *params, ucp_ep_h *ep_p)
     * }
     */
    public static FunctionDescriptor ucp_ep_create$descriptor() {
        return ucp_ep_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_create(ucp_worker_h worker, const ucp_ep_params_t *params, ucp_ep_h *ep_p)
     * }
     */
    public static MethodHandle ucp_ep_create$handle() {
        return ucp_ep_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_create(ucp_worker_h worker, const ucp_ep_params_t *params, ucp_ep_h *ep_p)
     * }
     */
    public static MemorySegment ucp_ep_create$address() {
        return ucp_ep_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_create(ucp_worker_h worker, const ucp_ep_params_t *params, ucp_ep_h *ep_p)
     * }
     */
    public static int ucp_ep_create(MemorySegment worker, MemorySegment params, MemorySegment ep_p) {
        var mh$ = ucp_ep_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_ep_create", worker, params, ep_p);
            }
            return (int)mh$.invokeExact(worker, params, ep_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_ep_close_nbx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_ep_close_nbx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_close_nbx(ucp_ep_h ep, const ucp_request_param_t *param)
     * }
     */
    public static FunctionDescriptor ucp_ep_close_nbx$descriptor() {
        return ucp_ep_close_nbx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_close_nbx(ucp_ep_h ep, const ucp_request_param_t *param)
     * }
     */
    public static MethodHandle ucp_ep_close_nbx$handle() {
        return ucp_ep_close_nbx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_close_nbx(ucp_ep_h ep, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_ep_close_nbx$address() {
        return ucp_ep_close_nbx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_close_nbx(ucp_ep_h ep, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_ep_close_nbx(MemorySegment ep, MemorySegment param) {
        var mh$ = ucp_ep_close_nbx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_ep_close_nbx", ep, param);
            }
            return (MemorySegment)mh$.invokeExact(ep, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_listener_reject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_listener_reject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_listener_reject(ucp_listener_h listener, ucp_conn_request_h conn_request)
     * }
     */
    public static FunctionDescriptor ucp_listener_reject$descriptor() {
        return ucp_listener_reject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_listener_reject(ucp_listener_h listener, ucp_conn_request_h conn_request)
     * }
     */
    public static MethodHandle ucp_listener_reject$handle() {
        return ucp_listener_reject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_listener_reject(ucp_listener_h listener, ucp_conn_request_h conn_request)
     * }
     */
    public static MemorySegment ucp_listener_reject$address() {
        return ucp_listener_reject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_listener_reject(ucp_listener_h listener, ucp_conn_request_h conn_request)
     * }
     */
    public static int ucp_listener_reject(MemorySegment listener, MemorySegment conn_request) {
        var mh$ = ucp_listener_reject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_listener_reject", listener, conn_request);
            }
            return (int)mh$.invokeExact(listener, conn_request);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_ep_print_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_ep_print_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_ep_print_info(ucp_ep_h ep, FILE *stream)
     * }
     */
    public static FunctionDescriptor ucp_ep_print_info$descriptor() {
        return ucp_ep_print_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_ep_print_info(ucp_ep_h ep, FILE *stream)
     * }
     */
    public static MethodHandle ucp_ep_print_info$handle() {
        return ucp_ep_print_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_ep_print_info(ucp_ep_h ep, FILE *stream)
     * }
     */
    public static MemorySegment ucp_ep_print_info$address() {
        return ucp_ep_print_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_ep_print_info(ucp_ep_h ep, FILE *stream)
     * }
     */
    public static void ucp_ep_print_info(MemorySegment ep, MemorySegment stream) {
        var mh$ = ucp_ep_print_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_ep_print_info", ep, stream);
            }
            mh$.invokeExact(ep, stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_ep_flush_nbx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_ep_flush_nbx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_flush_nbx(ucp_ep_h ep, const ucp_request_param_t *param)
     * }
     */
    public static FunctionDescriptor ucp_ep_flush_nbx$descriptor() {
        return ucp_ep_flush_nbx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_flush_nbx(ucp_ep_h ep, const ucp_request_param_t *param)
     * }
     */
    public static MethodHandle ucp_ep_flush_nbx$handle() {
        return ucp_ep_flush_nbx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_flush_nbx(ucp_ep_h ep, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_ep_flush_nbx$address() {
        return ucp_ep_flush_nbx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_ep_flush_nbx(ucp_ep_h ep, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_ep_flush_nbx(MemorySegment ep, MemorySegment param) {
        var mh$ = ucp_ep_flush_nbx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_ep_flush_nbx", ep, param);
            }
            return (MemorySegment)mh$.invokeExact(ep, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_ep_evaluate_perf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_ep_evaluate_perf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_evaluate_perf(ucp_ep_h ep, const ucp_ep_evaluate_perf_param_t *param, ucp_ep_evaluate_perf_attr_t *attr)
     * }
     */
    public static FunctionDescriptor ucp_ep_evaluate_perf$descriptor() {
        return ucp_ep_evaluate_perf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_evaluate_perf(ucp_ep_h ep, const ucp_ep_evaluate_perf_param_t *param, ucp_ep_evaluate_perf_attr_t *attr)
     * }
     */
    public static MethodHandle ucp_ep_evaluate_perf$handle() {
        return ucp_ep_evaluate_perf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_evaluate_perf(ucp_ep_h ep, const ucp_ep_evaluate_perf_param_t *param, ucp_ep_evaluate_perf_attr_t *attr)
     * }
     */
    public static MemorySegment ucp_ep_evaluate_perf$address() {
        return ucp_ep_evaluate_perf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_evaluate_perf(ucp_ep_h ep, const ucp_ep_evaluate_perf_param_t *param, ucp_ep_evaluate_perf_attr_t *attr)
     * }
     */
    public static int ucp_ep_evaluate_perf(MemorySegment ep, MemorySegment param, MemorySegment attr) {
        var mh$ = ucp_ep_evaluate_perf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_ep_evaluate_perf", ep, param, attr);
            }
            return (int)mh$.invokeExact(ep, param, attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_mem_map {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_mem_map");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_map(ucp_context_h context, const ucp_mem_map_params_t *params, ucp_mem_h *memh_p)
     * }
     */
    public static FunctionDescriptor ucp_mem_map$descriptor() {
        return ucp_mem_map.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_map(ucp_context_h context, const ucp_mem_map_params_t *params, ucp_mem_h *memh_p)
     * }
     */
    public static MethodHandle ucp_mem_map$handle() {
        return ucp_mem_map.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_map(ucp_context_h context, const ucp_mem_map_params_t *params, ucp_mem_h *memh_p)
     * }
     */
    public static MemorySegment ucp_mem_map$address() {
        return ucp_mem_map.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_map(ucp_context_h context, const ucp_mem_map_params_t *params, ucp_mem_h *memh_p)
     * }
     */
    public static int ucp_mem_map(MemorySegment context, MemorySegment params, MemorySegment memh_p) {
        var mh$ = ucp_mem_map.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_mem_map", context, params, memh_p);
            }
            return (int)mh$.invokeExact(context, params, memh_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_mem_unmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_mem_unmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_unmap(ucp_context_h context, ucp_mem_h memh)
     * }
     */
    public static FunctionDescriptor ucp_mem_unmap$descriptor() {
        return ucp_mem_unmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_unmap(ucp_context_h context, ucp_mem_h memh)
     * }
     */
    public static MethodHandle ucp_mem_unmap$handle() {
        return ucp_mem_unmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_unmap(ucp_context_h context, ucp_mem_h memh)
     * }
     */
    public static MemorySegment ucp_mem_unmap$address() {
        return ucp_mem_unmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_unmap(ucp_context_h context, ucp_mem_h memh)
     * }
     */
    public static int ucp_mem_unmap(MemorySegment context, MemorySegment memh) {
        var mh$ = ucp_mem_unmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_mem_unmap", context, memh);
            }
            return (int)mh$.invokeExact(context, memh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_mem_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_mem_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_query(const ucp_mem_h memh, ucp_mem_attr_t *attr)
     * }
     */
    public static FunctionDescriptor ucp_mem_query$descriptor() {
        return ucp_mem_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_query(const ucp_mem_h memh, ucp_mem_attr_t *attr)
     * }
     */
    public static MethodHandle ucp_mem_query$handle() {
        return ucp_mem_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_query(const ucp_mem_h memh, ucp_mem_attr_t *attr)
     * }
     */
    public static MemorySegment ucp_mem_query$address() {
        return ucp_mem_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_query(const ucp_mem_h memh, ucp_mem_attr_t *attr)
     * }
     */
    public static int ucp_mem_query(MemorySegment memh, MemorySegment attr) {
        var mh$ = ucp_mem_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_mem_query", memh, attr);
            }
            return (int)mh$.invokeExact(memh, attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_mem_print_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_mem_print_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_mem_print_info(const char *mem_spec, ucp_context_h context, FILE *stream)
     * }
     */
    public static FunctionDescriptor ucp_mem_print_info$descriptor() {
        return ucp_mem_print_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_mem_print_info(const char *mem_spec, ucp_context_h context, FILE *stream)
     * }
     */
    public static MethodHandle ucp_mem_print_info$handle() {
        return ucp_mem_print_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_mem_print_info(const char *mem_spec, ucp_context_h context, FILE *stream)
     * }
     */
    public static MemorySegment ucp_mem_print_info$address() {
        return ucp_mem_print_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_mem_print_info(const char *mem_spec, ucp_context_h context, FILE *stream)
     * }
     */
    public static void ucp_mem_print_info(MemorySegment mem_spec, MemorySegment context, MemorySegment stream) {
        var mh$ = ucp_mem_print_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_mem_print_info", mem_spec, context, stream);
            }
            mh$.invokeExact(mem_spec, context, stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UCP_MADV_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ucp_mem_advice.UCP_MADV_NORMAL = 0
     * }
     */
    public static int UCP_MADV_NORMAL() {
        return UCP_MADV_NORMAL;
    }
    private static final int UCP_MADV_WILLNEED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_mem_advice.UCP_MADV_WILLNEED = 1
     * }
     */
    public static int UCP_MADV_WILLNEED() {
        return UCP_MADV_WILLNEED;
    }

    private static class ucp_mem_advise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_mem_advise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_advise(ucp_context_h context, ucp_mem_h memh, ucp_mem_advise_params_t *params)
     * }
     */
    public static FunctionDescriptor ucp_mem_advise$descriptor() {
        return ucp_mem_advise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_advise(ucp_context_h context, ucp_mem_h memh, ucp_mem_advise_params_t *params)
     * }
     */
    public static MethodHandle ucp_mem_advise$handle() {
        return ucp_mem_advise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_advise(ucp_context_h context, ucp_mem_h memh, ucp_mem_advise_params_t *params)
     * }
     */
    public static MemorySegment ucp_mem_advise$address() {
        return ucp_mem_advise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_mem_advise(ucp_context_h context, ucp_mem_h memh, ucp_mem_advise_params_t *params)
     * }
     */
    public static int ucp_mem_advise(MemorySegment context, MemorySegment memh, MemorySegment params) {
        var mh$ = ucp_mem_advise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_mem_advise", context, memh, params);
            }
            return (int)mh$.invokeExact(context, memh, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UCP_MEMH_PACK_PARAM_FIELD_FLAGS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_memh_pack_params_field.UCP_MEMH_PACK_PARAM_FIELD_FLAGS = 1
     * }
     */
    public static int UCP_MEMH_PACK_PARAM_FIELD_FLAGS() {
        return UCP_MEMH_PACK_PARAM_FIELD_FLAGS;
    }
    private static final int UCP_MEMH_PACK_FLAG_EXPORT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_memh_pack_flags.UCP_MEMH_PACK_FLAG_EXPORT = 1
     * }
     */
    public static int UCP_MEMH_PACK_FLAG_EXPORT() {
        return UCP_MEMH_PACK_FLAG_EXPORT;
    }

    private static class ucp_memh_pack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_memh_pack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_memh_pack(ucp_mem_h memh, const ucp_memh_pack_params_t *params, void **buffer_p, size_t *buffer_size_p)
     * }
     */
    public static FunctionDescriptor ucp_memh_pack$descriptor() {
        return ucp_memh_pack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_memh_pack(ucp_mem_h memh, const ucp_memh_pack_params_t *params, void **buffer_p, size_t *buffer_size_p)
     * }
     */
    public static MethodHandle ucp_memh_pack$handle() {
        return ucp_memh_pack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_memh_pack(ucp_mem_h memh, const ucp_memh_pack_params_t *params, void **buffer_p, size_t *buffer_size_p)
     * }
     */
    public static MemorySegment ucp_memh_pack$address() {
        return ucp_memh_pack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_memh_pack(ucp_mem_h memh, const ucp_memh_pack_params_t *params, void **buffer_p, size_t *buffer_size_p)
     * }
     */
    public static int ucp_memh_pack(MemorySegment memh, MemorySegment params, MemorySegment buffer_p, MemorySegment buffer_size_p) {
        var mh$ = ucp_memh_pack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_memh_pack", memh, params, buffer_p, buffer_size_p);
            }
            return (int)mh$.invokeExact(memh, params, buffer_p, buffer_size_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_memh_buffer_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_memh_buffer_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_memh_buffer_release(void *buffer, const ucp_memh_buffer_release_params_t *params)
     * }
     */
    public static FunctionDescriptor ucp_memh_buffer_release$descriptor() {
        return ucp_memh_buffer_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_memh_buffer_release(void *buffer, const ucp_memh_buffer_release_params_t *params)
     * }
     */
    public static MethodHandle ucp_memh_buffer_release$handle() {
        return ucp_memh_buffer_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_memh_buffer_release(void *buffer, const ucp_memh_buffer_release_params_t *params)
     * }
     */
    public static MemorySegment ucp_memh_buffer_release$address() {
        return ucp_memh_buffer_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_memh_buffer_release(void *buffer, const ucp_memh_buffer_release_params_t *params)
     * }
     */
    public static void ucp_memh_buffer_release(MemorySegment buffer, MemorySegment params) {
        var mh$ = ucp_memh_buffer_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_memh_buffer_release", buffer, params);
            }
            mh$.invokeExact(buffer, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_ep_rkey_unpack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_ep_rkey_unpack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_rkey_unpack(ucp_ep_h ep, const void *rkey_buffer, ucp_rkey_h *rkey_p)
     * }
     */
    public static FunctionDescriptor ucp_ep_rkey_unpack$descriptor() {
        return ucp_ep_rkey_unpack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_rkey_unpack(ucp_ep_h ep, const void *rkey_buffer, ucp_rkey_h *rkey_p)
     * }
     */
    public static MethodHandle ucp_ep_rkey_unpack$handle() {
        return ucp_ep_rkey_unpack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_rkey_unpack(ucp_ep_h ep, const void *rkey_buffer, ucp_rkey_h *rkey_p)
     * }
     */
    public static MemorySegment ucp_ep_rkey_unpack$address() {
        return ucp_ep_rkey_unpack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_rkey_unpack(ucp_ep_h ep, const void *rkey_buffer, ucp_rkey_h *rkey_p)
     * }
     */
    public static int ucp_ep_rkey_unpack(MemorySegment ep, MemorySegment rkey_buffer, MemorySegment rkey_p) {
        var mh$ = ucp_ep_rkey_unpack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_ep_rkey_unpack", ep, rkey_buffer, rkey_p);
            }
            return (int)mh$.invokeExact(ep, rkey_buffer, rkey_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_rkey_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_rkey_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_rkey_ptr(ucp_rkey_h rkey, uint64_t raddr, void **addr_p)
     * }
     */
    public static FunctionDescriptor ucp_rkey_ptr$descriptor() {
        return ucp_rkey_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_rkey_ptr(ucp_rkey_h rkey, uint64_t raddr, void **addr_p)
     * }
     */
    public static MethodHandle ucp_rkey_ptr$handle() {
        return ucp_rkey_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_rkey_ptr(ucp_rkey_h rkey, uint64_t raddr, void **addr_p)
     * }
     */
    public static MemorySegment ucp_rkey_ptr$address() {
        return ucp_rkey_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_rkey_ptr(ucp_rkey_h rkey, uint64_t raddr, void **addr_p)
     * }
     */
    public static int ucp_rkey_ptr(MemorySegment rkey, long raddr, MemorySegment addr_p) {
        var mh$ = ucp_rkey_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_rkey_ptr", rkey, raddr, addr_p);
            }
            return (int)mh$.invokeExact(rkey, raddr, addr_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_rkey_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_rkey_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_rkey_destroy(ucp_rkey_h rkey)
     * }
     */
    public static FunctionDescriptor ucp_rkey_destroy$descriptor() {
        return ucp_rkey_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_rkey_destroy(ucp_rkey_h rkey)
     * }
     */
    public static MethodHandle ucp_rkey_destroy$handle() {
        return ucp_rkey_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_rkey_destroy(ucp_rkey_h rkey)
     * }
     */
    public static MemorySegment ucp_rkey_destroy$address() {
        return ucp_rkey_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_rkey_destroy(ucp_rkey_h rkey)
     * }
     */
    public static void ucp_rkey_destroy(MemorySegment rkey) {
        var mh$ = ucp_rkey_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_rkey_destroy", rkey);
            }
            mh$.invokeExact(rkey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_set_am_recv_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_set_am_recv_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_set_am_recv_handler(ucp_worker_h worker, const ucp_am_handler_param_t *param)
     * }
     */
    public static FunctionDescriptor ucp_worker_set_am_recv_handler$descriptor() {
        return ucp_worker_set_am_recv_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_set_am_recv_handler(ucp_worker_h worker, const ucp_am_handler_param_t *param)
     * }
     */
    public static MethodHandle ucp_worker_set_am_recv_handler$handle() {
        return ucp_worker_set_am_recv_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_set_am_recv_handler(ucp_worker_h worker, const ucp_am_handler_param_t *param)
     * }
     */
    public static MemorySegment ucp_worker_set_am_recv_handler$address() {
        return ucp_worker_set_am_recv_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_set_am_recv_handler(ucp_worker_h worker, const ucp_am_handler_param_t *param)
     * }
     */
    public static int ucp_worker_set_am_recv_handler(MemorySegment worker, MemorySegment param) {
        var mh$ = ucp_worker_set_am_recv_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_set_am_recv_handler", worker, param);
            }
            return (int)mh$.invokeExact(worker, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_am_send_nbx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_am_send_nbx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_am_send_nbx(ucp_ep_h ep, unsigned int id, const void *header, size_t header_length, const void *buffer, size_t count, const ucp_request_param_t *param)
     * }
     */
    public static FunctionDescriptor ucp_am_send_nbx$descriptor() {
        return ucp_am_send_nbx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_am_send_nbx(ucp_ep_h ep, unsigned int id, const void *header, size_t header_length, const void *buffer, size_t count, const ucp_request_param_t *param)
     * }
     */
    public static MethodHandle ucp_am_send_nbx$handle() {
        return ucp_am_send_nbx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_am_send_nbx(ucp_ep_h ep, unsigned int id, const void *header, size_t header_length, const void *buffer, size_t count, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_am_send_nbx$address() {
        return ucp_am_send_nbx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_am_send_nbx(ucp_ep_h ep, unsigned int id, const void *header, size_t header_length, const void *buffer, size_t count, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_am_send_nbx(MemorySegment ep, int id, MemorySegment header, long header_length, MemorySegment buffer, long count, MemorySegment param) {
        var mh$ = ucp_am_send_nbx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_am_send_nbx", ep, id, header, header_length, buffer, count, param);
            }
            return (MemorySegment)mh$.invokeExact(ep, id, header, header_length, buffer, count, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_am_recv_data_nbx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_am_recv_data_nbx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_am_recv_data_nbx(ucp_worker_h worker, void *data_desc, void *buffer, size_t count, const ucp_request_param_t *param)
     * }
     */
    public static FunctionDescriptor ucp_am_recv_data_nbx$descriptor() {
        return ucp_am_recv_data_nbx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_am_recv_data_nbx(ucp_worker_h worker, void *data_desc, void *buffer, size_t count, const ucp_request_param_t *param)
     * }
     */
    public static MethodHandle ucp_am_recv_data_nbx$handle() {
        return ucp_am_recv_data_nbx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_am_recv_data_nbx(ucp_worker_h worker, void *data_desc, void *buffer, size_t count, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_am_recv_data_nbx$address() {
        return ucp_am_recv_data_nbx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_am_recv_data_nbx(ucp_worker_h worker, void *data_desc, void *buffer, size_t count, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_am_recv_data_nbx(MemorySegment worker, MemorySegment data_desc, MemorySegment buffer, long count, MemorySegment param) {
        var mh$ = ucp_am_recv_data_nbx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_am_recv_data_nbx", worker, data_desc, buffer, count, param);
            }
            return (MemorySegment)mh$.invokeExact(worker, data_desc, buffer, count, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_am_data_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_am_data_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_am_data_release(ucp_worker_h worker, void *data)
     * }
     */
    public static FunctionDescriptor ucp_am_data_release$descriptor() {
        return ucp_am_data_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_am_data_release(ucp_worker_h worker, void *data)
     * }
     */
    public static MethodHandle ucp_am_data_release$handle() {
        return ucp_am_data_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_am_data_release(ucp_worker_h worker, void *data)
     * }
     */
    public static MemorySegment ucp_am_data_release$address() {
        return ucp_am_data_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_am_data_release(ucp_worker_h worker, void *data)
     * }
     */
    public static void ucp_am_data_release(MemorySegment worker, MemorySegment data) {
        var mh$ = ucp_am_data_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_am_data_release", worker, data);
            }
            mh$.invokeExact(worker, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_stream_send_nbx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_stream_send_nbx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_send_nbx(ucp_ep_h ep, const void *buffer, size_t count, const ucp_request_param_t *param)
     * }
     */
    public static FunctionDescriptor ucp_stream_send_nbx$descriptor() {
        return ucp_stream_send_nbx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_send_nbx(ucp_ep_h ep, const void *buffer, size_t count, const ucp_request_param_t *param)
     * }
     */
    public static MethodHandle ucp_stream_send_nbx$handle() {
        return ucp_stream_send_nbx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_send_nbx(ucp_ep_h ep, const void *buffer, size_t count, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_stream_send_nbx$address() {
        return ucp_stream_send_nbx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_send_nbx(ucp_ep_h ep, const void *buffer, size_t count, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_stream_send_nbx(MemorySegment ep, MemorySegment buffer, long count, MemorySegment param) {
        var mh$ = ucp_stream_send_nbx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_stream_send_nbx", ep, buffer, count, param);
            }
            return (MemorySegment)mh$.invokeExact(ep, buffer, count, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_tag_send_nbx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_tag_send_nbx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_nbx(ucp_ep_h ep, const void *buffer, size_t count, ucp_tag_t tag, const ucp_request_param_t *param)
     * }
     */
    public static FunctionDescriptor ucp_tag_send_nbx$descriptor() {
        return ucp_tag_send_nbx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_nbx(ucp_ep_h ep, const void *buffer, size_t count, ucp_tag_t tag, const ucp_request_param_t *param)
     * }
     */
    public static MethodHandle ucp_tag_send_nbx$handle() {
        return ucp_tag_send_nbx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_nbx(ucp_ep_h ep, const void *buffer, size_t count, ucp_tag_t tag, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_tag_send_nbx$address() {
        return ucp_tag_send_nbx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_nbx(ucp_ep_h ep, const void *buffer, size_t count, ucp_tag_t tag, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_tag_send_nbx(MemorySegment ep, MemorySegment buffer, long count, long tag, MemorySegment param) {
        var mh$ = ucp_tag_send_nbx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_tag_send_nbx", ep, buffer, count, tag, param);
            }
            return (MemorySegment)mh$.invokeExact(ep, buffer, count, tag, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_tag_send_sync_nbx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_tag_send_sync_nbx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_sync_nbx(ucp_ep_h ep, const void *buffer, size_t count, ucp_tag_t tag, const ucp_request_param_t *param)
     * }
     */
    public static FunctionDescriptor ucp_tag_send_sync_nbx$descriptor() {
        return ucp_tag_send_sync_nbx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_sync_nbx(ucp_ep_h ep, const void *buffer, size_t count, ucp_tag_t tag, const ucp_request_param_t *param)
     * }
     */
    public static MethodHandle ucp_tag_send_sync_nbx$handle() {
        return ucp_tag_send_sync_nbx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_sync_nbx(ucp_ep_h ep, const void *buffer, size_t count, ucp_tag_t tag, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_tag_send_sync_nbx$address() {
        return ucp_tag_send_sync_nbx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_send_sync_nbx(ucp_ep_h ep, const void *buffer, size_t count, ucp_tag_t tag, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_tag_send_sync_nbx(MemorySegment ep, MemorySegment buffer, long count, long tag, MemorySegment param) {
        var mh$ = ucp_tag_send_sync_nbx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_tag_send_sync_nbx", ep, buffer, count, tag, param);
            }
            return (MemorySegment)mh$.invokeExact(ep, buffer, count, tag, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_stream_recv_nbx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_stream_recv_nbx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_recv_nbx(ucp_ep_h ep, void *buffer, size_t count, size_t *length, const ucp_request_param_t *param)
     * }
     */
    public static FunctionDescriptor ucp_stream_recv_nbx$descriptor() {
        return ucp_stream_recv_nbx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_recv_nbx(ucp_ep_h ep, void *buffer, size_t count, size_t *length, const ucp_request_param_t *param)
     * }
     */
    public static MethodHandle ucp_stream_recv_nbx$handle() {
        return ucp_stream_recv_nbx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_recv_nbx(ucp_ep_h ep, void *buffer, size_t count, size_t *length, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_stream_recv_nbx$address() {
        return ucp_stream_recv_nbx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_recv_nbx(ucp_ep_h ep, void *buffer, size_t count, size_t *length, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_stream_recv_nbx(MemorySegment ep, MemorySegment buffer, long count, MemorySegment length, MemorySegment param) {
        var mh$ = ucp_stream_recv_nbx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_stream_recv_nbx", ep, buffer, count, length, param);
            }
            return (MemorySegment)mh$.invokeExact(ep, buffer, count, length, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_stream_recv_data_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_stream_recv_data_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_recv_data_nb(ucp_ep_h ep, size_t *length)
     * }
     */
    public static FunctionDescriptor ucp_stream_recv_data_nb$descriptor() {
        return ucp_stream_recv_data_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_recv_data_nb(ucp_ep_h ep, size_t *length)
     * }
     */
    public static MethodHandle ucp_stream_recv_data_nb$handle() {
        return ucp_stream_recv_data_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_recv_data_nb(ucp_ep_h ep, size_t *length)
     * }
     */
    public static MemorySegment ucp_stream_recv_data_nb$address() {
        return ucp_stream_recv_data_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_stream_recv_data_nb(ucp_ep_h ep, size_t *length)
     * }
     */
    public static MemorySegment ucp_stream_recv_data_nb(MemorySegment ep, MemorySegment length) {
        var mh$ = ucp_stream_recv_data_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_stream_recv_data_nb", ep, length);
            }
            return (MemorySegment)mh$.invokeExact(ep, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_tag_recv_nbx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_tag_recv_nbx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_recv_nbx(ucp_worker_h worker, void *buffer, size_t count, ucp_tag_t tag, ucp_tag_t tag_mask, const ucp_request_param_t *param)
     * }
     */
    public static FunctionDescriptor ucp_tag_recv_nbx$descriptor() {
        return ucp_tag_recv_nbx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_recv_nbx(ucp_worker_h worker, void *buffer, size_t count, ucp_tag_t tag, ucp_tag_t tag_mask, const ucp_request_param_t *param)
     * }
     */
    public static MethodHandle ucp_tag_recv_nbx$handle() {
        return ucp_tag_recv_nbx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_recv_nbx(ucp_worker_h worker, void *buffer, size_t count, ucp_tag_t tag, ucp_tag_t tag_mask, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_tag_recv_nbx$address() {
        return ucp_tag_recv_nbx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_recv_nbx(ucp_worker_h worker, void *buffer, size_t count, ucp_tag_t tag, ucp_tag_t tag_mask, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_tag_recv_nbx(MemorySegment worker, MemorySegment buffer, long count, long tag, long tag_mask, MemorySegment param) {
        var mh$ = ucp_tag_recv_nbx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_tag_recv_nbx", worker, buffer, count, tag, tag_mask, param);
            }
            return (MemorySegment)mh$.invokeExact(worker, buffer, count, tag, tag_mask, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_tag_probe_nb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_tag_probe_nb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucp_tag_message_h ucp_tag_probe_nb(ucp_worker_h worker, ucp_tag_t tag, ucp_tag_t tag_mask, int remove, ucp_tag_recv_info_t *info)
     * }
     */
    public static FunctionDescriptor ucp_tag_probe_nb$descriptor() {
        return ucp_tag_probe_nb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucp_tag_message_h ucp_tag_probe_nb(ucp_worker_h worker, ucp_tag_t tag, ucp_tag_t tag_mask, int remove, ucp_tag_recv_info_t *info)
     * }
     */
    public static MethodHandle ucp_tag_probe_nb$handle() {
        return ucp_tag_probe_nb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucp_tag_message_h ucp_tag_probe_nb(ucp_worker_h worker, ucp_tag_t tag, ucp_tag_t tag_mask, int remove, ucp_tag_recv_info_t *info)
     * }
     */
    public static MemorySegment ucp_tag_probe_nb$address() {
        return ucp_tag_probe_nb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucp_tag_message_h ucp_tag_probe_nb(ucp_worker_h worker, ucp_tag_t tag, ucp_tag_t tag_mask, int remove, ucp_tag_recv_info_t *info)
     * }
     */
    public static MemorySegment ucp_tag_probe_nb(MemorySegment worker, long tag, long tag_mask, int remove, MemorySegment info) {
        var mh$ = ucp_tag_probe_nb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_tag_probe_nb", worker, tag, tag_mask, remove, info);
            }
            return (MemorySegment)mh$.invokeExact(worker, tag, tag_mask, remove, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_tag_msg_recv_nbx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_tag_msg_recv_nbx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_msg_recv_nbx(ucp_worker_h worker, void *buffer, size_t count, ucp_tag_message_h message, const ucp_request_param_t *param)
     * }
     */
    public static FunctionDescriptor ucp_tag_msg_recv_nbx$descriptor() {
        return ucp_tag_msg_recv_nbx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_msg_recv_nbx(ucp_worker_h worker, void *buffer, size_t count, ucp_tag_message_h message, const ucp_request_param_t *param)
     * }
     */
    public static MethodHandle ucp_tag_msg_recv_nbx$handle() {
        return ucp_tag_msg_recv_nbx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_msg_recv_nbx(ucp_worker_h worker, void *buffer, size_t count, ucp_tag_message_h message, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_tag_msg_recv_nbx$address() {
        return ucp_tag_msg_recv_nbx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_tag_msg_recv_nbx(ucp_worker_h worker, void *buffer, size_t count, ucp_tag_message_h message, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_tag_msg_recv_nbx(MemorySegment worker, MemorySegment buffer, long count, MemorySegment message, MemorySegment param) {
        var mh$ = ucp_tag_msg_recv_nbx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_tag_msg_recv_nbx", worker, buffer, count, message, param);
            }
            return (MemorySegment)mh$.invokeExact(worker, buffer, count, message, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_put_nbx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_put_nbx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_put_nbx(ucp_ep_h ep, const void *buffer, size_t count, uint64_t remote_addr, ucp_rkey_h rkey, const ucp_request_param_t *param)
     * }
     */
    public static FunctionDescriptor ucp_put_nbx$descriptor() {
        return ucp_put_nbx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_put_nbx(ucp_ep_h ep, const void *buffer, size_t count, uint64_t remote_addr, ucp_rkey_h rkey, const ucp_request_param_t *param)
     * }
     */
    public static MethodHandle ucp_put_nbx$handle() {
        return ucp_put_nbx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_put_nbx(ucp_ep_h ep, const void *buffer, size_t count, uint64_t remote_addr, ucp_rkey_h rkey, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_put_nbx$address() {
        return ucp_put_nbx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_put_nbx(ucp_ep_h ep, const void *buffer, size_t count, uint64_t remote_addr, ucp_rkey_h rkey, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_put_nbx(MemorySegment ep, MemorySegment buffer, long count, long remote_addr, MemorySegment rkey, MemorySegment param) {
        var mh$ = ucp_put_nbx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_put_nbx", ep, buffer, count, remote_addr, rkey, param);
            }
            return (MemorySegment)mh$.invokeExact(ep, buffer, count, remote_addr, rkey, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_get_nbx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_get_nbx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_get_nbx(ucp_ep_h ep, void *buffer, size_t count, uint64_t remote_addr, ucp_rkey_h rkey, const ucp_request_param_t *param)
     * }
     */
    public static FunctionDescriptor ucp_get_nbx$descriptor() {
        return ucp_get_nbx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_get_nbx(ucp_ep_h ep, void *buffer, size_t count, uint64_t remote_addr, ucp_rkey_h rkey, const ucp_request_param_t *param)
     * }
     */
    public static MethodHandle ucp_get_nbx$handle() {
        return ucp_get_nbx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_get_nbx(ucp_ep_h ep, void *buffer, size_t count, uint64_t remote_addr, ucp_rkey_h rkey, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_get_nbx$address() {
        return ucp_get_nbx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_get_nbx(ucp_ep_h ep, void *buffer, size_t count, uint64_t remote_addr, ucp_rkey_h rkey, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_get_nbx(MemorySegment ep, MemorySegment buffer, long count, long remote_addr, MemorySegment rkey, MemorySegment param) {
        var mh$ = ucp_get_nbx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_get_nbx", ep, buffer, count, remote_addr, rkey, param);
            }
            return (MemorySegment)mh$.invokeExact(ep, buffer, count, remote_addr, rkey, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_atomic_op_nbx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_LONG,
            Ucx.C_LONG,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_atomic_op_nbx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_atomic_op_nbx(ucp_ep_h ep, ucp_atomic_op_t opcode, const void *buffer, size_t count, uint64_t remote_addr, ucp_rkey_h rkey, const ucp_request_param_t *param)
     * }
     */
    public static FunctionDescriptor ucp_atomic_op_nbx$descriptor() {
        return ucp_atomic_op_nbx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_atomic_op_nbx(ucp_ep_h ep, ucp_atomic_op_t opcode, const void *buffer, size_t count, uint64_t remote_addr, ucp_rkey_h rkey, const ucp_request_param_t *param)
     * }
     */
    public static MethodHandle ucp_atomic_op_nbx$handle() {
        return ucp_atomic_op_nbx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_atomic_op_nbx(ucp_ep_h ep, ucp_atomic_op_t opcode, const void *buffer, size_t count, uint64_t remote_addr, ucp_rkey_h rkey, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_atomic_op_nbx$address() {
        return ucp_atomic_op_nbx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_atomic_op_nbx(ucp_ep_h ep, ucp_atomic_op_t opcode, const void *buffer, size_t count, uint64_t remote_addr, ucp_rkey_h rkey, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_atomic_op_nbx(MemorySegment ep, int opcode, MemorySegment buffer, long count, long remote_addr, MemorySegment rkey, MemorySegment param) {
        var mh$ = ucp_atomic_op_nbx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_atomic_op_nbx", ep, opcode, buffer, count, remote_addr, rkey, param);
            }
            return (MemorySegment)mh$.invokeExact(ep, opcode, buffer, count, remote_addr, rkey, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_request_check_status {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_request_check_status");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_request_check_status(void *request)
     * }
     */
    public static FunctionDescriptor ucp_request_check_status$descriptor() {
        return ucp_request_check_status.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_request_check_status(void *request)
     * }
     */
    public static MethodHandle ucp_request_check_status$handle() {
        return ucp_request_check_status.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_request_check_status(void *request)
     * }
     */
    public static MemorySegment ucp_request_check_status$address() {
        return ucp_request_check_status.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_request_check_status(void *request)
     * }
     */
    public static int ucp_request_check_status(MemorySegment request) {
        var mh$ = ucp_request_check_status.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_request_check_status", request);
            }
            return (int)mh$.invokeExact(request);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_tag_recv_request_test {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_tag_recv_request_test");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_tag_recv_request_test(void *request, ucp_tag_recv_info_t *info)
     * }
     */
    public static FunctionDescriptor ucp_tag_recv_request_test$descriptor() {
        return ucp_tag_recv_request_test.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_tag_recv_request_test(void *request, ucp_tag_recv_info_t *info)
     * }
     */
    public static MethodHandle ucp_tag_recv_request_test$handle() {
        return ucp_tag_recv_request_test.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_tag_recv_request_test(void *request, ucp_tag_recv_info_t *info)
     * }
     */
    public static MemorySegment ucp_tag_recv_request_test$address() {
        return ucp_tag_recv_request_test.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_tag_recv_request_test(void *request, ucp_tag_recv_info_t *info)
     * }
     */
    public static int ucp_tag_recv_request_test(MemorySegment request, MemorySegment info) {
        var mh$ = ucp_tag_recv_request_test.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_tag_recv_request_test", request, info);
            }
            return (int)mh$.invokeExact(request, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_stream_recv_request_test {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_stream_recv_request_test");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_stream_recv_request_test(void *request, size_t *length_p)
     * }
     */
    public static FunctionDescriptor ucp_stream_recv_request_test$descriptor() {
        return ucp_stream_recv_request_test.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_stream_recv_request_test(void *request, size_t *length_p)
     * }
     */
    public static MethodHandle ucp_stream_recv_request_test$handle() {
        return ucp_stream_recv_request_test.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_stream_recv_request_test(void *request, size_t *length_p)
     * }
     */
    public static MemorySegment ucp_stream_recv_request_test$address() {
        return ucp_stream_recv_request_test.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_stream_recv_request_test(void *request, size_t *length_p)
     * }
     */
    public static int ucp_stream_recv_request_test(MemorySegment request, MemorySegment length_p) {
        var mh$ = ucp_stream_recv_request_test.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_stream_recv_request_test", request, length_p);
            }
            return (int)mh$.invokeExact(request, length_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_request_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_request_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_request_cancel(ucp_worker_h worker, void *request)
     * }
     */
    public static FunctionDescriptor ucp_request_cancel$descriptor() {
        return ucp_request_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_request_cancel(ucp_worker_h worker, void *request)
     * }
     */
    public static MethodHandle ucp_request_cancel$handle() {
        return ucp_request_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_request_cancel(ucp_worker_h worker, void *request)
     * }
     */
    public static MemorySegment ucp_request_cancel$address() {
        return ucp_request_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_request_cancel(ucp_worker_h worker, void *request)
     * }
     */
    public static void ucp_request_cancel(MemorySegment worker, MemorySegment request) {
        var mh$ = ucp_request_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_request_cancel", worker, request);
            }
            mh$.invokeExact(worker, request);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_stream_data_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_stream_data_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_stream_data_release(ucp_ep_h ep, void *data)
     * }
     */
    public static FunctionDescriptor ucp_stream_data_release$descriptor() {
        return ucp_stream_data_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_stream_data_release(ucp_ep_h ep, void *data)
     * }
     */
    public static MethodHandle ucp_stream_data_release$handle() {
        return ucp_stream_data_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_stream_data_release(ucp_ep_h ep, void *data)
     * }
     */
    public static MemorySegment ucp_stream_data_release$address() {
        return ucp_stream_data_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_stream_data_release(ucp_ep_h ep, void *data)
     * }
     */
    public static void ucp_stream_data_release(MemorySegment ep, MemorySegment data) {
        var mh$ = ucp_stream_data_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_stream_data_release", ep, data);
            }
            mh$.invokeExact(ep, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_request_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_request_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_request_free(void *request)
     * }
     */
    public static FunctionDescriptor ucp_request_free$descriptor() {
        return ucp_request_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_request_free(void *request)
     * }
     */
    public static MethodHandle ucp_request_free$handle() {
        return ucp_request_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_request_free(void *request)
     * }
     */
    public static MemorySegment ucp_request_free$address() {
        return ucp_request_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_request_free(void *request)
     * }
     */
    public static void ucp_request_free(MemorySegment request) {
        var mh$ = ucp_request_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_request_free", request);
            }
            mh$.invokeExact(request);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_dt_create_generic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_dt_create_generic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_dt_create_generic(const ucp_generic_dt_ops_t *ops, void *context, ucp_datatype_t *datatype_p)
     * }
     */
    public static FunctionDescriptor ucp_dt_create_generic$descriptor() {
        return ucp_dt_create_generic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_dt_create_generic(const ucp_generic_dt_ops_t *ops, void *context, ucp_datatype_t *datatype_p)
     * }
     */
    public static MethodHandle ucp_dt_create_generic$handle() {
        return ucp_dt_create_generic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_dt_create_generic(const ucp_generic_dt_ops_t *ops, void *context, ucp_datatype_t *datatype_p)
     * }
     */
    public static MemorySegment ucp_dt_create_generic$address() {
        return ucp_dt_create_generic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_dt_create_generic(const ucp_generic_dt_ops_t *ops, void *context, ucp_datatype_t *datatype_p)
     * }
     */
    public static int ucp_dt_create_generic(MemorySegment ops, MemorySegment context, MemorySegment datatype_p) {
        var mh$ = ucp_dt_create_generic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_dt_create_generic", ops, context, datatype_p);
            }
            return (int)mh$.invokeExact(ops, context, datatype_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_dt_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucx.C_LONG
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_dt_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucp_dt_destroy(ucp_datatype_t datatype)
     * }
     */
    public static FunctionDescriptor ucp_dt_destroy$descriptor() {
        return ucp_dt_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucp_dt_destroy(ucp_datatype_t datatype)
     * }
     */
    public static MethodHandle ucp_dt_destroy$handle() {
        return ucp_dt_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucp_dt_destroy(ucp_datatype_t datatype)
     * }
     */
    public static MemorySegment ucp_dt_destroy$address() {
        return ucp_dt_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucp_dt_destroy(ucp_datatype_t datatype)
     * }
     */
    public static void ucp_dt_destroy(long datatype) {
        var mh$ = ucp_dt_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_dt_destroy", datatype);
            }
            mh$.invokeExact(datatype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_dt_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_LONG,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_dt_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_dt_query(ucp_datatype_t datatype, ucp_datatype_attr_t *attr)
     * }
     */
    public static FunctionDescriptor ucp_dt_query$descriptor() {
        return ucp_dt_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_dt_query(ucp_datatype_t datatype, ucp_datatype_attr_t *attr)
     * }
     */
    public static MethodHandle ucp_dt_query$handle() {
        return ucp_dt_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_dt_query(ucp_datatype_t datatype, ucp_datatype_attr_t *attr)
     * }
     */
    public static MemorySegment ucp_dt_query$address() {
        return ucp_dt_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_dt_query(ucp_datatype_t datatype, ucp_datatype_attr_t *attr)
     * }
     */
    public static int ucp_dt_query(long datatype, MemorySegment attr) {
        var mh$ = ucp_dt_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_dt_query", datatype, attr);
            }
            return (int)mh$.invokeExact(datatype, attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_fence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_fence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_fence(ucp_worker_h worker)
     * }
     */
    public static FunctionDescriptor ucp_worker_fence$descriptor() {
        return ucp_worker_fence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_fence(ucp_worker_h worker)
     * }
     */
    public static MethodHandle ucp_worker_fence$handle() {
        return ucp_worker_fence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_fence(ucp_worker_h worker)
     * }
     */
    public static MemorySegment ucp_worker_fence$address() {
        return ucp_worker_fence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_worker_fence(ucp_worker_h worker)
     * }
     */
    public static int ucp_worker_fence(MemorySegment worker) {
        var mh$ = ucp_worker_fence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_fence", worker);
            }
            return (int)mh$.invokeExact(worker);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucp_worker_flush_nbx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_POINTER,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_worker_flush_nbx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_worker_flush_nbx(ucp_worker_h worker, const ucp_request_param_t *param)
     * }
     */
    public static FunctionDescriptor ucp_worker_flush_nbx$descriptor() {
        return ucp_worker_flush_nbx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_worker_flush_nbx(ucp_worker_h worker, const ucp_request_param_t *param)
     * }
     */
    public static MethodHandle ucp_worker_flush_nbx$handle() {
        return ucp_worker_flush_nbx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_worker_flush_nbx(ucp_worker_h worker, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_worker_flush_nbx$address() {
        return ucp_worker_flush_nbx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_ptr_t ucp_worker_flush_nbx(ucp_worker_h worker, const ucp_request_param_t *param)
     * }
     */
    public static MemorySegment ucp_worker_flush_nbx(MemorySegment worker, MemorySegment param) {
        var mh$ = ucp_worker_flush_nbx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_worker_flush_nbx", worker, param);
            }
            return (MemorySegment)mh$.invokeExact(worker, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UCP_EP_ATTR_FIELD_NAME = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_attr_field.UCP_EP_ATTR_FIELD_NAME = 1
     * }
     */
    public static int UCP_EP_ATTR_FIELD_NAME() {
        return UCP_EP_ATTR_FIELD_NAME;
    }
    private static final int UCP_EP_ATTR_FIELD_LOCAL_SOCKADDR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_attr_field.UCP_EP_ATTR_FIELD_LOCAL_SOCKADDR = 2
     * }
     */
    public static int UCP_EP_ATTR_FIELD_LOCAL_SOCKADDR() {
        return UCP_EP_ATTR_FIELD_LOCAL_SOCKADDR;
    }
    private static final int UCP_EP_ATTR_FIELD_REMOTE_SOCKADDR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_attr_field.UCP_EP_ATTR_FIELD_REMOTE_SOCKADDR = 4
     * }
     */
    public static int UCP_EP_ATTR_FIELD_REMOTE_SOCKADDR() {
        return UCP_EP_ATTR_FIELD_REMOTE_SOCKADDR;
    }
    private static final int UCP_EP_ATTR_FIELD_TRANSPORTS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_attr_field.UCP_EP_ATTR_FIELD_TRANSPORTS = 8
     * }
     */
    public static int UCP_EP_ATTR_FIELD_TRANSPORTS() {
        return UCP_EP_ATTR_FIELD_TRANSPORTS;
    }
    private static final int UCP_EP_ATTR_FIELD_USER_DATA = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ucp_ep_attr_field.UCP_EP_ATTR_FIELD_USER_DATA = 16
     * }
     */
    public static int UCP_EP_ATTR_FIELD_USER_DATA() {
        return UCP_EP_ATTR_FIELD_USER_DATA;
    }

    private static class ucp_ep_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucx.C_INT,
            Ucx.C_POINTER,
            Ucx.C_POINTER
        );

        public static final MemorySegment ADDR = Ucx.findOrThrow("ucp_ep_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_query(ucp_ep_h ep, ucp_ep_attr_t *attr)
     * }
     */
    public static FunctionDescriptor ucp_ep_query$descriptor() {
        return ucp_ep_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_query(ucp_ep_h ep, ucp_ep_attr_t *attr)
     * }
     */
    public static MethodHandle ucp_ep_query$handle() {
        return ucp_ep_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_query(ucp_ep_h ep, ucp_ep_attr_t *attr)
     * }
     */
    public static MemorySegment ucp_ep_query$address() {
        return ucp_ep_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucs_status_t ucp_ep_query(ucp_ep_h ep, ucp_ep_attr_t *attr)
     * }
     */
    public static int ucp_ep_query(MemorySegment ep, MemorySegment attr) {
        var mh$ = ucp_ep_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucp_ep_query", ep, attr);
            }
            return (int)mh$.invokeExact(ep, attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long UCS_MEMORY_TYPES_CPU_ACCESSIBLE = 337L;
    /**
     * {@snippet lang=c :
     * #define UCS_MEMORY_TYPES_CPU_ACCESSIBLE 337
     * }
     */
    public static long UCS_MEMORY_TYPES_CPU_ACCESSIBLE() {
        return UCS_MEMORY_TYPES_CPU_ACCESSIBLE;
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final long __STDC_IEC_60559_BFP__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_BFP__ 201404
     * }
     */
    public static long __STDC_IEC_60559_BFP__() {
        return __STDC_IEC_60559_BFP__;
    }
}

