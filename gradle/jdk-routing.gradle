// WarpForge JDK routing
//
// Goals:
//  - snakegrinder-* must RUN on a GraalVM JDK 25 launcher (GraalPy runtime compilation).
//  - snakeburger-* must compile/run on the locally-built Babylon JDK discovered under ../babylon/build.
//
// Notes:
//  - Gradle's JavaExec/Test tasks have BOTH `javaLauncher` (toolchain) and `executable` (path) inputs.
//    If both are set and point at different installations, Gradle fails with:
//      "Toolchain from `executable` property does not match toolchain from `javaLauncher` property."
//
//  - Some plugins (notably `application`) may set `javaLauncher` late during project evaluation.
//    To avoid being overwritten, we wire snakegrinder launchers in `gradle.projectsEvaluated { ... }`
//    so this script runs last.
//
// Babylon Auto-Update:
//  - Pass -Pbabylon.autoUpdate=true to automatically pull and rebuild Babylon before snakeburger tasks
//  - This ensures jdk.incubator.code APIs are always up-to-date

import org.gradle.api.Action
import org.gradle.api.tasks.JavaExec
import org.gradle.api.tasks.compile.JavaCompile
import org.gradle.api.tasks.testing.Test
import org.gradle.jvm.toolchain.JavaLanguageVersion
import org.gradle.jvm.toolchain.JavaToolchainService
import org.gradle.jvm.toolchain.JvmVendorSpec

// Prefer services.get(...) so this works even when the root project does not apply the Java plugin.
def toolchainService = project.services.get(JavaToolchainService)

// ---- Toolchain launcher for Java 25 on GraalVM (snakegrinder) ----
// Vendor matching keeps this robust across Oracle GraalVM vs GraalVM Community.
def graalvm25LauncherProvider = toolchainService.launcherFor(({ spec ->
    spec.languageVersion = JavaLanguageVersion.of(25)
    spec.vendor = JvmVendorSpec.matching("GraalVM")
} as Action))

// ---- Babylon discovery helpers (snakeburger) ----
def isMac = System.getProperty("os.name", "").toLowerCase().contains("mac")

// Return the Babylon JDK home dir (the one that contains bin/java AND bin/javac)
def findBabylonJdkHome = { ->
    File babylonRoot = new File(rootDir, "../babylon")
    File buildDir = new File(babylonRoot, "build")
    if (!buildDir.exists()) return null

    // macOS: .../Contents/Home/bin/javac
    if (isMac) {
        def javacFiles = fileTree(buildDir) {
            include "**/Contents/Home/bin/javac"
        }.files
        if (!javacFiles.isEmpty()) {
            File javac = javacFiles.iterator().next()
            return javac.parentFile.parentFile // Contents/Home
        }
    }

    // Linux: prefer .../jdk/bin/javac (avoid support/interim-image)
    def javacFiles = fileTree(buildDir) {
        include "**/jdk/bin/javac"
        include "**/images/**/bin/javac"
        exclude "**/support/**"
        exclude "**/interim-image/**"
        exclude "**/jre/**"
    }.files

    if (javacFiles.isEmpty()) return null

    // Deterministic pick: prefer paths that look like the final built JDK.
    def sorted = javacFiles.toList().sort { it.absolutePath }
    File pick = sorted.find { f ->
        def p = f.absolutePath
        return (p.contains("/jdk/") || p.endsWith("/jdk/bin/javac")) && !p.contains("support") && !p.contains("interim")
    } ?: sorted[0]

    return pick.parentFile.parentFile // .../jdk
}

def configureSnakeBurgerProject = { Project p ->
    def babylonHome = findBabylonJdkHome.call()
    if (babylonHome == null) {
        // Fail only when a snakeburger task is actually executed.
        p.tasks.matching { t -> (t instanceof JavaCompile) || (t instanceof JavaExec) || (t instanceof Test) }.configureEach { t ->
            t.doFirst {
                throw new GradleException(
                    "Babylon JDK not found under ../babylon/build. Expected a built JDK containing " +
                    (isMac ? "Contents/Home/bin/javac" : "jdk/bin/javac") +
                    ". Build Babylon first in ../babylon, then re-run."
                )
            }
        }
        return
    }

    def babylonJava  = new File(babylonHome, "bin/java")
    def babylonJavac = new File(babylonHome, "bin/javac")

    if (!babylonJava.exists() || !babylonJavac.exists()) {
        p.tasks.matching { t -> (t instanceof JavaCompile) || (t instanceof JavaExec) || (t instanceof Test) }.configureEach { t ->
            t.doFirst {
                throw new GradleException(
                    "Babylon JDK home looks invalid: " + babylonHome.absolutePath +
                    " (expected bin/java and bin/javac)"
                )
            }
        }
        return
    }

    // Determine which incubator modules to enable
    // warpforge modules and snakeburger-codegen (tests depend on warpforge) need jdk.incubator.vector
    def needsVector = p.name.startsWith("warpforge") || p.name == "snakeburger-codegen"
    def incubatorModules = needsVector
        ? "jdk.incubator.code,jdk.incubator.vector"
        : "jdk.incubator.code"

    p.tasks.withType(JavaCompile).configureEach { JavaCompile c ->
        c.options.fork = true
        // Use explicit executable to avoid Gradle probing a non-standard installation via toolchains.
        c.options.forkOptions.executable = babylonJavac.absolutePath
        c.options.compilerArgs.addAll(["--add-modules", incubatorModules])
    }

    p.tasks.withType(JavaExec).configureEach { JavaExec e ->
        e.executable = babylonJava.absolutePath
        e.jvmArgs("--add-modules", incubatorModules, "--enable-native-access=ALL-UNNAMED")
    }

    p.tasks.withType(Test).configureEach { Test t ->
        t.executable = babylonJava.absolutePath
        t.jvmArgs("--add-modules", incubatorModules, "--enable-native-access=ALL-UNNAMED")
    }
}

// Check if auto-update is enabled
def autoUpdateEnabled = project.hasProperty('babylon.autoUpdate') &&
    project.property('babylon.autoUpdate').toString().toLowerCase() in ['true', '1', 'yes']

// ============================================================================
// JDK Routing for snakeburger and warpforge modules
// ============================================================================
// Babylon JDK modules (require jdk.incubator.code):
//   - snakeburger-cli: BabylonHello.java demo
//   - snakeburger-codegen: Future sophisticated code generation via code reflection
//
// Standard Java 25 modules:
//   - snakeburger-core: Pure Java AST/parser (no Babylon APIs)
//   - warpforge-*: Runtime components (use jdk.incubator.vector)
//
// Mode 2b architecture:
//   1. generateTestModelJars runs on Babylon JDK → produces JARs with Java 25 bytecode
//   2. espressoSmokeTest runs on GraalVM → loads pre-generated JARs via Espresso

// Modules that REQUIRE Babylon JDK (use jdk.incubator.code)
// snakeburger-codegen needs Babylon for future sophisticated code generation via code reflection
def babylonModules = ['snakeburger-cli', 'snakeburger-codegen'] as Set

// Modules that need jdk.incubator.vector (available in Java 25+)
def vectorModules = ['warpforge-core', 'warpforge-backend-cpu', 'warpforge-backend-nvidia',
                     'warpforge-backend-amd', 'warpforge-test-runner', 'warpforge-io'] as Set

subprojects { p ->
    // Babylon JDK modules (only snakeburger-cli now)
    if (babylonModules.contains(p.name)) {
        configureSnakeBurgerProject.call(p)

        if (autoUpdateEnabled) {
            p.afterEvaluate {
                def babylonRuntime = rootProject.findProject(':babylon-runtime')
                if (babylonRuntime != null) {
                    p.tasks.withType(JavaCompile).configureEach { compileTask ->
                        compileTask.dependsOn(babylonRuntime.tasks.named('ensureBabylonReady'))
                    }
                }
            }
        }
    }
    // Vector API modules (standard Java 25 with jdk.incubator.vector)
    else if (vectorModules.contains(p.name)) {
        p.tasks.withType(JavaCompile).configureEach { JavaCompile c ->
            c.options.compilerArgs.addAll(["--add-modules", "jdk.incubator.vector"])
        }
        p.tasks.withType(JavaExec).configureEach { JavaExec e ->
            e.jvmArgs("--add-modules", "jdk.incubator.vector", "--enable-native-access=ALL-UNNAMED")
        }
        p.tasks.withType(Test).configureEach { Test t ->
            t.jvmArgs("--add-modules", "jdk.incubator.vector", "--enable-native-access=ALL-UNNAMED")
        }
    }
    // Other snakeburger modules (standard Java 25, no special modules)
    // snakeburger-core, snakeburger-codegen compile with default toolchain
}

// Configure snakegrinder as late as possible so nothing overrides it.
gradle.projectsEvaluated {
    def graalLauncher = graalvm25LauncherProvider.get()
    def graalJava = graalLauncher.executablePath.asFile.absolutePath

    rootProject.subprojects.each { p ->
        if (!p.name.startsWith("snakegrinder")) return

        p.tasks.withType(JavaExec).configureEach { JavaExec e ->
            // Force BOTH properties to the same toolchain to avoid Gradle mismatch errors.
            e.javaLauncher.set(graalvm25LauncherProvider)
            e.executable = graalJava

            e.jvmArgs(
                "--enable-native-access=ALL-UNNAMED",
                "-XX:+UnlockExperimentalVMOptions",
                "-XX:+EnableJVMCI"
            )
        }

        p.tasks.withType(Test).configureEach { Test t ->
            t.javaLauncher.set(graalvm25LauncherProvider)
            t.executable = graalJava

            t.jvmArgs(
                "--enable-native-access=ALL-UNNAMED",
                "-XX:+UnlockExperimentalVMOptions",
                "-XX:+EnableJVMCI"
            )
        }
    }

    // Configure espressoSmokeTest in warpforge-test-runner to use GraalVM
    // The java-community Maven dependency provides Espresso as a polyglot language
    def testRunner = rootProject.findProject(':warpforge-test-runner')
    if (testRunner != null) {
        testRunner.tasks.matching { it.name == 'espressoSmokeTest' }.configureEach { Test t ->
            t.javaLauncher.set(graalvm25LauncherProvider)
            t.executable = graalJava

            t.jvmArgs(
                "--add-modules", "jdk.incubator.vector",
                "--enable-native-access=ALL-UNNAMED",
                "-XX:+UnlockExperimentalVMOptions",
                "-XX:+EnableJVMCI"
            )
        }
    }
}
