// Generated by jextract

package io.surfworks.warpforge.io.ffi.rdmacm;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ibv_port_attr {
 *     enum ibv_port_state state;
 *     enum ibv_mtu max_mtu;
 *     enum ibv_mtu active_mtu;
 *     int gid_tbl_len;
 *     uint32_t port_cap_flags;
 *     uint32_t max_msg_sz;
 *     uint32_t bad_pkey_cntr;
 *     uint32_t qkey_viol_cntr;
 *     uint16_t pkey_tbl_len;
 *     uint16_t lid;
 *     uint16_t sm_lid;
 *     uint8_t lmc;
 *     uint8_t max_vl_num;
 *     uint8_t sm_sl;
 *     uint8_t subnet_timeout;
 *     uint8_t init_type_reply;
 *     uint8_t active_width;
 *     uint8_t active_speed;
 *     uint8_t phys_state;
 *     uint8_t link_layer;
 *     uint8_t flags;
 *     uint16_t port_cap_flags2;
 * }
 * }
 */
public class ibv_port_attr {

    ibv_port_attr() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        RdmaCm.C_INT.withName("state"),
        RdmaCm.C_INT.withName("max_mtu"),
        RdmaCm.C_INT.withName("active_mtu"),
        RdmaCm.C_INT.withName("gid_tbl_len"),
        RdmaCm.C_INT.withName("port_cap_flags"),
        RdmaCm.C_INT.withName("max_msg_sz"),
        RdmaCm.C_INT.withName("bad_pkey_cntr"),
        RdmaCm.C_INT.withName("qkey_viol_cntr"),
        RdmaCm.C_SHORT.withName("pkey_tbl_len"),
        RdmaCm.C_SHORT.withName("lid"),
        RdmaCm.C_SHORT.withName("sm_lid"),
        RdmaCm.C_CHAR.withName("lmc"),
        RdmaCm.C_CHAR.withName("max_vl_num"),
        RdmaCm.C_CHAR.withName("sm_sl"),
        RdmaCm.C_CHAR.withName("subnet_timeout"),
        RdmaCm.C_CHAR.withName("init_type_reply"),
        RdmaCm.C_CHAR.withName("active_width"),
        RdmaCm.C_CHAR.withName("active_speed"),
        RdmaCm.C_CHAR.withName("phys_state"),
        RdmaCm.C_CHAR.withName("link_layer"),
        RdmaCm.C_CHAR.withName("flags"),
        RdmaCm.C_SHORT.withName("port_cap_flags2"),
        MemoryLayout.paddingLayout(2)
    ).withName("ibv_port_attr");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt state$LAYOUT = (OfInt)$LAYOUT.select(groupElement("state"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum ibv_port_state state
     * }
     */
    public static final OfInt state$layout() {
        return state$LAYOUT;
    }

    private static final long state$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum ibv_port_state state
     * }
     */
    public static final long state$offset() {
        return state$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum ibv_port_state state
     * }
     */
    public static int state(MemorySegment struct) {
        return struct.get(state$LAYOUT, state$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum ibv_port_state state
     * }
     */
    public static void state(MemorySegment struct, int fieldValue) {
        struct.set(state$LAYOUT, state$OFFSET, fieldValue);
    }

    private static final OfInt max_mtu$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_mtu"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum ibv_mtu max_mtu
     * }
     */
    public static final OfInt max_mtu$layout() {
        return max_mtu$LAYOUT;
    }

    private static final long max_mtu$OFFSET = 4;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum ibv_mtu max_mtu
     * }
     */
    public static final long max_mtu$offset() {
        return max_mtu$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum ibv_mtu max_mtu
     * }
     */
    public static int max_mtu(MemorySegment struct) {
        return struct.get(max_mtu$LAYOUT, max_mtu$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum ibv_mtu max_mtu
     * }
     */
    public static void max_mtu(MemorySegment struct, int fieldValue) {
        struct.set(max_mtu$LAYOUT, max_mtu$OFFSET, fieldValue);
    }

    private static final OfInt active_mtu$LAYOUT = (OfInt)$LAYOUT.select(groupElement("active_mtu"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum ibv_mtu active_mtu
     * }
     */
    public static final OfInt active_mtu$layout() {
        return active_mtu$LAYOUT;
    }

    private static final long active_mtu$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum ibv_mtu active_mtu
     * }
     */
    public static final long active_mtu$offset() {
        return active_mtu$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum ibv_mtu active_mtu
     * }
     */
    public static int active_mtu(MemorySegment struct) {
        return struct.get(active_mtu$LAYOUT, active_mtu$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum ibv_mtu active_mtu
     * }
     */
    public static void active_mtu(MemorySegment struct, int fieldValue) {
        struct.set(active_mtu$LAYOUT, active_mtu$OFFSET, fieldValue);
    }

    private static final OfInt gid_tbl_len$LAYOUT = (OfInt)$LAYOUT.select(groupElement("gid_tbl_len"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int gid_tbl_len
     * }
     */
    public static final OfInt gid_tbl_len$layout() {
        return gid_tbl_len$LAYOUT;
    }

    private static final long gid_tbl_len$OFFSET = 12;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int gid_tbl_len
     * }
     */
    public static final long gid_tbl_len$offset() {
        return gid_tbl_len$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int gid_tbl_len
     * }
     */
    public static int gid_tbl_len(MemorySegment struct) {
        return struct.get(gid_tbl_len$LAYOUT, gid_tbl_len$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int gid_tbl_len
     * }
     */
    public static void gid_tbl_len(MemorySegment struct, int fieldValue) {
        struct.set(gid_tbl_len$LAYOUT, gid_tbl_len$OFFSET, fieldValue);
    }

    private static final OfInt port_cap_flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("port_cap_flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t port_cap_flags
     * }
     */
    public static final OfInt port_cap_flags$layout() {
        return port_cap_flags$LAYOUT;
    }

    private static final long port_cap_flags$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t port_cap_flags
     * }
     */
    public static final long port_cap_flags$offset() {
        return port_cap_flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t port_cap_flags
     * }
     */
    public static int port_cap_flags(MemorySegment struct) {
        return struct.get(port_cap_flags$LAYOUT, port_cap_flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t port_cap_flags
     * }
     */
    public static void port_cap_flags(MemorySegment struct, int fieldValue) {
        struct.set(port_cap_flags$LAYOUT, port_cap_flags$OFFSET, fieldValue);
    }

    private static final OfInt max_msg_sz$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_msg_sz"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t max_msg_sz
     * }
     */
    public static final OfInt max_msg_sz$layout() {
        return max_msg_sz$LAYOUT;
    }

    private static final long max_msg_sz$OFFSET = 20;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t max_msg_sz
     * }
     */
    public static final long max_msg_sz$offset() {
        return max_msg_sz$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t max_msg_sz
     * }
     */
    public static int max_msg_sz(MemorySegment struct) {
        return struct.get(max_msg_sz$LAYOUT, max_msg_sz$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t max_msg_sz
     * }
     */
    public static void max_msg_sz(MemorySegment struct, int fieldValue) {
        struct.set(max_msg_sz$LAYOUT, max_msg_sz$OFFSET, fieldValue);
    }

    private static final OfInt bad_pkey_cntr$LAYOUT = (OfInt)$LAYOUT.select(groupElement("bad_pkey_cntr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t bad_pkey_cntr
     * }
     */
    public static final OfInt bad_pkey_cntr$layout() {
        return bad_pkey_cntr$LAYOUT;
    }

    private static final long bad_pkey_cntr$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t bad_pkey_cntr
     * }
     */
    public static final long bad_pkey_cntr$offset() {
        return bad_pkey_cntr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t bad_pkey_cntr
     * }
     */
    public static int bad_pkey_cntr(MemorySegment struct) {
        return struct.get(bad_pkey_cntr$LAYOUT, bad_pkey_cntr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t bad_pkey_cntr
     * }
     */
    public static void bad_pkey_cntr(MemorySegment struct, int fieldValue) {
        struct.set(bad_pkey_cntr$LAYOUT, bad_pkey_cntr$OFFSET, fieldValue);
    }

    private static final OfInt qkey_viol_cntr$LAYOUT = (OfInt)$LAYOUT.select(groupElement("qkey_viol_cntr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t qkey_viol_cntr
     * }
     */
    public static final OfInt qkey_viol_cntr$layout() {
        return qkey_viol_cntr$LAYOUT;
    }

    private static final long qkey_viol_cntr$OFFSET = 28;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t qkey_viol_cntr
     * }
     */
    public static final long qkey_viol_cntr$offset() {
        return qkey_viol_cntr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t qkey_viol_cntr
     * }
     */
    public static int qkey_viol_cntr(MemorySegment struct) {
        return struct.get(qkey_viol_cntr$LAYOUT, qkey_viol_cntr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t qkey_viol_cntr
     * }
     */
    public static void qkey_viol_cntr(MemorySegment struct, int fieldValue) {
        struct.set(qkey_viol_cntr$LAYOUT, qkey_viol_cntr$OFFSET, fieldValue);
    }

    private static final OfShort pkey_tbl_len$LAYOUT = (OfShort)$LAYOUT.select(groupElement("pkey_tbl_len"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint16_t pkey_tbl_len
     * }
     */
    public static final OfShort pkey_tbl_len$layout() {
        return pkey_tbl_len$LAYOUT;
    }

    private static final long pkey_tbl_len$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint16_t pkey_tbl_len
     * }
     */
    public static final long pkey_tbl_len$offset() {
        return pkey_tbl_len$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint16_t pkey_tbl_len
     * }
     */
    public static short pkey_tbl_len(MemorySegment struct) {
        return struct.get(pkey_tbl_len$LAYOUT, pkey_tbl_len$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint16_t pkey_tbl_len
     * }
     */
    public static void pkey_tbl_len(MemorySegment struct, short fieldValue) {
        struct.set(pkey_tbl_len$LAYOUT, pkey_tbl_len$OFFSET, fieldValue);
    }

    private static final OfShort lid$LAYOUT = (OfShort)$LAYOUT.select(groupElement("lid"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint16_t lid
     * }
     */
    public static final OfShort lid$layout() {
        return lid$LAYOUT;
    }

    private static final long lid$OFFSET = 34;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint16_t lid
     * }
     */
    public static final long lid$offset() {
        return lid$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint16_t lid
     * }
     */
    public static short lid(MemorySegment struct) {
        return struct.get(lid$LAYOUT, lid$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint16_t lid
     * }
     */
    public static void lid(MemorySegment struct, short fieldValue) {
        struct.set(lid$LAYOUT, lid$OFFSET, fieldValue);
    }

    private static final OfShort sm_lid$LAYOUT = (OfShort)$LAYOUT.select(groupElement("sm_lid"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint16_t sm_lid
     * }
     */
    public static final OfShort sm_lid$layout() {
        return sm_lid$LAYOUT;
    }

    private static final long sm_lid$OFFSET = 36;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint16_t sm_lid
     * }
     */
    public static final long sm_lid$offset() {
        return sm_lid$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint16_t sm_lid
     * }
     */
    public static short sm_lid(MemorySegment struct) {
        return struct.get(sm_lid$LAYOUT, sm_lid$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint16_t sm_lid
     * }
     */
    public static void sm_lid(MemorySegment struct, short fieldValue) {
        struct.set(sm_lid$LAYOUT, sm_lid$OFFSET, fieldValue);
    }

    private static final OfByte lmc$LAYOUT = (OfByte)$LAYOUT.select(groupElement("lmc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t lmc
     * }
     */
    public static final OfByte lmc$layout() {
        return lmc$LAYOUT;
    }

    private static final long lmc$OFFSET = 38;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t lmc
     * }
     */
    public static final long lmc$offset() {
        return lmc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t lmc
     * }
     */
    public static byte lmc(MemorySegment struct) {
        return struct.get(lmc$LAYOUT, lmc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t lmc
     * }
     */
    public static void lmc(MemorySegment struct, byte fieldValue) {
        struct.set(lmc$LAYOUT, lmc$OFFSET, fieldValue);
    }

    private static final OfByte max_vl_num$LAYOUT = (OfByte)$LAYOUT.select(groupElement("max_vl_num"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t max_vl_num
     * }
     */
    public static final OfByte max_vl_num$layout() {
        return max_vl_num$LAYOUT;
    }

    private static final long max_vl_num$OFFSET = 39;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t max_vl_num
     * }
     */
    public static final long max_vl_num$offset() {
        return max_vl_num$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t max_vl_num
     * }
     */
    public static byte max_vl_num(MemorySegment struct) {
        return struct.get(max_vl_num$LAYOUT, max_vl_num$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t max_vl_num
     * }
     */
    public static void max_vl_num(MemorySegment struct, byte fieldValue) {
        struct.set(max_vl_num$LAYOUT, max_vl_num$OFFSET, fieldValue);
    }

    private static final OfByte sm_sl$LAYOUT = (OfByte)$LAYOUT.select(groupElement("sm_sl"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t sm_sl
     * }
     */
    public static final OfByte sm_sl$layout() {
        return sm_sl$LAYOUT;
    }

    private static final long sm_sl$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t sm_sl
     * }
     */
    public static final long sm_sl$offset() {
        return sm_sl$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t sm_sl
     * }
     */
    public static byte sm_sl(MemorySegment struct) {
        return struct.get(sm_sl$LAYOUT, sm_sl$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t sm_sl
     * }
     */
    public static void sm_sl(MemorySegment struct, byte fieldValue) {
        struct.set(sm_sl$LAYOUT, sm_sl$OFFSET, fieldValue);
    }

    private static final OfByte subnet_timeout$LAYOUT = (OfByte)$LAYOUT.select(groupElement("subnet_timeout"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t subnet_timeout
     * }
     */
    public static final OfByte subnet_timeout$layout() {
        return subnet_timeout$LAYOUT;
    }

    private static final long subnet_timeout$OFFSET = 41;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t subnet_timeout
     * }
     */
    public static final long subnet_timeout$offset() {
        return subnet_timeout$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t subnet_timeout
     * }
     */
    public static byte subnet_timeout(MemorySegment struct) {
        return struct.get(subnet_timeout$LAYOUT, subnet_timeout$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t subnet_timeout
     * }
     */
    public static void subnet_timeout(MemorySegment struct, byte fieldValue) {
        struct.set(subnet_timeout$LAYOUT, subnet_timeout$OFFSET, fieldValue);
    }

    private static final OfByte init_type_reply$LAYOUT = (OfByte)$LAYOUT.select(groupElement("init_type_reply"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t init_type_reply
     * }
     */
    public static final OfByte init_type_reply$layout() {
        return init_type_reply$LAYOUT;
    }

    private static final long init_type_reply$OFFSET = 42;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t init_type_reply
     * }
     */
    public static final long init_type_reply$offset() {
        return init_type_reply$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t init_type_reply
     * }
     */
    public static byte init_type_reply(MemorySegment struct) {
        return struct.get(init_type_reply$LAYOUT, init_type_reply$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t init_type_reply
     * }
     */
    public static void init_type_reply(MemorySegment struct, byte fieldValue) {
        struct.set(init_type_reply$LAYOUT, init_type_reply$OFFSET, fieldValue);
    }

    private static final OfByte active_width$LAYOUT = (OfByte)$LAYOUT.select(groupElement("active_width"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t active_width
     * }
     */
    public static final OfByte active_width$layout() {
        return active_width$LAYOUT;
    }

    private static final long active_width$OFFSET = 43;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t active_width
     * }
     */
    public static final long active_width$offset() {
        return active_width$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t active_width
     * }
     */
    public static byte active_width(MemorySegment struct) {
        return struct.get(active_width$LAYOUT, active_width$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t active_width
     * }
     */
    public static void active_width(MemorySegment struct, byte fieldValue) {
        struct.set(active_width$LAYOUT, active_width$OFFSET, fieldValue);
    }

    private static final OfByte active_speed$LAYOUT = (OfByte)$LAYOUT.select(groupElement("active_speed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t active_speed
     * }
     */
    public static final OfByte active_speed$layout() {
        return active_speed$LAYOUT;
    }

    private static final long active_speed$OFFSET = 44;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t active_speed
     * }
     */
    public static final long active_speed$offset() {
        return active_speed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t active_speed
     * }
     */
    public static byte active_speed(MemorySegment struct) {
        return struct.get(active_speed$LAYOUT, active_speed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t active_speed
     * }
     */
    public static void active_speed(MemorySegment struct, byte fieldValue) {
        struct.set(active_speed$LAYOUT, active_speed$OFFSET, fieldValue);
    }

    private static final OfByte phys_state$LAYOUT = (OfByte)$LAYOUT.select(groupElement("phys_state"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t phys_state
     * }
     */
    public static final OfByte phys_state$layout() {
        return phys_state$LAYOUT;
    }

    private static final long phys_state$OFFSET = 45;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t phys_state
     * }
     */
    public static final long phys_state$offset() {
        return phys_state$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t phys_state
     * }
     */
    public static byte phys_state(MemorySegment struct) {
        return struct.get(phys_state$LAYOUT, phys_state$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t phys_state
     * }
     */
    public static void phys_state(MemorySegment struct, byte fieldValue) {
        struct.set(phys_state$LAYOUT, phys_state$OFFSET, fieldValue);
    }

    private static final OfByte link_layer$LAYOUT = (OfByte)$LAYOUT.select(groupElement("link_layer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t link_layer
     * }
     */
    public static final OfByte link_layer$layout() {
        return link_layer$LAYOUT;
    }

    private static final long link_layer$OFFSET = 46;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t link_layer
     * }
     */
    public static final long link_layer$offset() {
        return link_layer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t link_layer
     * }
     */
    public static byte link_layer(MemorySegment struct) {
        return struct.get(link_layer$LAYOUT, link_layer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t link_layer
     * }
     */
    public static void link_layer(MemorySegment struct, byte fieldValue) {
        struct.set(link_layer$LAYOUT, link_layer$OFFSET, fieldValue);
    }

    private static final OfByte flags$LAYOUT = (OfByte)$LAYOUT.select(groupElement("flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t flags
     * }
     */
    public static final OfByte flags$layout() {
        return flags$LAYOUT;
    }

    private static final long flags$OFFSET = 47;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t flags
     * }
     */
    public static final long flags$offset() {
        return flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t flags
     * }
     */
    public static byte flags(MemorySegment struct) {
        return struct.get(flags$LAYOUT, flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t flags
     * }
     */
    public static void flags(MemorySegment struct, byte fieldValue) {
        struct.set(flags$LAYOUT, flags$OFFSET, fieldValue);
    }

    private static final OfShort port_cap_flags2$LAYOUT = (OfShort)$LAYOUT.select(groupElement("port_cap_flags2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint16_t port_cap_flags2
     * }
     */
    public static final OfShort port_cap_flags2$layout() {
        return port_cap_flags2$LAYOUT;
    }

    private static final long port_cap_flags2$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint16_t port_cap_flags2
     * }
     */
    public static final long port_cap_flags2$offset() {
        return port_cap_flags2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint16_t port_cap_flags2
     * }
     */
    public static short port_cap_flags2(MemorySegment struct) {
        return struct.get(port_cap_flags2$LAYOUT, port_cap_flags2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint16_t port_cap_flags2
     * }
     */
    public static void port_cap_flags2(MemorySegment struct, short fieldValue) {
        struct.set(port_cap_flags2$LAYOUT, port_cap_flags2$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

