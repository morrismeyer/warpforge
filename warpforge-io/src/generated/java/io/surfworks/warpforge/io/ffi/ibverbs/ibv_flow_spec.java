// Generated by jextract

package io.surfworks.warpforge.io.ffi.ibverbs;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ibv_flow_spec {
 *     union {
 *         struct {
 *             enum ibv_flow_spec_type type;
 *             uint16_t size;
 *         } hdr;
 *         struct ibv_flow_spec_eth eth;
 *         struct ibv_flow_spec_ipv4 ipv4;
 *         struct ibv_flow_spec_tcp_udp tcp_udp;
 *         struct ibv_flow_spec_ipv4_ext ipv4_ext;
 *         struct ibv_flow_spec_ipv6 ipv6;
 *         struct ibv_flow_spec_esp esp;
 *         struct ibv_flow_spec_tunnel tunnel;
 *         struct ibv_flow_spec_gre gre;
 *         struct ibv_flow_spec_mpls mpls;
 *         struct ibv_flow_spec_action_tag flow_tag;
 *         struct ibv_flow_spec_action_drop drop;
 *         struct ibv_flow_spec_action_handle handle;
 *         struct ibv_flow_spec_counter_action flow_count;
 *     };
 * }
 * }
 */
public class ibv_flow_spec {

    ibv_flow_spec() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        MemoryLayout.unionLayout(
            ibv_flow_spec.hdr.layout().withName("hdr"),
            ibv_flow_spec_eth.layout().withName("eth"),
            ibv_flow_spec_ipv4.layout().withName("ipv4"),
            ibv_flow_spec_tcp_udp.layout().withName("tcp_udp"),
            ibv_flow_spec_ipv4_ext.layout().withName("ipv4_ext"),
            ibv_flow_spec_ipv6.layout().withName("ipv6"),
            ibv_flow_spec_esp.layout().withName("esp"),
            ibv_flow_spec_tunnel.layout().withName("tunnel"),
            ibv_flow_spec_gre.layout().withName("gre"),
            ibv_flow_spec_mpls.layout().withName("mpls"),
            ibv_flow_spec_action_tag.layout().withName("flow_tag"),
            ibv_flow_spec_action_drop.layout().withName("drop"),
            ibv_flow_spec_action_handle.layout().withName("handle"),
            ibv_flow_spec_counter_action.layout().withName("flow_count")
        ).withName("$anon$1848:2")
    ).withName("ibv_flow_spec");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     enum ibv_flow_spec_type type;
     *     uint16_t size;
     * }
     * }
     */
    public static class hdr {

        hdr() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            Ibverbs.C_INT.withName("type"),
            Ibverbs.C_SHORT.withName("size"),
            MemoryLayout.paddingLayout(2)
        ).withName("$anon$1849:3");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfInt type$LAYOUT = (OfInt)$LAYOUT.select(groupElement("type"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * enum ibv_flow_spec_type type
         * }
         */
        public static final OfInt type$layout() {
            return type$LAYOUT;
        }

        private static final long type$OFFSET = 0;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * enum ibv_flow_spec_type type
         * }
         */
        public static final long type$offset() {
            return type$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * enum ibv_flow_spec_type type
         * }
         */
        public static int type(MemorySegment struct) {
            return struct.get(type$LAYOUT, type$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * enum ibv_flow_spec_type type
         * }
         */
        public static void type(MemorySegment struct, int fieldValue) {
            struct.set(type$LAYOUT, type$OFFSET, fieldValue);
        }

        private static final OfShort size$LAYOUT = (OfShort)$LAYOUT.select(groupElement("size"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * uint16_t size
         * }
         */
        public static final OfShort size$layout() {
            return size$LAYOUT;
        }

        private static final long size$OFFSET = 4;

        /**
         * Offset for field:
         * {@snippet lang=c :
         * uint16_t size
         * }
         */
        public static final long size$offset() {
            return size$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * uint16_t size
         * }
         */
        public static short size(MemorySegment struct) {
            return struct.get(size$LAYOUT, size$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * uint16_t size
         * }
         */
        public static void size(MemorySegment struct, short fieldValue) {
            struct.set(size$LAYOUT, size$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout hdr$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$1848:2"), groupElement("hdr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     enum ibv_flow_spec_type type;
     *     uint16_t size;
     * } hdr
     * }
     */
    public static final GroupLayout hdr$layout() {
        return hdr$LAYOUT;
    }

    private static final long hdr$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     enum ibv_flow_spec_type type;
     *     uint16_t size;
     * } hdr
     * }
     */
    public static final long hdr$offset() {
        return hdr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     enum ibv_flow_spec_type type;
     *     uint16_t size;
     * } hdr
     * }
     */
    public static MemorySegment hdr(MemorySegment struct) {
        return struct.asSlice(hdr$OFFSET, hdr$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     enum ibv_flow_spec_type type;
     *     uint16_t size;
     * } hdr
     * }
     */
    public static void hdr(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, hdr$OFFSET, hdr$LAYOUT.byteSize());
    }

    private static final GroupLayout eth$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$1848:2"), groupElement("eth"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_eth eth
     * }
     */
    public static final GroupLayout eth$layout() {
        return eth$LAYOUT;
    }

    private static final long eth$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_eth eth
     * }
     */
    public static final long eth$offset() {
        return eth$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_eth eth
     * }
     */
    public static MemorySegment eth(MemorySegment struct) {
        return struct.asSlice(eth$OFFSET, eth$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_eth eth
     * }
     */
    public static void eth(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, eth$OFFSET, eth$LAYOUT.byteSize());
    }

    private static final GroupLayout ipv4$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$1848:2"), groupElement("ipv4"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_ipv4 ipv4
     * }
     */
    public static final GroupLayout ipv4$layout() {
        return ipv4$LAYOUT;
    }

    private static final long ipv4$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_ipv4 ipv4
     * }
     */
    public static final long ipv4$offset() {
        return ipv4$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_ipv4 ipv4
     * }
     */
    public static MemorySegment ipv4(MemorySegment struct) {
        return struct.asSlice(ipv4$OFFSET, ipv4$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_ipv4 ipv4
     * }
     */
    public static void ipv4(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, ipv4$OFFSET, ipv4$LAYOUT.byteSize());
    }

    private static final GroupLayout tcp_udp$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$1848:2"), groupElement("tcp_udp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_tcp_udp tcp_udp
     * }
     */
    public static final GroupLayout tcp_udp$layout() {
        return tcp_udp$LAYOUT;
    }

    private static final long tcp_udp$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_tcp_udp tcp_udp
     * }
     */
    public static final long tcp_udp$offset() {
        return tcp_udp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_tcp_udp tcp_udp
     * }
     */
    public static MemorySegment tcp_udp(MemorySegment struct) {
        return struct.asSlice(tcp_udp$OFFSET, tcp_udp$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_tcp_udp tcp_udp
     * }
     */
    public static void tcp_udp(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, tcp_udp$OFFSET, tcp_udp$LAYOUT.byteSize());
    }

    private static final GroupLayout ipv4_ext$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$1848:2"), groupElement("ipv4_ext"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_ipv4_ext ipv4_ext
     * }
     */
    public static final GroupLayout ipv4_ext$layout() {
        return ipv4_ext$LAYOUT;
    }

    private static final long ipv4_ext$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_ipv4_ext ipv4_ext
     * }
     */
    public static final long ipv4_ext$offset() {
        return ipv4_ext$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_ipv4_ext ipv4_ext
     * }
     */
    public static MemorySegment ipv4_ext(MemorySegment struct) {
        return struct.asSlice(ipv4_ext$OFFSET, ipv4_ext$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_ipv4_ext ipv4_ext
     * }
     */
    public static void ipv4_ext(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, ipv4_ext$OFFSET, ipv4_ext$LAYOUT.byteSize());
    }

    private static final GroupLayout ipv6$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$1848:2"), groupElement("ipv6"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_ipv6 ipv6
     * }
     */
    public static final GroupLayout ipv6$layout() {
        return ipv6$LAYOUT;
    }

    private static final long ipv6$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_ipv6 ipv6
     * }
     */
    public static final long ipv6$offset() {
        return ipv6$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_ipv6 ipv6
     * }
     */
    public static MemorySegment ipv6(MemorySegment struct) {
        return struct.asSlice(ipv6$OFFSET, ipv6$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_ipv6 ipv6
     * }
     */
    public static void ipv6(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, ipv6$OFFSET, ipv6$LAYOUT.byteSize());
    }

    private static final GroupLayout esp$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$1848:2"), groupElement("esp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_esp esp
     * }
     */
    public static final GroupLayout esp$layout() {
        return esp$LAYOUT;
    }

    private static final long esp$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_esp esp
     * }
     */
    public static final long esp$offset() {
        return esp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_esp esp
     * }
     */
    public static MemorySegment esp(MemorySegment struct) {
        return struct.asSlice(esp$OFFSET, esp$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_esp esp
     * }
     */
    public static void esp(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, esp$OFFSET, esp$LAYOUT.byteSize());
    }

    private static final GroupLayout tunnel$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$1848:2"), groupElement("tunnel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_tunnel tunnel
     * }
     */
    public static final GroupLayout tunnel$layout() {
        return tunnel$LAYOUT;
    }

    private static final long tunnel$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_tunnel tunnel
     * }
     */
    public static final long tunnel$offset() {
        return tunnel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_tunnel tunnel
     * }
     */
    public static MemorySegment tunnel(MemorySegment struct) {
        return struct.asSlice(tunnel$OFFSET, tunnel$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_tunnel tunnel
     * }
     */
    public static void tunnel(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, tunnel$OFFSET, tunnel$LAYOUT.byteSize());
    }

    private static final GroupLayout gre$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$1848:2"), groupElement("gre"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_gre gre
     * }
     */
    public static final GroupLayout gre$layout() {
        return gre$LAYOUT;
    }

    private static final long gre$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_gre gre
     * }
     */
    public static final long gre$offset() {
        return gre$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_gre gre
     * }
     */
    public static MemorySegment gre(MemorySegment struct) {
        return struct.asSlice(gre$OFFSET, gre$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_gre gre
     * }
     */
    public static void gre(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, gre$OFFSET, gre$LAYOUT.byteSize());
    }

    private static final GroupLayout mpls$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$1848:2"), groupElement("mpls"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_mpls mpls
     * }
     */
    public static final GroupLayout mpls$layout() {
        return mpls$LAYOUT;
    }

    private static final long mpls$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_mpls mpls
     * }
     */
    public static final long mpls$offset() {
        return mpls$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_mpls mpls
     * }
     */
    public static MemorySegment mpls(MemorySegment struct) {
        return struct.asSlice(mpls$OFFSET, mpls$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_mpls mpls
     * }
     */
    public static void mpls(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, mpls$OFFSET, mpls$LAYOUT.byteSize());
    }

    private static final GroupLayout flow_tag$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$1848:2"), groupElement("flow_tag"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_action_tag flow_tag
     * }
     */
    public static final GroupLayout flow_tag$layout() {
        return flow_tag$LAYOUT;
    }

    private static final long flow_tag$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_action_tag flow_tag
     * }
     */
    public static final long flow_tag$offset() {
        return flow_tag$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_action_tag flow_tag
     * }
     */
    public static MemorySegment flow_tag(MemorySegment struct) {
        return struct.asSlice(flow_tag$OFFSET, flow_tag$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_action_tag flow_tag
     * }
     */
    public static void flow_tag(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, flow_tag$OFFSET, flow_tag$LAYOUT.byteSize());
    }

    private static final GroupLayout drop$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$1848:2"), groupElement("drop"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_action_drop drop
     * }
     */
    public static final GroupLayout drop$layout() {
        return drop$LAYOUT;
    }

    private static final long drop$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_action_drop drop
     * }
     */
    public static final long drop$offset() {
        return drop$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_action_drop drop
     * }
     */
    public static MemorySegment drop(MemorySegment struct) {
        return struct.asSlice(drop$OFFSET, drop$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_action_drop drop
     * }
     */
    public static void drop(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, drop$OFFSET, drop$LAYOUT.byteSize());
    }

    private static final GroupLayout handle$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$1848:2"), groupElement("handle"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_action_handle handle
     * }
     */
    public static final GroupLayout handle$layout() {
        return handle$LAYOUT;
    }

    private static final long handle$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_action_handle handle
     * }
     */
    public static final long handle$offset() {
        return handle$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_action_handle handle
     * }
     */
    public static MemorySegment handle(MemorySegment struct) {
        return struct.asSlice(handle$OFFSET, handle$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_action_handle handle
     * }
     */
    public static void handle(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, handle$OFFSET, handle$LAYOUT.byteSize());
    }

    private static final GroupLayout flow_count$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("$anon$1848:2"), groupElement("flow_count"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_counter_action flow_count
     * }
     */
    public static final GroupLayout flow_count$layout() {
        return flow_count$LAYOUT;
    }

    private static final long flow_count$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_counter_action flow_count
     * }
     */
    public static final long flow_count$offset() {
        return flow_count$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_counter_action flow_count
     * }
     */
    public static MemorySegment flow_count(MemorySegment struct) {
        return struct.asSlice(flow_count$OFFSET, flow_count$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_flow_spec_counter_action flow_count
     * }
     */
    public static void flow_count(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, flow_count$OFFSET, flow_count$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

