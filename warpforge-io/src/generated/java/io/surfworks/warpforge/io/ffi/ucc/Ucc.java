// Generated by jextract

package io.surfworks.warpforge.io.ffi.ucc;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Ucc {

    Ucc() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("ucc"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int _STDINT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDINT_H 1
     * }
     */
    public static int _STDINT_H() {
        return _STDINT_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)35L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 35
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int _BITS_WCHAR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_WCHAR_H 1
     * }
     */
    public static int _BITS_WCHAR_H() {
        return _BITS_WCHAR_H;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int _BITS_STDINT_UINTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_UINTN_H 1
     * }
     */
    public static int _BITS_STDINT_UINTN_H() {
        return _BITS_STDINT_UINTN_H;
    }
    private static final int UCC_VERSION_MAJOR_SHIFT = (int)24L;
    /**
     * {@snippet lang=c :
     * #define UCC_VERSION_MAJOR_SHIFT 24
     * }
     */
    public static int UCC_VERSION_MAJOR_SHIFT() {
        return UCC_VERSION_MAJOR_SHIFT;
    }
    private static final int UCC_VERSION_MINOR_SHIFT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define UCC_VERSION_MINOR_SHIFT 16
     * }
     */
    public static int UCC_VERSION_MINOR_SHIFT() {
        return UCC_VERSION_MINOR_SHIFT;
    }
    private static final int UCC_API_MAJOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define UCC_API_MAJOR 1
     * }
     */
    public static int UCC_API_MAJOR() {
        return UCC_API_MAJOR;
    }
    private static final int UCC_API_MINOR = (int)7L;
    /**
     * {@snippet lang=c :
     * #define UCC_API_MINOR 7
     * }
     */
    public static int UCC_API_MINOR() {
        return UCC_API_MINOR;
    }
    private static final int _STDIO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDIO_H 1
     * }
     */
    public static int _STDIO_H() {
        return _STDIO_H;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _____fpos_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos_t_defined 1
     * }
     */
    public static int _____fpos_t_defined() {
        return _____fpos_t_defined;
    }
    private static final int ____mbstate_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____mbstate_t_defined 1
     * }
     */
    public static int ____mbstate_t_defined() {
        return ____mbstate_t_defined;
    }
    private static final int _____fpos64_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos64_t_defined 1
     * }
     */
    public static int _____fpos64_t_defined() {
        return _____fpos64_t_defined;
    }
    private static final int ____FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____FILE_defined 1
     * }
     */
    public static int ____FILE_defined() {
        return ____FILE_defined;
    }
    private static final int __FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __FILE_defined 1
     * }
     */
    public static int __FILE_defined() {
        return __FILE_defined;
    }
    private static final int __struct_FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_FILE_defined 1
     * }
     */
    public static int __struct_FILE_defined() {
        return __struct_FILE_defined;
    }
    private static final int _IO_EOF_SEEN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IO_EOF_SEEN 16
     * }
     */
    public static int _IO_EOF_SEEN() {
        return _IO_EOF_SEEN;
    }
    private static final int _IO_ERR_SEEN = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _IO_ERR_SEEN 32
     * }
     */
    public static int _IO_ERR_SEEN() {
        return _IO_ERR_SEEN;
    }
    private static final int _IO_USER_LOCK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _IO_USER_LOCK 32768
     * }
     */
    public static int _IO_USER_LOCK() {
        return _IO_USER_LOCK;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int BUFSIZ = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 8192
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int _BITS_STDIO_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDIO_LIM_H 1
     * }
     */
    public static int _BITS_STDIO_LIM_H() {
        return _BITS_STDIO_LIM_H;
    }
    private static final int L_tmpnam = (int)20L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 20
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)238328L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 238328
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int FILENAME_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 4096
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_ctermid = (int)9L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 9
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int FOPEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 16
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int __HAVE_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128 0
     * }
     */
    public static int __HAVE_FLOAT128() {
        return __HAVE_FLOAT128;
    }
    private static final int __HAVE_DISTINCT_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128() {
        return __HAVE_DISTINCT_FLOAT128;
    }
    private static final int __HAVE_FLOAT64X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X 1
     * }
     */
    public static int __HAVE_FLOAT64X() {
        return __HAVE_FLOAT64X;
    }
    private static final int __HAVE_FLOAT64X_LONG_DOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X_LONG_DOUBLE 1
     * }
     */
    public static int __HAVE_FLOAT64X_LONG_DOUBLE() {
        return __HAVE_FLOAT64X_LONG_DOUBLE;
    }
    private static final int __HAVE_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT16 0
     * }
     */
    public static int __HAVE_FLOAT16() {
        return __HAVE_FLOAT16;
    }
    private static final int __HAVE_FLOAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32 1
     * }
     */
    public static int __HAVE_FLOAT32() {
        return __HAVE_FLOAT32;
    }
    private static final int __HAVE_FLOAT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64 1
     * }
     */
    public static int __HAVE_FLOAT64() {
        return __HAVE_FLOAT64;
    }
    private static final int __HAVE_FLOAT32X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32X 1
     * }
     */
    public static int __HAVE_FLOAT32X() {
        return __HAVE_FLOAT32X;
    }
    private static final int __HAVE_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128X 0
     * }
     */
    public static int __HAVE_FLOAT128X() {
        return __HAVE_FLOAT128X;
    }
    private static final int __HAVE_DISTINCT_FLOAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32() {
        return __HAVE_DISTINCT_FLOAT32;
    }
    private static final int __HAVE_DISTINCT_FLOAT64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64() {
        return __HAVE_DISTINCT_FLOAT64;
    }
    private static final int __HAVE_DISTINCT_FLOAT32X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32X() {
        return __HAVE_DISTINCT_FLOAT32X;
    }
    private static final int __HAVE_DISTINCT_FLOAT64X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64X() {
        return __HAVE_DISTINCT_FLOAT64X;
    }
    private static final int __HAVE_FLOATN_NOT_TYPEDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOATN_NOT_TYPEDEF 0
     * }
     */
    public static int __HAVE_FLOATN_NOT_TYPEDEF() {
        return __HAVE_FLOATN_NOT_TYPEDEF;
    }
    private static final int UCC_DT_PREDEFINED_LAST = (int)18L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_PREDEFINED_LAST 18
     * }
     */
    public static int UCC_DT_PREDEFINED_LAST() {
        return UCC_DT_PREDEFINED_LAST;
    }
    private static final int UCC_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OK = 0
     * }
     */
    public static int UCC_OK() {
        return UCC_OK;
    }
    private static final int UCC_INPROGRESS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_INPROGRESS = 1
     * }
     */
    public static int UCC_INPROGRESS() {
        return UCC_INPROGRESS;
    }
    private static final int UCC_OPERATION_INITIALIZED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OPERATION_INITIALIZED = 2
     * }
     */
    public static int UCC_OPERATION_INITIALIZED() {
        return UCC_OPERATION_INITIALIZED;
    }
    private static final int UCC_ERR_NOT_SUPPORTED = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_ERR_NOT_SUPPORTED = -1
     * }
     */
    public static int UCC_ERR_NOT_SUPPORTED() {
        return UCC_ERR_NOT_SUPPORTED;
    }
    private static final int UCC_ERR_NOT_IMPLEMENTED = (int)-2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_ERR_NOT_IMPLEMENTED = -2
     * }
     */
    public static int UCC_ERR_NOT_IMPLEMENTED() {
        return UCC_ERR_NOT_IMPLEMENTED;
    }
    private static final int UCC_ERR_INVALID_PARAM = (int)-3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_ERR_INVALID_PARAM = -3
     * }
     */
    public static int UCC_ERR_INVALID_PARAM() {
        return UCC_ERR_INVALID_PARAM;
    }
    private static final int UCC_ERR_NO_MEMORY = (int)-4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_ERR_NO_MEMORY = -4
     * }
     */
    public static int UCC_ERR_NO_MEMORY() {
        return UCC_ERR_NO_MEMORY;
    }
    private static final int UCC_ERR_NO_RESOURCE = (int)-5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_ERR_NO_RESOURCE = -5
     * }
     */
    public static int UCC_ERR_NO_RESOURCE() {
        return UCC_ERR_NO_RESOURCE;
    }
    private static final int UCC_ERR_NO_MESSAGE = (int)-6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_ERR_NO_MESSAGE = -6
     * }
     */
    public static int UCC_ERR_NO_MESSAGE() {
        return UCC_ERR_NO_MESSAGE;
    }
    private static final int UCC_ERR_NOT_FOUND = (int)-7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_ERR_NOT_FOUND = -7
     * }
     */
    public static int UCC_ERR_NOT_FOUND() {
        return UCC_ERR_NOT_FOUND;
    }
    private static final int UCC_ERR_TIMED_OUT = (int)-8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_ERR_TIMED_OUT = -8
     * }
     */
    public static int UCC_ERR_TIMED_OUT() {
        return UCC_ERR_TIMED_OUT;
    }
    private static final int UCC_ERR_IO_ERROR = (int)-9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_ERR_IO_ERROR = -9
     * }
     */
    public static int UCC_ERR_IO_ERROR() {
        return UCC_ERR_IO_ERROR;
    }
    private static final int UCC_ERR_LAST = (int)-100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_ERR_LAST = -100
     * }
     */
    public static int UCC_ERR_LAST() {
        return UCC_ERR_LAST;
    }

    private static class ucc_status_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_POINTER,
            Ucc.C_INT
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_status_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ucc_status_string(ucc_status_t status)
     * }
     */
    public static FunctionDescriptor ucc_status_string$descriptor() {
        return ucc_status_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ucc_status_string(ucc_status_t status)
     * }
     */
    public static MethodHandle ucc_status_string$handle() {
        return ucc_status_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ucc_status_string(ucc_status_t status)
     * }
     */
    public static MemorySegment ucc_status_string$address() {
        return ucc_status_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ucc_status_string(ucc_status_t status)
     * }
     */
    public static MemorySegment ucc_status_string(int status) {
        var mh$ = ucc_status_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_status_string", status);
            }
            return (MemorySegment)mh$.invokeExact(status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = Ucc.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = Ucc.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = Ucc.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = Ucc.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = Ucc.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = Ucc.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = Ucc.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = Ucc.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = Ucc.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = Ucc.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = Ucc.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = Ucc.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = Ucc.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = Ucc.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = Ucc.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = Ucc.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = Ucc.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = Ucc.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = Ucc.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = Ucc.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = Ucc.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = Ucc.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = Ucc.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct ucc_lib_info *ucc_lib_h
     * }
     */
    public static final AddressLayout ucc_lib_h = Ucc.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ucc_context *ucc_context_h
     * }
     */
    public static final AddressLayout ucc_context_h = Ucc.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ucc_team *ucc_team_h
     * }
     */
    public static final AddressLayout ucc_team_h = Ucc.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ucc_coll_req *ucc_coll_req_h
     * }
     */
    public static final AddressLayout ucc_coll_req_h = Ucc.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ucc_mem_handle *ucc_mem_h
     * }
     */
    public static final AddressLayout ucc_mem_h = Ucc.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ucc_lib_config *ucc_lib_config_h
     * }
     */
    public static final AddressLayout ucc_lib_config_h = Ucc.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ucc_context_config *ucc_context_config_h
     * }
     */
    public static final AddressLayout ucc_context_config_h = Ucc.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef uint64_t ucc_count_t
     * }
     */
    public static final OfLong ucc_count_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t ucc_aint_t
     * }
     */
    public static final OfLong ucc_aint_t = Ucc.C_LONG;
    private static final int UCC_CONFIG_PRINT_CONFIG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_CONFIG_PRINT_CONFIG = 1
     * }
     */
    public static int UCC_CONFIG_PRINT_CONFIG() {
        return UCC_CONFIG_PRINT_CONFIG;
    }
    private static final int UCC_CONFIG_PRINT_HEADER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_CONFIG_PRINT_HEADER = 2
     * }
     */
    public static int UCC_CONFIG_PRINT_HEADER() {
        return UCC_CONFIG_PRINT_HEADER;
    }
    private static final int UCC_CONFIG_PRINT_DOC = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_CONFIG_PRINT_DOC = 4
     * }
     */
    public static int UCC_CONFIG_PRINT_DOC() {
        return UCC_CONFIG_PRINT_DOC;
    }
    private static final int UCC_CONFIG_PRINT_HIDDEN = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_CONFIG_PRINT_HIDDEN = 8
     * }
     */
    public static int UCC_CONFIG_PRINT_HIDDEN() {
        return UCC_CONFIG_PRINT_HIDDEN;
    }
    /**
     * {@snippet lang=c :
     * typedef uint16_t ucc_coll_id_t
     * }
     */
    public static final OfShort ucc_coll_id_t = Ucc.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef void *ucc_p2p_conn_t
     * }
     */
    public static final AddressLayout ucc_p2p_conn_t = Ucc.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *ucc_context_addr_h
     * }
     */
    public static final AddressLayout ucc_context_addr_h = Ucc.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef size_t ucc_context_addr_len_t
     * }
     */
    public static final OfLong ucc_context_addr_len_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct ucc_ee *ucc_ee_h
     * }
     */
    public static final AddressLayout ucc_ee_h = Ucc.C_POINTER;
    private static final int UCC_DATATYPE_PREDEFINED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_DATATYPE_PREDEFINED = 0
     * }
     */
    public static int UCC_DATATYPE_PREDEFINED() {
        return UCC_DATATYPE_PREDEFINED;
    }
    private static final int UCC_DATATYPE_GENERIC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_DATATYPE_GENERIC = 1
     * }
     */
    public static int UCC_DATATYPE_GENERIC() {
        return UCC_DATATYPE_GENERIC;
    }
    private static final int UCC_DATATYPE_SHIFT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_DATATYPE_SHIFT = 3
     * }
     */
    public static int UCC_DATATYPE_SHIFT() {
        return UCC_DATATYPE_SHIFT;
    }
    private static final int UCC_DATATYPE_CLASS_MASK = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_DATATYPE_CLASS_MASK = 7
     * }
     */
    public static int UCC_DATATYPE_CLASS_MASK() {
        return UCC_DATATYPE_CLASS_MASK;
    }
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = Ucc.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = Ucc.C_LONG;

    private static class stdin$constants {
        public static final AddressLayout LAYOUT = Ucc.C_POINTER;
        public static final MemorySegment SEGMENT = Ucc.findOrThrow("stdin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static AddressLayout stdin$layout() {
        return stdin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin$segment() {
        return stdin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin() {
        return stdin$constants.SEGMENT.get(stdin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static void stdin(MemorySegment varValue) {
        stdin$constants.SEGMENT.set(stdin$constants.LAYOUT, 0L, varValue);
    }

    private static class stdout$constants {
        public static final AddressLayout LAYOUT = Ucc.C_POINTER;
        public static final MemorySegment SEGMENT = Ucc.findOrThrow("stdout").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static AddressLayout stdout$layout() {
        return stdout$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout$segment() {
        return stdout$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout() {
        return stdout$constants.SEGMENT.get(stdout$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static void stdout(MemorySegment varValue) {
        stdout$constants.SEGMENT.set(stdout$constants.LAYOUT, 0L, varValue);
    }

    private static class stderr$constants {
        public static final AddressLayout LAYOUT = Ucc.C_POINTER;
        public static final MemorySegment SEGMENT = Ucc.findOrThrow("stderr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static AddressLayout stderr$layout() {
        return stderr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr$segment() {
        return stderr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr() {
        return stderr$constants.SEGMENT.get(stderr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static void stderr(MemorySegment varValue) {
        stderr$constants.SEGMENT.set(stderr$constants.LAYOUT, 0L, varValue);
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static int remove(MemorySegment __filename) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", __filename);
            }
            return (int)mh$.invokeExact(__filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static int renameat(int __oldfd, MemorySegment __old, int __newfd, MemorySegment __new) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", __oldfd, __old, __newfd, __new);
            }
            return (int)mh$.invokeExact(__oldfd, __old, __newfd, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static int fclose(MemorySegment __stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_POINTER    );

        public static final MemorySegment ADDR = Ucc.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("tmpnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static FunctionDescriptor tmpnam_r$descriptor() {
        return tmpnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MethodHandle tmpnam_r$handle() {
        return tmpnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r$address() {
        return tmpnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r(MemorySegment __s) {
        var mh$ = tmpnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_r", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __pfx) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __pfx);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __pfx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static int fflush(MemorySegment __stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fflush_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush_unlocked$descriptor() {
        return fflush_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fflush_unlocked$handle() {
        return fflush_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fflush_unlocked$address() {
        return fflush_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static int fflush_unlocked(MemorySegment __stream) {
        var mh$ = fflush_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __modes) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment __filename, MemorySegment __modes, MemorySegment __stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", __filename, __modes, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_POINTER,
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen(int __fd, MemorySegment __modes) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", __fd, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__fd, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_LONG,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __s, long __len, MemorySegment __modes) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __s, __len, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__s, __len, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufloc, MemorySegment __sizeloc) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufloc, __sizeloc);
            }
            return (MemorySegment)mh$.invokeExact(__bufloc, __sizeloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static void setbuf(MemorySegment __stream, MemorySegment __buf) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", __stream, __buf);
            }
            mh$.invokeExact(__stream, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_INT,
            Ucc.C_LONG
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static int setvbuf(MemorySegment __stream, MemorySegment __buf, int __modes, long __n) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", __stream, __buf, __modes, __n);
            }
            return (int)mh$.invokeExact(__stream, __buf, __modes, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_LONG
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static void setbuffer(MemorySegment __stream, MemorySegment __buf, long __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", __stream, __buf, __size);
            }
            mh$.invokeExact(__stream, __buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static void setlinebuf(MemorySegment __stream) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucc.C_INT,
                Ucc.C_POINTER,
                Ucc.C_POINTER
            );
        private static final MemorySegment ADDR = Ucc.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", __stream, __format, x2);
                }
                return (int)spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int printf(const char *restrict __format, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucc.C_INT,
                Ucc.C_POINTER
            );
        private static final MemorySegment ADDR = Ucc.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int printf(const char *restrict __format, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", __format, x1);
                }
                return (int)spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucc.C_INT,
                Ucc.C_POINTER,
                Ucc.C_POINTER
            );
        private static final MemorySegment ADDR = Ucc.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", __s, __format, x2);
                }
                return (int)spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vprintf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucc.C_INT,
                Ucc.C_POINTER,
                Ucc.C_LONG,
                Ucc.C_POINTER
            );
        private static final MemorySegment ADDR = Ucc.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, long __maxlen, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __s, __maxlen, __format, x3);
                }
                return (int)spreader.invokeExact(__s, __maxlen, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_LONG,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsnprintf(MemorySegment __s, long __maxlen, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __s, __maxlen, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __maxlen, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static int vdprintf(int __fd, MemorySegment __fmt, MemorySegment __arg) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", __fd, __fmt, __arg);
            }
            return (int)mh$.invokeExact(__fd, __fmt, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int dprintf(int __fd, const char *restrict __fmt, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucc.C_INT,
                Ucc.C_INT,
                Ucc.C_POINTER
            );
        private static final MemorySegment ADDR = Ucc.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int dprintf(int __fd, const char *restrict __fmt, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", __fd, __fmt, x2);
                }
                return (int)spreader.invokeExact(__fd, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucc.C_INT,
                Ucc.C_POINTER,
                Ucc.C_POINTER
            );
        private static final MemorySegment ADDR = Ucc.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", __stream, __format, x2);
                }
                return (int)spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int scanf(const char *restrict __format, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucc.C_INT,
                Ucc.C_POINTER
            );
        private static final MemorySegment ADDR = Ucc.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int scanf(const char *restrict __format, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", __format, x1);
                }
                return (int)spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Ucc.C_INT,
                Ucc.C_POINTER,
                Ucc.C_POINTER
            );
        private static final MemorySegment ADDR = Ucc.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", __s, __format, x2);
                }
                return (int)spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = Ucc.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = Ucc.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = Ucc.C_DOUBLE;

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static int fgetc(MemorySegment __stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static int getc(MemorySegment __stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT    );

        public static final MemorySegment ADDR = Ucc.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static int getc_unlocked(MemorySegment __stream) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT    );

        public static final MemorySegment ADDR = Ucc.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fgetc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc_unlocked$descriptor() {
        return fgetc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc_unlocked$handle() {
        return fgetc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc_unlocked$address() {
        return fgetc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static int fgetc_unlocked(MemorySegment __stream) {
        var mh$ = fgetc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static int fputc(int __c, MemorySegment __stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static int putc(int __c, MemorySegment __stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_INT
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static int putchar(int __c) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fputc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc_unlocked$descriptor() {
        return fputc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc_unlocked$handle() {
        return fputc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc_unlocked$address() {
        return fputc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int fputc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = fputc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int putc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_INT
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static int putchar_unlocked(int __c) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static int getw(MemorySegment __stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static int putw(int __w, MemorySegment __stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", __w, __stream);
            }
            return (int)mh$.invokeExact(__w, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment __s, int __n, MemorySegment __stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", __s, __n, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__s, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_LONG,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("__getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor __getdelim$descriptor() {
        return __getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle __getdelim$handle() {
        return __getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment __getdelim$address() {
        return __getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long __getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = __getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_LONG,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_LONG,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __lineptr, MemorySegment __n, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __lineptr, __n, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static int fputs(MemorySegment __s, MemorySegment __stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", __s, __stream);
            }
            return (int)mh$.invokeExact(__s, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static int puts(MemorySegment __s) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", __s);
            }
            return (int)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static int ungetc(int __c, MemorySegment __stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_LONG,
            Ucc.C_POINTER,
            Ucc.C_LONG,
            Ucc.C_LONG,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_LONG,
            Ucc.C_POINTER,
            Ucc.C_LONG,
            Ucc.C_LONG,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __n, MemorySegment __s) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __n, __s);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_LONG,
            Ucc.C_POINTER,
            Ucc.C_LONG,
            Ucc.C_LONG,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fread_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread_unlocked$descriptor() {
        return fread_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread_unlocked$handle() {
        return fread_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread_unlocked$address() {
        return fread_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_LONG,
            Ucc.C_POINTER,
            Ucc.C_LONG,
            Ucc.C_LONG,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fwrite_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite_unlocked$descriptor() {
        return fwrite_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite_unlocked$handle() {
        return fwrite_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite_unlocked$address() {
        return fwrite_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fwrite_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fwrite_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_LONG,
            Ucc.C_INT
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static int fseek(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_LONG,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static long ftell(MemorySegment __stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static void rewind(MemorySegment __stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_LONG,
            Ucc.C_INT
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_LONG,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static int fgetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static int fsetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static void clearerr(MemorySegment __stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static int feof(MemorySegment __stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static int ferror(MemorySegment __stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("clearerr_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr_unlocked$descriptor() {
        return clearerr_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr_unlocked$handle() {
        return clearerr_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr_unlocked$address() {
        return clearerr_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static void clearerr_unlocked(MemorySegment __stream) {
        var mh$ = clearerr_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_unlocked", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("feof_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof_unlocked$descriptor() {
        return feof_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle feof_unlocked$handle() {
        return feof_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment feof_unlocked$address() {
        return feof_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static int feof_unlocked(MemorySegment __stream) {
        var mh$ = feof_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ferror_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror_unlocked$descriptor() {
        return ferror_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle ferror_unlocked$handle() {
        return ferror_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment ferror_unlocked$address() {
        return ferror_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static int ferror_unlocked(MemorySegment __stream) {
        var mh$ = ferror_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static void perror(MemorySegment __s) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", __s);
            }
            mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static int fileno(MemorySegment __stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("fileno_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno_unlocked$descriptor() {
        return fileno_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fileno_unlocked$handle() {
        return fileno_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fileno_unlocked$address() {
        return fileno_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static int fileno_unlocked(MemorySegment __stream) {
        var mh$ = fileno_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static int pclose(MemorySegment __stream) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen(MemorySegment __command, MemorySegment __modes) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", __command, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__command, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid(MemorySegment __s) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static void flockfile(MemorySegment __stream) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static int ftrylockfile(MemorySegment __stream) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static void funlockfile(MemorySegment __stream) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __uflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("__uflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static FunctionDescriptor __uflow$descriptor() {
        return __uflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MethodHandle __uflow$handle() {
        return __uflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MemorySegment __uflow$address() {
        return __uflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static int __uflow(MemorySegment x0) {
        var mh$ = __uflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__uflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_INT
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("__overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static FunctionDescriptor __overflow$descriptor() {
        return __overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MethodHandle __overflow$handle() {
        return __overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MemorySegment __overflow$address() {
        return __overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static int __overflow(MemorySegment x0, int x1) {
        var mh$ = __overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__overflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UCC_COLL_TYPE_ALLGATHER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_ALLGATHER = 1
     * }
     */
    public static int UCC_COLL_TYPE_ALLGATHER() {
        return UCC_COLL_TYPE_ALLGATHER;
    }
    private static final int UCC_COLL_TYPE_ALLGATHERV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_ALLGATHERV = 2
     * }
     */
    public static int UCC_COLL_TYPE_ALLGATHERV() {
        return UCC_COLL_TYPE_ALLGATHERV;
    }
    private static final int UCC_COLL_TYPE_ALLREDUCE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_ALLREDUCE = 4
     * }
     */
    public static int UCC_COLL_TYPE_ALLREDUCE() {
        return UCC_COLL_TYPE_ALLREDUCE;
    }
    private static final int UCC_COLL_TYPE_ALLTOALL = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_ALLTOALL = 8
     * }
     */
    public static int UCC_COLL_TYPE_ALLTOALL() {
        return UCC_COLL_TYPE_ALLTOALL;
    }
    private static final int UCC_COLL_TYPE_ALLTOALLV = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_ALLTOALLV = 16
     * }
     */
    public static int UCC_COLL_TYPE_ALLTOALLV() {
        return UCC_COLL_TYPE_ALLTOALLV;
    }
    private static final int UCC_COLL_TYPE_BARRIER = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_BARRIER = 32
     * }
     */
    public static int UCC_COLL_TYPE_BARRIER() {
        return UCC_COLL_TYPE_BARRIER;
    }
    private static final int UCC_COLL_TYPE_BCAST = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_BCAST = 64
     * }
     */
    public static int UCC_COLL_TYPE_BCAST() {
        return UCC_COLL_TYPE_BCAST;
    }
    private static final int UCC_COLL_TYPE_FANIN = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_FANIN = 128
     * }
     */
    public static int UCC_COLL_TYPE_FANIN() {
        return UCC_COLL_TYPE_FANIN;
    }
    private static final int UCC_COLL_TYPE_FANOUT = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_FANOUT = 256
     * }
     */
    public static int UCC_COLL_TYPE_FANOUT() {
        return UCC_COLL_TYPE_FANOUT;
    }
    private static final int UCC_COLL_TYPE_GATHER = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_GATHER = 512
     * }
     */
    public static int UCC_COLL_TYPE_GATHER() {
        return UCC_COLL_TYPE_GATHER;
    }
    private static final int UCC_COLL_TYPE_GATHERV = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_GATHERV = 1024
     * }
     */
    public static int UCC_COLL_TYPE_GATHERV() {
        return UCC_COLL_TYPE_GATHERV;
    }
    private static final int UCC_COLL_TYPE_REDUCE = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_REDUCE = 2048
     * }
     */
    public static int UCC_COLL_TYPE_REDUCE() {
        return UCC_COLL_TYPE_REDUCE;
    }
    private static final int UCC_COLL_TYPE_REDUCE_SCATTER = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_REDUCE_SCATTER = 4096
     * }
     */
    public static int UCC_COLL_TYPE_REDUCE_SCATTER() {
        return UCC_COLL_TYPE_REDUCE_SCATTER;
    }
    private static final int UCC_COLL_TYPE_REDUCE_SCATTERV = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_REDUCE_SCATTERV = 8192
     * }
     */
    public static int UCC_COLL_TYPE_REDUCE_SCATTERV() {
        return UCC_COLL_TYPE_REDUCE_SCATTERV;
    }
    private static final int UCC_COLL_TYPE_SCATTER = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_SCATTER = 16384
     * }
     */
    public static int UCC_COLL_TYPE_SCATTER() {
        return UCC_COLL_TYPE_SCATTER;
    }
    private static final int UCC_COLL_TYPE_SCATTERV = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_SCATTERV = 32768
     * }
     */
    public static int UCC_COLL_TYPE_SCATTERV() {
        return UCC_COLL_TYPE_SCATTERV;
    }
    private static final int UCC_COLL_TYPE_LAST = (int)32769L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_TYPE_LAST = 32769
     * }
     */
    public static int UCC_COLL_TYPE_LAST() {
        return UCC_COLL_TYPE_LAST;
    }
    private static final int UCC_MEMORY_TYPE_HOST = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ucc_memory_type.UCC_MEMORY_TYPE_HOST = 0
     * }
     */
    public static int UCC_MEMORY_TYPE_HOST() {
        return UCC_MEMORY_TYPE_HOST;
    }
    private static final int UCC_MEMORY_TYPE_CUDA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucc_memory_type.UCC_MEMORY_TYPE_CUDA = 1
     * }
     */
    public static int UCC_MEMORY_TYPE_CUDA() {
        return UCC_MEMORY_TYPE_CUDA;
    }
    private static final int UCC_MEMORY_TYPE_CUDA_MANAGED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucc_memory_type.UCC_MEMORY_TYPE_CUDA_MANAGED = 2
     * }
     */
    public static int UCC_MEMORY_TYPE_CUDA_MANAGED() {
        return UCC_MEMORY_TYPE_CUDA_MANAGED;
    }
    private static final int UCC_MEMORY_TYPE_ROCM = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ucc_memory_type.UCC_MEMORY_TYPE_ROCM = 3
     * }
     */
    public static int UCC_MEMORY_TYPE_ROCM() {
        return UCC_MEMORY_TYPE_ROCM;
    }
    private static final int UCC_MEMORY_TYPE_ROCM_MANAGED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucc_memory_type.UCC_MEMORY_TYPE_ROCM_MANAGED = 4
     * }
     */
    public static int UCC_MEMORY_TYPE_ROCM_MANAGED() {
        return UCC_MEMORY_TYPE_ROCM_MANAGED;
    }
    private static final int UCC_MEMORY_TYPE_LAST = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ucc_memory_type.UCC_MEMORY_TYPE_LAST = 5
     * }
     */
    public static int UCC_MEMORY_TYPE_LAST() {
        return UCC_MEMORY_TYPE_LAST;
    }
    private static final int UCC_MEMORY_TYPE_UNKNOWN = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ucc_memory_type.UCC_MEMORY_TYPE_UNKNOWN = 5
     * }
     */
    public static int UCC_MEMORY_TYPE_UNKNOWN() {
        return UCC_MEMORY_TYPE_UNKNOWN;
    }
    /**
     * {@snippet lang=c :
     * typedef uint64_t ucc_datatype_t
     * }
     */
    public static final OfLong ucc_datatype_t = Ucc.C_LONG;
    private static final int UCC_GENERIC_DT_OPS_FIELD_FLAGS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucc_generic_dt_ops_field.UCC_GENERIC_DT_OPS_FIELD_FLAGS = 1
     * }
     */
    public static int UCC_GENERIC_DT_OPS_FIELD_FLAGS() {
        return UCC_GENERIC_DT_OPS_FIELD_FLAGS;
    }
    private static final int UCC_GENERIC_DT_OPS_FLAG_CONTIG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_GENERIC_DT_OPS_FLAG_CONTIG = 1
     * }
     */
    public static int UCC_GENERIC_DT_OPS_FLAG_CONTIG() {
        return UCC_GENERIC_DT_OPS_FLAG_CONTIG;
    }
    private static final int UCC_GENERIC_DT_OPS_FLAG_REDUCE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_GENERIC_DT_OPS_FLAG_REDUCE = 2
     * }
     */
    public static int UCC_GENERIC_DT_OPS_FLAG_REDUCE() {
        return UCC_GENERIC_DT_OPS_FLAG_REDUCE;
    }

    private static class ucc_dt_create_generic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_dt_create_generic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_dt_create_generic(const ucc_generic_dt_ops_t *ops, void *context, ucc_datatype_t *datatype_p)
     * }
     */
    public static FunctionDescriptor ucc_dt_create_generic$descriptor() {
        return ucc_dt_create_generic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_dt_create_generic(const ucc_generic_dt_ops_t *ops, void *context, ucc_datatype_t *datatype_p)
     * }
     */
    public static MethodHandle ucc_dt_create_generic$handle() {
        return ucc_dt_create_generic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_dt_create_generic(const ucc_generic_dt_ops_t *ops, void *context, ucc_datatype_t *datatype_p)
     * }
     */
    public static MemorySegment ucc_dt_create_generic$address() {
        return ucc_dt_create_generic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_dt_create_generic(const ucc_generic_dt_ops_t *ops, void *context, ucc_datatype_t *datatype_p)
     * }
     */
    public static int ucc_dt_create_generic(MemorySegment ops, MemorySegment context, MemorySegment datatype_p) {
        var mh$ = ucc_dt_create_generic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_dt_create_generic", ops, context, datatype_p);
            }
            return (int)mh$.invokeExact(ops, context, datatype_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_dt_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucc.C_LONG
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_dt_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucc_dt_destroy(ucc_datatype_t datatype)
     * }
     */
    public static FunctionDescriptor ucc_dt_destroy$descriptor() {
        return ucc_dt_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucc_dt_destroy(ucc_datatype_t datatype)
     * }
     */
    public static MethodHandle ucc_dt_destroy$handle() {
        return ucc_dt_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucc_dt_destroy(ucc_datatype_t datatype)
     * }
     */
    public static MemorySegment ucc_dt_destroy$address() {
        return ucc_dt_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucc_dt_destroy(ucc_datatype_t datatype)
     * }
     */
    public static void ucc_dt_destroy(long datatype) {
        var mh$ = ucc_dt_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_dt_destroy", datatype);
            }
            mh$.invokeExact(datatype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UCC_OP_SUM = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OP_SUM = 0
     * }
     */
    public static int UCC_OP_SUM() {
        return UCC_OP_SUM;
    }
    private static final int UCC_OP_PROD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OP_PROD = 1
     * }
     */
    public static int UCC_OP_PROD() {
        return UCC_OP_PROD;
    }
    private static final int UCC_OP_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OP_MAX = 2
     * }
     */
    public static int UCC_OP_MAX() {
        return UCC_OP_MAX;
    }
    private static final int UCC_OP_MIN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OP_MIN = 3
     * }
     */
    public static int UCC_OP_MIN() {
        return UCC_OP_MIN;
    }
    private static final int UCC_OP_LAND = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OP_LAND = 4
     * }
     */
    public static int UCC_OP_LAND() {
        return UCC_OP_LAND;
    }
    private static final int UCC_OP_LOR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OP_LOR = 5
     * }
     */
    public static int UCC_OP_LOR() {
        return UCC_OP_LOR;
    }
    private static final int UCC_OP_LXOR = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OP_LXOR = 6
     * }
     */
    public static int UCC_OP_LXOR() {
        return UCC_OP_LXOR;
    }
    private static final int UCC_OP_BAND = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OP_BAND = 7
     * }
     */
    public static int UCC_OP_BAND() {
        return UCC_OP_BAND;
    }
    private static final int UCC_OP_BOR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OP_BOR = 8
     * }
     */
    public static int UCC_OP_BOR() {
        return UCC_OP_BOR;
    }
    private static final int UCC_OP_BXOR = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OP_BXOR = 9
     * }
     */
    public static int UCC_OP_BXOR() {
        return UCC_OP_BXOR;
    }
    private static final int UCC_OP_MAXLOC = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OP_MAXLOC = 10
     * }
     */
    public static int UCC_OP_MAXLOC() {
        return UCC_OP_MAXLOC;
    }
    private static final int UCC_OP_MINLOC = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OP_MINLOC = 11
     * }
     */
    public static int UCC_OP_MINLOC() {
        return UCC_OP_MINLOC;
    }
    private static final int UCC_OP_AVG = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OP_AVG = 12
     * }
     */
    public static int UCC_OP_AVG() {
        return UCC_OP_AVG;
    }
    private static final int UCC_OP_LAST = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_OP_LAST = 13
     * }
     */
    public static int UCC_OP_LAST() {
        return UCC_OP_LAST;
    }
    private static final int UCC_THREAD_SINGLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_THREAD_SINGLE = 0
     * }
     */
    public static int UCC_THREAD_SINGLE() {
        return UCC_THREAD_SINGLE;
    }
    private static final int UCC_THREAD_FUNNELED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_THREAD_FUNNELED = 1
     * }
     */
    public static int UCC_THREAD_FUNNELED() {
        return UCC_THREAD_FUNNELED;
    }
    private static final int UCC_THREAD_MULTIPLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_THREAD_MULTIPLE = 2
     * }
     */
    public static int UCC_THREAD_MULTIPLE() {
        return UCC_THREAD_MULTIPLE;
    }
    private static final int UCC_NO_SYNC_COLLECTIVES = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_NO_SYNC_COLLECTIVES = 0
     * }
     */
    public static int UCC_NO_SYNC_COLLECTIVES() {
        return UCC_NO_SYNC_COLLECTIVES;
    }
    private static final int UCC_SYNC_COLLECTIVES = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_SYNC_COLLECTIVES = 1
     * }
     */
    public static int UCC_SYNC_COLLECTIVES() {
        return UCC_SYNC_COLLECTIVES;
    }
    private static final int UCC_LIB_PARAM_FIELD_THREAD_MODE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucc_lib_params_field.UCC_LIB_PARAM_FIELD_THREAD_MODE = 1
     * }
     */
    public static int UCC_LIB_PARAM_FIELD_THREAD_MODE() {
        return UCC_LIB_PARAM_FIELD_THREAD_MODE;
    }
    private static final int UCC_LIB_PARAM_FIELD_COLL_TYPES = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucc_lib_params_field.UCC_LIB_PARAM_FIELD_COLL_TYPES = 2
     * }
     */
    public static int UCC_LIB_PARAM_FIELD_COLL_TYPES() {
        return UCC_LIB_PARAM_FIELD_COLL_TYPES;
    }
    private static final int UCC_LIB_PARAM_FIELD_REDUCTION_TYPES = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucc_lib_params_field.UCC_LIB_PARAM_FIELD_REDUCTION_TYPES = 4
     * }
     */
    public static int UCC_LIB_PARAM_FIELD_REDUCTION_TYPES() {
        return UCC_LIB_PARAM_FIELD_REDUCTION_TYPES;
    }
    private static final int UCC_LIB_PARAM_FIELD_SYNC_TYPE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucc_lib_params_field.UCC_LIB_PARAM_FIELD_SYNC_TYPE = 8
     * }
     */
    public static int UCC_LIB_PARAM_FIELD_SYNC_TYPE() {
        return UCC_LIB_PARAM_FIELD_SYNC_TYPE;
    }
    private static final int UCC_LIB_ATTR_FIELD_THREAD_MODE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucc_lib_attr_field.UCC_LIB_ATTR_FIELD_THREAD_MODE = 1
     * }
     */
    public static int UCC_LIB_ATTR_FIELD_THREAD_MODE() {
        return UCC_LIB_ATTR_FIELD_THREAD_MODE;
    }
    private static final int UCC_LIB_ATTR_FIELD_COLL_TYPES = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucc_lib_attr_field.UCC_LIB_ATTR_FIELD_COLL_TYPES = 2
     * }
     */
    public static int UCC_LIB_ATTR_FIELD_COLL_TYPES() {
        return UCC_LIB_ATTR_FIELD_COLL_TYPES;
    }
    private static final int UCC_LIB_ATTR_FIELD_REDUCTION_TYPES = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucc_lib_attr_field.UCC_LIB_ATTR_FIELD_REDUCTION_TYPES = 4
     * }
     */
    public static int UCC_LIB_ATTR_FIELD_REDUCTION_TYPES() {
        return UCC_LIB_ATTR_FIELD_REDUCTION_TYPES;
    }
    private static final int UCC_LIB_ATTR_FIELD_SYNC_TYPE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucc_lib_attr_field.UCC_LIB_ATTR_FIELD_SYNC_TYPE = 8
     * }
     */
    public static int UCC_LIB_ATTR_FIELD_SYNC_TYPE() {
        return UCC_LIB_ATTR_FIELD_SYNC_TYPE;
    }

    private static class ucc_lib_config_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_lib_config_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_lib_config_read(const char *env_prefix, const char *filename, ucc_lib_config_h *config)
     * }
     */
    public static FunctionDescriptor ucc_lib_config_read$descriptor() {
        return ucc_lib_config_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_lib_config_read(const char *env_prefix, const char *filename, ucc_lib_config_h *config)
     * }
     */
    public static MethodHandle ucc_lib_config_read$handle() {
        return ucc_lib_config_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_lib_config_read(const char *env_prefix, const char *filename, ucc_lib_config_h *config)
     * }
     */
    public static MemorySegment ucc_lib_config_read$address() {
        return ucc_lib_config_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_lib_config_read(const char *env_prefix, const char *filename, ucc_lib_config_h *config)
     * }
     */
    public static int ucc_lib_config_read(MemorySegment env_prefix, MemorySegment filename, MemorySegment config) {
        var mh$ = ucc_lib_config_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_lib_config_read", env_prefix, filename, config);
            }
            return (int)mh$.invokeExact(env_prefix, filename, config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_lib_config_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_lib_config_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucc_lib_config_release(ucc_lib_config_h config)
     * }
     */
    public static FunctionDescriptor ucc_lib_config_release$descriptor() {
        return ucc_lib_config_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucc_lib_config_release(ucc_lib_config_h config)
     * }
     */
    public static MethodHandle ucc_lib_config_release$handle() {
        return ucc_lib_config_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucc_lib_config_release(ucc_lib_config_h config)
     * }
     */
    public static MemorySegment ucc_lib_config_release$address() {
        return ucc_lib_config_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucc_lib_config_release(ucc_lib_config_h config)
     * }
     */
    public static void ucc_lib_config_release(MemorySegment config) {
        var mh$ = ucc_lib_config_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_lib_config_release", config);
            }
            mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_lib_config_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_INT
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_lib_config_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucc_lib_config_print(const ucc_lib_config_h config, FILE *stream, const char *title, ucc_config_print_flags_t print_flags)
     * }
     */
    public static FunctionDescriptor ucc_lib_config_print$descriptor() {
        return ucc_lib_config_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucc_lib_config_print(const ucc_lib_config_h config, FILE *stream, const char *title, ucc_config_print_flags_t print_flags)
     * }
     */
    public static MethodHandle ucc_lib_config_print$handle() {
        return ucc_lib_config_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucc_lib_config_print(const ucc_lib_config_h config, FILE *stream, const char *title, ucc_config_print_flags_t print_flags)
     * }
     */
    public static MemorySegment ucc_lib_config_print$address() {
        return ucc_lib_config_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucc_lib_config_print(const ucc_lib_config_h config, FILE *stream, const char *title, ucc_config_print_flags_t print_flags)
     * }
     */
    public static void ucc_lib_config_print(MemorySegment config, MemorySegment stream, MemorySegment title, int print_flags) {
        var mh$ = ucc_lib_config_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_lib_config_print", config, stream, title, print_flags);
            }
            mh$.invokeExact(config, stream, title, print_flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_lib_config_modify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_lib_config_modify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_lib_config_modify(ucc_lib_config_h config, const char *name, const char *value)
     * }
     */
    public static FunctionDescriptor ucc_lib_config_modify$descriptor() {
        return ucc_lib_config_modify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_lib_config_modify(ucc_lib_config_h config, const char *name, const char *value)
     * }
     */
    public static MethodHandle ucc_lib_config_modify$handle() {
        return ucc_lib_config_modify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_lib_config_modify(ucc_lib_config_h config, const char *name, const char *value)
     * }
     */
    public static MemorySegment ucc_lib_config_modify$address() {
        return ucc_lib_config_modify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_lib_config_modify(ucc_lib_config_h config, const char *name, const char *value)
     * }
     */
    public static int ucc_lib_config_modify(MemorySegment config, MemorySegment name, MemorySegment value) {
        var mh$ = ucc_lib_config_modify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_lib_config_modify", config, name, value);
            }
            return (int)mh$.invokeExact(config, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_get_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_get_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucc_get_version(unsigned int *major_version, unsigned int *minor_version, unsigned int *release_number)
     * }
     */
    public static FunctionDescriptor ucc_get_version$descriptor() {
        return ucc_get_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucc_get_version(unsigned int *major_version, unsigned int *minor_version, unsigned int *release_number)
     * }
     */
    public static MethodHandle ucc_get_version$handle() {
        return ucc_get_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucc_get_version(unsigned int *major_version, unsigned int *minor_version, unsigned int *release_number)
     * }
     */
    public static MemorySegment ucc_get_version$address() {
        return ucc_get_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucc_get_version(unsigned int *major_version, unsigned int *minor_version, unsigned int *release_number)
     * }
     */
    public static void ucc_get_version(MemorySegment major_version, MemorySegment minor_version, MemorySegment release_number) {
        var mh$ = ucc_get_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_get_version", major_version, minor_version, release_number);
            }
            mh$.invokeExact(major_version, minor_version, release_number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_get_version_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_POINTER    );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_get_version_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ucc_get_version_string()
     * }
     */
    public static FunctionDescriptor ucc_get_version_string$descriptor() {
        return ucc_get_version_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ucc_get_version_string()
     * }
     */
    public static MethodHandle ucc_get_version_string$handle() {
        return ucc_get_version_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ucc_get_version_string()
     * }
     */
    public static MemorySegment ucc_get_version_string$address() {
        return ucc_get_version_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ucc_get_version_string()
     * }
     */
    public static MemorySegment ucc_get_version_string() {
        var mh$ = ucc_get_version_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_get_version_string");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_init_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_INT,
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_init_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_init_version(unsigned int api_major_version, unsigned int api_minor_version, const ucc_lib_params_t *params, const ucc_lib_config_h config, ucc_lib_h *lib_p)
     * }
     */
    public static FunctionDescriptor ucc_init_version$descriptor() {
        return ucc_init_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_init_version(unsigned int api_major_version, unsigned int api_minor_version, const ucc_lib_params_t *params, const ucc_lib_config_h config, ucc_lib_h *lib_p)
     * }
     */
    public static MethodHandle ucc_init_version$handle() {
        return ucc_init_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_init_version(unsigned int api_major_version, unsigned int api_minor_version, const ucc_lib_params_t *params, const ucc_lib_config_h config, ucc_lib_h *lib_p)
     * }
     */
    public static MemorySegment ucc_init_version$address() {
        return ucc_init_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_init_version(unsigned int api_major_version, unsigned int api_minor_version, const ucc_lib_params_t *params, const ucc_lib_config_h config, ucc_lib_h *lib_p)
     * }
     */
    public static int ucc_init_version(int api_major_version, int api_minor_version, MemorySegment params, MemorySegment config, MemorySegment lib_p) {
        var mh$ = ucc_init_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_init_version", api_major_version, api_minor_version, params, config, lib_p);
            }
            return (int)mh$.invokeExact(api_major_version, api_minor_version, params, config, lib_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_finalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_finalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_finalize(ucc_lib_h lib_p)
     * }
     */
    public static FunctionDescriptor ucc_finalize$descriptor() {
        return ucc_finalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_finalize(ucc_lib_h lib_p)
     * }
     */
    public static MethodHandle ucc_finalize$handle() {
        return ucc_finalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_finalize(ucc_lib_h lib_p)
     * }
     */
    public static MemorySegment ucc_finalize$address() {
        return ucc_finalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_finalize(ucc_lib_h lib_p)
     * }
     */
    public static int ucc_finalize(MemorySegment lib_p) {
        var mh$ = ucc_finalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_finalize", lib_p);
            }
            return (int)mh$.invokeExact(lib_p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_lib_get_attr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_lib_get_attr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_lib_get_attr(ucc_lib_h lib_p, ucc_lib_attr_t *lib_attr)
     * }
     */
    public static FunctionDescriptor ucc_lib_get_attr$descriptor() {
        return ucc_lib_get_attr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_lib_get_attr(ucc_lib_h lib_p, ucc_lib_attr_t *lib_attr)
     * }
     */
    public static MethodHandle ucc_lib_get_attr$handle() {
        return ucc_lib_get_attr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_lib_get_attr(ucc_lib_h lib_p, ucc_lib_attr_t *lib_attr)
     * }
     */
    public static MemorySegment ucc_lib_get_attr$address() {
        return ucc_lib_get_attr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_lib_get_attr(ucc_lib_h lib_p, ucc_lib_attr_t *lib_attr)
     * }
     */
    public static int ucc_lib_get_attr(MemorySegment lib_p, MemorySegment lib_attr) {
        var mh$ = ucc_lib_get_attr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_lib_get_attr", lib_p, lib_attr);
            }
            return (int)mh$.invokeExact(lib_p, lib_attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UCC_CONTEXT_EXCLUSIVE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_CONTEXT_EXCLUSIVE = 0
     * }
     */
    public static int UCC_CONTEXT_EXCLUSIVE() {
        return UCC_CONTEXT_EXCLUSIVE;
    }
    private static final int UCC_CONTEXT_SHARED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_CONTEXT_SHARED = 1
     * }
     */
    public static int UCC_CONTEXT_SHARED() {
        return UCC_CONTEXT_SHARED;
    }
    private static final int UCC_CONTEXT_PARAM_FIELD_TYPE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucc_context_params_field.UCC_CONTEXT_PARAM_FIELD_TYPE = 1
     * }
     */
    public static int UCC_CONTEXT_PARAM_FIELD_TYPE() {
        return UCC_CONTEXT_PARAM_FIELD_TYPE;
    }
    private static final int UCC_CONTEXT_PARAM_FIELD_SYNC_TYPE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucc_context_params_field.UCC_CONTEXT_PARAM_FIELD_SYNC_TYPE = 2
     * }
     */
    public static int UCC_CONTEXT_PARAM_FIELD_SYNC_TYPE() {
        return UCC_CONTEXT_PARAM_FIELD_SYNC_TYPE;
    }
    private static final int UCC_CONTEXT_PARAM_FIELD_OOB = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucc_context_params_field.UCC_CONTEXT_PARAM_FIELD_OOB = 4
     * }
     */
    public static int UCC_CONTEXT_PARAM_FIELD_OOB() {
        return UCC_CONTEXT_PARAM_FIELD_OOB;
    }
    private static final int UCC_CONTEXT_PARAM_FIELD_ID = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucc_context_params_field.UCC_CONTEXT_PARAM_FIELD_ID = 8
     * }
     */
    public static int UCC_CONTEXT_PARAM_FIELD_ID() {
        return UCC_CONTEXT_PARAM_FIELD_ID;
    }
    private static final int UCC_CONTEXT_PARAM_FIELD_MEM_PARAMS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ucc_context_params_field.UCC_CONTEXT_PARAM_FIELD_MEM_PARAMS = 16
     * }
     */
    public static int UCC_CONTEXT_PARAM_FIELD_MEM_PARAMS() {
        return UCC_CONTEXT_PARAM_FIELD_MEM_PARAMS;
    }
    private static final int UCC_CONTEXT_ATTR_FIELD_TYPE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucc_context_attr_field.UCC_CONTEXT_ATTR_FIELD_TYPE = 1
     * }
     */
    public static int UCC_CONTEXT_ATTR_FIELD_TYPE() {
        return UCC_CONTEXT_ATTR_FIELD_TYPE;
    }
    private static final int UCC_CONTEXT_ATTR_FIELD_SYNC_TYPE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucc_context_attr_field.UCC_CONTEXT_ATTR_FIELD_SYNC_TYPE = 2
     * }
     */
    public static int UCC_CONTEXT_ATTR_FIELD_SYNC_TYPE() {
        return UCC_CONTEXT_ATTR_FIELD_SYNC_TYPE;
    }
    private static final int UCC_CONTEXT_ATTR_FIELD_CTX_ADDR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucc_context_attr_field.UCC_CONTEXT_ATTR_FIELD_CTX_ADDR = 4
     * }
     */
    public static int UCC_CONTEXT_ATTR_FIELD_CTX_ADDR() {
        return UCC_CONTEXT_ATTR_FIELD_CTX_ADDR;
    }
    private static final int UCC_CONTEXT_ATTR_FIELD_CTX_ADDR_LEN = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucc_context_attr_field.UCC_CONTEXT_ATTR_FIELD_CTX_ADDR_LEN = 8
     * }
     */
    public static int UCC_CONTEXT_ATTR_FIELD_CTX_ADDR_LEN() {
        return UCC_CONTEXT_ATTR_FIELD_CTX_ADDR_LEN;
    }
    private static final int UCC_CONTEXT_ATTR_FIELD_WORK_BUFFER_SIZE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ucc_context_attr_field.UCC_CONTEXT_ATTR_FIELD_WORK_BUFFER_SIZE = 16
     * }
     */
    public static int UCC_CONTEXT_ATTR_FIELD_WORK_BUFFER_SIZE() {
        return UCC_CONTEXT_ATTR_FIELD_WORK_BUFFER_SIZE;
    }

    private static class ucc_context_config_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_context_config_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_config_read(ucc_lib_h lib_handle, const char *filename, ucc_context_config_h *config)
     * }
     */
    public static FunctionDescriptor ucc_context_config_read$descriptor() {
        return ucc_context_config_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_config_read(ucc_lib_h lib_handle, const char *filename, ucc_context_config_h *config)
     * }
     */
    public static MethodHandle ucc_context_config_read$handle() {
        return ucc_context_config_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_config_read(ucc_lib_h lib_handle, const char *filename, ucc_context_config_h *config)
     * }
     */
    public static MemorySegment ucc_context_config_read$address() {
        return ucc_context_config_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_context_config_read(ucc_lib_h lib_handle, const char *filename, ucc_context_config_h *config)
     * }
     */
    public static int ucc_context_config_read(MemorySegment lib_handle, MemorySegment filename, MemorySegment config) {
        var mh$ = ucc_context_config_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_context_config_read", lib_handle, filename, config);
            }
            return (int)mh$.invokeExact(lib_handle, filename, config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_context_config_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_context_config_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucc_context_config_release(ucc_context_config_h config)
     * }
     */
    public static FunctionDescriptor ucc_context_config_release$descriptor() {
        return ucc_context_config_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucc_context_config_release(ucc_context_config_h config)
     * }
     */
    public static MethodHandle ucc_context_config_release$handle() {
        return ucc_context_config_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucc_context_config_release(ucc_context_config_h config)
     * }
     */
    public static MemorySegment ucc_context_config_release$address() {
        return ucc_context_config_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucc_context_config_release(ucc_context_config_h config)
     * }
     */
    public static void ucc_context_config_release(MemorySegment config) {
        var mh$ = ucc_context_config_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_context_config_release", config);
            }
            mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_context_config_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_INT
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_context_config_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ucc_context_config_print(const ucc_context_config_h config, FILE *stream, const char *title, ucc_config_print_flags_t print_flags)
     * }
     */
    public static FunctionDescriptor ucc_context_config_print$descriptor() {
        return ucc_context_config_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ucc_context_config_print(const ucc_context_config_h config, FILE *stream, const char *title, ucc_config_print_flags_t print_flags)
     * }
     */
    public static MethodHandle ucc_context_config_print$handle() {
        return ucc_context_config_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ucc_context_config_print(const ucc_context_config_h config, FILE *stream, const char *title, ucc_config_print_flags_t print_flags)
     * }
     */
    public static MemorySegment ucc_context_config_print$address() {
        return ucc_context_config_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ucc_context_config_print(const ucc_context_config_h config, FILE *stream, const char *title, ucc_config_print_flags_t print_flags)
     * }
     */
    public static void ucc_context_config_print(MemorySegment config, MemorySegment stream, MemorySegment title, int print_flags) {
        var mh$ = ucc_context_config_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_context_config_print", config, stream, title, print_flags);
            }
            mh$.invokeExact(config, stream, title, print_flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_context_config_modify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_context_config_modify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_config_modify(ucc_context_config_h config, const char *component, const char *name, const char *value)
     * }
     */
    public static FunctionDescriptor ucc_context_config_modify$descriptor() {
        return ucc_context_config_modify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_config_modify(ucc_context_config_h config, const char *component, const char *name, const char *value)
     * }
     */
    public static MethodHandle ucc_context_config_modify$handle() {
        return ucc_context_config_modify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_config_modify(ucc_context_config_h config, const char *component, const char *name, const char *value)
     * }
     */
    public static MemorySegment ucc_context_config_modify$address() {
        return ucc_context_config_modify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_context_config_modify(ucc_context_config_h config, const char *component, const char *name, const char *value)
     * }
     */
    public static int ucc_context_config_modify(MemorySegment config, MemorySegment component, MemorySegment name, MemorySegment value) {
        var mh$ = ucc_context_config_modify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_context_config_modify", config, component, name, value);
            }
            return (int)mh$.invokeExact(config, component, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_context_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_context_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_create(ucc_lib_h lib_handle, const ucc_context_params_t *params, const ucc_context_config_h config, ucc_context_h *context)
     * }
     */
    public static FunctionDescriptor ucc_context_create$descriptor() {
        return ucc_context_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_create(ucc_lib_h lib_handle, const ucc_context_params_t *params, const ucc_context_config_h config, ucc_context_h *context)
     * }
     */
    public static MethodHandle ucc_context_create$handle() {
        return ucc_context_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_create(ucc_lib_h lib_handle, const ucc_context_params_t *params, const ucc_context_config_h config, ucc_context_h *context)
     * }
     */
    public static MemorySegment ucc_context_create$address() {
        return ucc_context_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_context_create(ucc_lib_h lib_handle, const ucc_context_params_t *params, const ucc_context_config_h config, ucc_context_h *context)
     * }
     */
    public static int ucc_context_create(MemorySegment lib_handle, MemorySegment params, MemorySegment config, MemorySegment context) {
        var mh$ = ucc_context_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_context_create", lib_handle, params, config, context);
            }
            return (int)mh$.invokeExact(lib_handle, params, config, context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_context_progress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_context_progress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_progress(ucc_context_h context)
     * }
     */
    public static FunctionDescriptor ucc_context_progress$descriptor() {
        return ucc_context_progress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_progress(ucc_context_h context)
     * }
     */
    public static MethodHandle ucc_context_progress$handle() {
        return ucc_context_progress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_progress(ucc_context_h context)
     * }
     */
    public static MemorySegment ucc_context_progress$address() {
        return ucc_context_progress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_context_progress(ucc_context_h context)
     * }
     */
    public static int ucc_context_progress(MemorySegment context) {
        var mh$ = ucc_context_progress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_context_progress", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_context_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_context_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_destroy(ucc_context_h context)
     * }
     */
    public static FunctionDescriptor ucc_context_destroy$descriptor() {
        return ucc_context_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_destroy(ucc_context_h context)
     * }
     */
    public static MethodHandle ucc_context_destroy$handle() {
        return ucc_context_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_destroy(ucc_context_h context)
     * }
     */
    public static MemorySegment ucc_context_destroy$address() {
        return ucc_context_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_context_destroy(ucc_context_h context)
     * }
     */
    public static int ucc_context_destroy(MemorySegment context) {
        var mh$ = ucc_context_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_context_destroy", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_context_get_attr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_context_get_attr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_get_attr(ucc_context_h context, ucc_context_attr_t *context_attr)
     * }
     */
    public static FunctionDescriptor ucc_context_get_attr$descriptor() {
        return ucc_context_get_attr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_get_attr(ucc_context_h context, ucc_context_attr_t *context_attr)
     * }
     */
    public static MethodHandle ucc_context_get_attr$handle() {
        return ucc_context_get_attr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_context_get_attr(ucc_context_h context, ucc_context_attr_t *context_attr)
     * }
     */
    public static MemorySegment ucc_context_get_attr$address() {
        return ucc_context_get_attr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_context_get_attr(ucc_context_h context, ucc_context_attr_t *context_attr)
     * }
     */
    public static int ucc_context_get_attr(MemorySegment context, MemorySegment context_attr) {
        var mh$ = ucc_context_get_attr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_context_get_attr", context, context_attr);
            }
            return (int)mh$.invokeExact(context, context_attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UCC_TEAM_PARAM_FIELD_ORDERING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_params_field.UCC_TEAM_PARAM_FIELD_ORDERING = 1
     * }
     */
    public static int UCC_TEAM_PARAM_FIELD_ORDERING() {
        return UCC_TEAM_PARAM_FIELD_ORDERING;
    }
    private static final int UCC_TEAM_PARAM_FIELD_OUTSTANDING_COLLS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_params_field.UCC_TEAM_PARAM_FIELD_OUTSTANDING_COLLS = 2
     * }
     */
    public static int UCC_TEAM_PARAM_FIELD_OUTSTANDING_COLLS() {
        return UCC_TEAM_PARAM_FIELD_OUTSTANDING_COLLS;
    }
    private static final int UCC_TEAM_PARAM_FIELD_EP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_params_field.UCC_TEAM_PARAM_FIELD_EP = 4
     * }
     */
    public static int UCC_TEAM_PARAM_FIELD_EP() {
        return UCC_TEAM_PARAM_FIELD_EP;
    }
    private static final int UCC_TEAM_PARAM_FIELD_EP_LIST = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_params_field.UCC_TEAM_PARAM_FIELD_EP_LIST = 8
     * }
     */
    public static int UCC_TEAM_PARAM_FIELD_EP_LIST() {
        return UCC_TEAM_PARAM_FIELD_EP_LIST;
    }
    private static final int UCC_TEAM_PARAM_FIELD_EP_RANGE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_params_field.UCC_TEAM_PARAM_FIELD_EP_RANGE = 16
     * }
     */
    public static int UCC_TEAM_PARAM_FIELD_EP_RANGE() {
        return UCC_TEAM_PARAM_FIELD_EP_RANGE;
    }
    private static final int UCC_TEAM_PARAM_FIELD_TEAM_SIZE = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_params_field.UCC_TEAM_PARAM_FIELD_TEAM_SIZE = 32
     * }
     */
    public static int UCC_TEAM_PARAM_FIELD_TEAM_SIZE() {
        return UCC_TEAM_PARAM_FIELD_TEAM_SIZE;
    }
    private static final int UCC_TEAM_PARAM_FIELD_SYNC_TYPE = (int)64L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_params_field.UCC_TEAM_PARAM_FIELD_SYNC_TYPE = 64
     * }
     */
    public static int UCC_TEAM_PARAM_FIELD_SYNC_TYPE() {
        return UCC_TEAM_PARAM_FIELD_SYNC_TYPE;
    }
    private static final int UCC_TEAM_PARAM_FIELD_OOB = (int)128L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_params_field.UCC_TEAM_PARAM_FIELD_OOB = 128
     * }
     */
    public static int UCC_TEAM_PARAM_FIELD_OOB() {
        return UCC_TEAM_PARAM_FIELD_OOB;
    }
    private static final int UCC_TEAM_PARAM_FIELD_P2P_CONN = (int)256L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_params_field.UCC_TEAM_PARAM_FIELD_P2P_CONN = 256
     * }
     */
    public static int UCC_TEAM_PARAM_FIELD_P2P_CONN() {
        return UCC_TEAM_PARAM_FIELD_P2P_CONN;
    }
    private static final int UCC_TEAM_PARAM_FIELD_MEM_PARAMS = (int)512L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_params_field.UCC_TEAM_PARAM_FIELD_MEM_PARAMS = 512
     * }
     */
    public static int UCC_TEAM_PARAM_FIELD_MEM_PARAMS() {
        return UCC_TEAM_PARAM_FIELD_MEM_PARAMS;
    }
    private static final int UCC_TEAM_PARAM_FIELD_EP_MAP = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_params_field.UCC_TEAM_PARAM_FIELD_EP_MAP = 1024
     * }
     */
    public static int UCC_TEAM_PARAM_FIELD_EP_MAP() {
        return UCC_TEAM_PARAM_FIELD_EP_MAP;
    }
    private static final int UCC_TEAM_PARAM_FIELD_ID = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_params_field.UCC_TEAM_PARAM_FIELD_ID = 2048
     * }
     */
    public static int UCC_TEAM_PARAM_FIELD_ID() {
        return UCC_TEAM_PARAM_FIELD_ID;
    }
    private static final int UCC_TEAM_PARAM_FIELD_FLAGS = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_params_field.UCC_TEAM_PARAM_FIELD_FLAGS = 4096
     * }
     */
    public static int UCC_TEAM_PARAM_FIELD_FLAGS() {
        return UCC_TEAM_PARAM_FIELD_FLAGS;
    }
    private static final int UCC_TEAM_ATTR_FIELD_POST_ORDERING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_attr_field.UCC_TEAM_ATTR_FIELD_POST_ORDERING = 1
     * }
     */
    public static int UCC_TEAM_ATTR_FIELD_POST_ORDERING() {
        return UCC_TEAM_ATTR_FIELD_POST_ORDERING;
    }
    private static final int UCC_TEAM_ATTR_FIELD_OUTSTANDING_CALLS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_attr_field.UCC_TEAM_ATTR_FIELD_OUTSTANDING_CALLS = 2
     * }
     */
    public static int UCC_TEAM_ATTR_FIELD_OUTSTANDING_CALLS() {
        return UCC_TEAM_ATTR_FIELD_OUTSTANDING_CALLS;
    }
    private static final int UCC_TEAM_ATTR_FIELD_EP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_attr_field.UCC_TEAM_ATTR_FIELD_EP = 4
     * }
     */
    public static int UCC_TEAM_ATTR_FIELD_EP() {
        return UCC_TEAM_ATTR_FIELD_EP;
    }
    private static final int UCC_TEAM_ATTR_FIELD_EP_RANGE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_attr_field.UCC_TEAM_ATTR_FIELD_EP_RANGE = 8
     * }
     */
    public static int UCC_TEAM_ATTR_FIELD_EP_RANGE() {
        return UCC_TEAM_ATTR_FIELD_EP_RANGE;
    }
    private static final int UCC_TEAM_ATTR_FIELD_SYNC_TYPE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_attr_field.UCC_TEAM_ATTR_FIELD_SYNC_TYPE = 16
     * }
     */
    public static int UCC_TEAM_ATTR_FIELD_SYNC_TYPE() {
        return UCC_TEAM_ATTR_FIELD_SYNC_TYPE;
    }
    private static final int UCC_TEAM_ATTR_FIELD_MEM_PARAMS = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_attr_field.UCC_TEAM_ATTR_FIELD_MEM_PARAMS = 32
     * }
     */
    public static int UCC_TEAM_ATTR_FIELD_MEM_PARAMS() {
        return UCC_TEAM_ATTR_FIELD_MEM_PARAMS;
    }
    private static final int UCC_TEAM_ATTR_FIELD_SIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_attr_field.UCC_TEAM_ATTR_FIELD_SIZE = 64
     * }
     */
    public static int UCC_TEAM_ATTR_FIELD_SIZE() {
        return UCC_TEAM_ATTR_FIELD_SIZE;
    }
    private static final int UCC_TEAM_ATTR_FIELD_EPS = (int)128L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_attr_field.UCC_TEAM_ATTR_FIELD_EPS = 128
     * }
     */
    public static int UCC_TEAM_ATTR_FIELD_EPS() {
        return UCC_TEAM_ATTR_FIELD_EPS;
    }
    private static final int UCC_TEAM_FLAG_COLL_WORK_BUFFER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucc_team_flags.UCC_TEAM_FLAG_COLL_WORK_BUFFER = 1
     * }
     */
    public static int UCC_TEAM_FLAG_COLL_WORK_BUFFER() {
        return UCC_TEAM_FLAG_COLL_WORK_BUFFER;
    }
    private static final int UCC_COLLECTIVE_POST_ORDERED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLLECTIVE_POST_ORDERED = 0
     * }
     */
    public static int UCC_COLLECTIVE_POST_ORDERED() {
        return UCC_COLLECTIVE_POST_ORDERED;
    }
    private static final int UCC_COLLECTIVE_POST_UNORDERED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLLECTIVE_POST_UNORDERED = 1
     * }
     */
    public static int UCC_COLLECTIVE_POST_UNORDERED() {
        return UCC_COLLECTIVE_POST_UNORDERED;
    }
    private static final int UCC_COLLECTIVE_INIT_ORDERED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLLECTIVE_INIT_ORDERED = 2
     * }
     */
    public static int UCC_COLLECTIVE_INIT_ORDERED() {
        return UCC_COLLECTIVE_INIT_ORDERED;
    }
    private static final int UCC_COLLECTIVE_INIT_UNORDERED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLLECTIVE_INIT_UNORDERED = 3
     * }
     */
    public static int UCC_COLLECTIVE_INIT_UNORDERED() {
        return UCC_COLLECTIVE_INIT_UNORDERED;
    }
    private static final int UCC_COLLECTIVE_INIT_AND_POST_ORDERED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLLECTIVE_INIT_AND_POST_ORDERED = 4
     * }
     */
    public static int UCC_COLLECTIVE_INIT_AND_POST_ORDERED() {
        return UCC_COLLECTIVE_INIT_AND_POST_ORDERED;
    }
    private static final int UCC_COLLECTIVE_INIT_AND_POST_UNORDERED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLLECTIVE_INIT_AND_POST_UNORDERED = 5
     * }
     */
    public static int UCC_COLLECTIVE_INIT_AND_POST_UNORDERED() {
        return UCC_COLLECTIVE_INIT_AND_POST_UNORDERED;
    }
    private static final int UCC_COLLECTIVE_EP_RANGE_CONTIG = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLLECTIVE_EP_RANGE_CONTIG = 0
     * }
     */
    public static int UCC_COLLECTIVE_EP_RANGE_CONTIG() {
        return UCC_COLLECTIVE_EP_RANGE_CONTIG;
    }
    private static final int UCC_COLLECTIVE_EP_RANGE_NONCONTIG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLLECTIVE_EP_RANGE_NONCONTIG = 1
     * }
     */
    public static int UCC_COLLECTIVE_EP_RANGE_NONCONTIG() {
        return UCC_COLLECTIVE_EP_RANGE_NONCONTIG;
    }
    private static final int UCC_EP_MAP_FULL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_EP_MAP_FULL = 1
     * }
     */
    public static int UCC_EP_MAP_FULL() {
        return UCC_EP_MAP_FULL;
    }
    private static final int UCC_EP_MAP_STRIDED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_EP_MAP_STRIDED = 2
     * }
     */
    public static int UCC_EP_MAP_STRIDED() {
        return UCC_EP_MAP_STRIDED;
    }
    private static final int UCC_EP_MAP_ARRAY = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_EP_MAP_ARRAY = 3
     * }
     */
    public static int UCC_EP_MAP_ARRAY() {
        return UCC_EP_MAP_ARRAY;
    }
    private static final int UCC_EP_MAP_CB = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_EP_MAP_CB = 4
     * }
     */
    public static int UCC_EP_MAP_CB() {
        return UCC_EP_MAP_CB;
    }

    private static class ucc_team_create_post {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_team_create_post");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_team_create_post(ucc_context_h *contexts, uint32_t num_contexts, const ucc_team_params_t *team_params, ucc_team_h *new_team)
     * }
     */
    public static FunctionDescriptor ucc_team_create_post$descriptor() {
        return ucc_team_create_post.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_team_create_post(ucc_context_h *contexts, uint32_t num_contexts, const ucc_team_params_t *team_params, ucc_team_h *new_team)
     * }
     */
    public static MethodHandle ucc_team_create_post$handle() {
        return ucc_team_create_post.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_team_create_post(ucc_context_h *contexts, uint32_t num_contexts, const ucc_team_params_t *team_params, ucc_team_h *new_team)
     * }
     */
    public static MemorySegment ucc_team_create_post$address() {
        return ucc_team_create_post.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_team_create_post(ucc_context_h *contexts, uint32_t num_contexts, const ucc_team_params_t *team_params, ucc_team_h *new_team)
     * }
     */
    public static int ucc_team_create_post(MemorySegment contexts, int num_contexts, MemorySegment team_params, MemorySegment new_team) {
        var mh$ = ucc_team_create_post.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_team_create_post", contexts, num_contexts, team_params, new_team);
            }
            return (int)mh$.invokeExact(contexts, num_contexts, team_params, new_team);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_team_create_test {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_team_create_test");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_team_create_test(ucc_team_h team)
     * }
     */
    public static FunctionDescriptor ucc_team_create_test$descriptor() {
        return ucc_team_create_test.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_team_create_test(ucc_team_h team)
     * }
     */
    public static MethodHandle ucc_team_create_test$handle() {
        return ucc_team_create_test.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_team_create_test(ucc_team_h team)
     * }
     */
    public static MemorySegment ucc_team_create_test$address() {
        return ucc_team_create_test.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_team_create_test(ucc_team_h team)
     * }
     */
    public static int ucc_team_create_test(MemorySegment team) {
        var mh$ = ucc_team_create_test.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_team_create_test", team);
            }
            return (int)mh$.invokeExact(team);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_team_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_team_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_team_destroy(ucc_team_h team)
     * }
     */
    public static FunctionDescriptor ucc_team_destroy$descriptor() {
        return ucc_team_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_team_destroy(ucc_team_h team)
     * }
     */
    public static MethodHandle ucc_team_destroy$handle() {
        return ucc_team_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_team_destroy(ucc_team_h team)
     * }
     */
    public static MemorySegment ucc_team_destroy$address() {
        return ucc_team_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_team_destroy(ucc_team_h team)
     * }
     */
    public static int ucc_team_destroy(MemorySegment team) {
        var mh$ = ucc_team_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_team_destroy", team);
            }
            return (int)mh$.invokeExact(team);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_team_get_attr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_team_get_attr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_team_get_attr(ucc_team_h team, ucc_team_attr_t *team_attr)
     * }
     */
    public static FunctionDescriptor ucc_team_get_attr$descriptor() {
        return ucc_team_get_attr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_team_get_attr(ucc_team_h team, ucc_team_attr_t *team_attr)
     * }
     */
    public static MethodHandle ucc_team_get_attr$handle() {
        return ucc_team_get_attr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_team_get_attr(ucc_team_h team, ucc_team_attr_t *team_attr)
     * }
     */
    public static MemorySegment ucc_team_get_attr$address() {
        return ucc_team_get_attr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_team_get_attr(ucc_team_h team, ucc_team_attr_t *team_attr)
     * }
     */
    public static int ucc_team_get_attr(MemorySegment team, MemorySegment team_attr) {
        var mh$ = ucc_team_get_attr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_team_get_attr", team, team_attr);
            }
            return (int)mh$.invokeExact(team, team_attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_team_create_from_parent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_LONG,
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_team_create_from_parent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_team_create_from_parent(uint64_t my_ep, uint32_t included, ucc_team_h parent_team, ucc_team_h *new_team)
     * }
     */
    public static FunctionDescriptor ucc_team_create_from_parent$descriptor() {
        return ucc_team_create_from_parent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_team_create_from_parent(uint64_t my_ep, uint32_t included, ucc_team_h parent_team, ucc_team_h *new_team)
     * }
     */
    public static MethodHandle ucc_team_create_from_parent$handle() {
        return ucc_team_create_from_parent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_team_create_from_parent(uint64_t my_ep, uint32_t included, ucc_team_h parent_team, ucc_team_h *new_team)
     * }
     */
    public static MemorySegment ucc_team_create_from_parent$address() {
        return ucc_team_create_from_parent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_team_create_from_parent(uint64_t my_ep, uint32_t included, ucc_team_h parent_team, ucc_team_h *new_team)
     * }
     */
    public static int ucc_team_create_from_parent(long my_ep, int included, MemorySegment parent_team, MemorySegment new_team) {
        var mh$ = ucc_team_create_from_parent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_team_create_from_parent", my_ep, included, parent_team, new_team);
            }
            return (int)mh$.invokeExact(my_ep, included, parent_team, new_team);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UCC_COLL_ARGS_FLAG_IN_PLACE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_ARGS_FLAG_IN_PLACE = 1
     * }
     */
    public static int UCC_COLL_ARGS_FLAG_IN_PLACE() {
        return UCC_COLL_ARGS_FLAG_IN_PLACE;
    }
    private static final int UCC_COLL_ARGS_FLAG_PERSISTENT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_ARGS_FLAG_PERSISTENT = 2
     * }
     */
    public static int UCC_COLL_ARGS_FLAG_PERSISTENT() {
        return UCC_COLL_ARGS_FLAG_PERSISTENT;
    }
    private static final int UCC_COLL_ARGS_FLAG_COUNT_64BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_ARGS_FLAG_COUNT_64BIT = 4
     * }
     */
    public static int UCC_COLL_ARGS_FLAG_COUNT_64BIT() {
        return UCC_COLL_ARGS_FLAG_COUNT_64BIT;
    }
    private static final int UCC_COLL_ARGS_FLAG_DISPLACEMENTS_64BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_ARGS_FLAG_DISPLACEMENTS_64BIT = 8
     * }
     */
    public static int UCC_COLL_ARGS_FLAG_DISPLACEMENTS_64BIT() {
        return UCC_COLL_ARGS_FLAG_DISPLACEMENTS_64BIT;
    }
    private static final int UCC_COLL_ARGS_FLAG_CONTIG_SRC_BUFFER = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_ARGS_FLAG_CONTIG_SRC_BUFFER = 16
     * }
     */
    public static int UCC_COLL_ARGS_FLAG_CONTIG_SRC_BUFFER() {
        return UCC_COLL_ARGS_FLAG_CONTIG_SRC_BUFFER;
    }
    private static final int UCC_COLL_ARGS_FLAG_CONTIG_DST_BUFFER = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_ARGS_FLAG_CONTIG_DST_BUFFER = 32
     * }
     */
    public static int UCC_COLL_ARGS_FLAG_CONTIG_DST_BUFFER() {
        return UCC_COLL_ARGS_FLAG_CONTIG_DST_BUFFER;
    }
    private static final int UCC_COLL_ARGS_FLAG_TIMEOUT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_ARGS_FLAG_TIMEOUT = 64
     * }
     */
    public static int UCC_COLL_ARGS_FLAG_TIMEOUT() {
        return UCC_COLL_ARGS_FLAG_TIMEOUT;
    }
    private static final int UCC_COLL_ARGS_FLAG_MEM_MAPPED_BUFFERS = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_ARGS_FLAG_MEM_MAPPED_BUFFERS = 128
     * }
     */
    public static int UCC_COLL_ARGS_FLAG_MEM_MAPPED_BUFFERS() {
        return UCC_COLL_ARGS_FLAG_MEM_MAPPED_BUFFERS;
    }
    private static final int UCC_COLL_ARGS_FLAG_SRC_MEMH_GLOBAL = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_ARGS_FLAG_SRC_MEMH_GLOBAL = 256
     * }
     */
    public static int UCC_COLL_ARGS_FLAG_SRC_MEMH_GLOBAL() {
        return UCC_COLL_ARGS_FLAG_SRC_MEMH_GLOBAL;
    }
    private static final int UCC_COLL_ARGS_FLAG_DST_MEMH_GLOBAL = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_ARGS_FLAG_DST_MEMH_GLOBAL = 512
     * }
     */
    public static int UCC_COLL_ARGS_FLAG_DST_MEMH_GLOBAL() {
        return UCC_COLL_ARGS_FLAG_DST_MEMH_GLOBAL;
    }
    private static final int UCC_COLL_ARGS_HINT_OPTIMIZE_OVERLAP_CPU = (int)16777216L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_ARGS_HINT_OPTIMIZE_OVERLAP_CPU = 16777216
     * }
     */
    public static int UCC_COLL_ARGS_HINT_OPTIMIZE_OVERLAP_CPU() {
        return UCC_COLL_ARGS_HINT_OPTIMIZE_OVERLAP_CPU;
    }
    private static final int UCC_COLL_ARGS_HINT_OPTIMIZE_OVERLAP_GPU = (int)33554432L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_ARGS_HINT_OPTIMIZE_OVERLAP_GPU = 33554432
     * }
     */
    public static int UCC_COLL_ARGS_HINT_OPTIMIZE_OVERLAP_GPU() {
        return UCC_COLL_ARGS_HINT_OPTIMIZE_OVERLAP_GPU;
    }
    private static final int UCC_COLL_ARGS_HINT_OPTIMIZE_LATENCY = (int)67108864L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_ARGS_HINT_OPTIMIZE_LATENCY = 67108864
     * }
     */
    public static int UCC_COLL_ARGS_HINT_OPTIMIZE_LATENCY() {
        return UCC_COLL_ARGS_HINT_OPTIMIZE_LATENCY;
    }
    private static final int UCC_COLL_ARGS_HINT_CONTIG_SRC_BUFFER = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_ARGS_HINT_CONTIG_SRC_BUFFER = 16
     * }
     */
    public static int UCC_COLL_ARGS_HINT_CONTIG_SRC_BUFFER() {
        return UCC_COLL_ARGS_HINT_CONTIG_SRC_BUFFER;
    }
    private static final int UCC_COLL_ARGS_HINT_CONTIG_DST_BUFFER = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_COLL_ARGS_HINT_CONTIG_DST_BUFFER = 32
     * }
     */
    public static int UCC_COLL_ARGS_HINT_CONTIG_DST_BUFFER() {
        return UCC_COLL_ARGS_HINT_CONTIG_DST_BUFFER;
    }
    private static final int UCC_ERR_TYPE_LOCAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_ERR_TYPE_LOCAL = 0
     * }
     */
    public static int UCC_ERR_TYPE_LOCAL() {
        return UCC_ERR_TYPE_LOCAL;
    }
    private static final int UCC_ERR_TYPE_GLOBAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_ERR_TYPE_GLOBAL = 1
     * }
     */
    public static int UCC_ERR_TYPE_GLOBAL() {
        return UCC_ERR_TYPE_GLOBAL;
    }
    private static final int UCC_COLL_ARGS_FIELD_FLAGS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucc_coll_args_field.UCC_COLL_ARGS_FIELD_FLAGS = 1
     * }
     */
    public static int UCC_COLL_ARGS_FIELD_FLAGS() {
        return UCC_COLL_ARGS_FIELD_FLAGS;
    }
    private static final int UCC_COLL_ARGS_FIELD_TAG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucc_coll_args_field.UCC_COLL_ARGS_FIELD_TAG = 2
     * }
     */
    public static int UCC_COLL_ARGS_FIELD_TAG() {
        return UCC_COLL_ARGS_FIELD_TAG;
    }
    private static final int UCC_COLL_ARGS_FIELD_CB = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucc_coll_args_field.UCC_COLL_ARGS_FIELD_CB = 4
     * }
     */
    public static int UCC_COLL_ARGS_FIELD_CB() {
        return UCC_COLL_ARGS_FIELD_CB;
    }
    private static final int UCC_COLL_ARGS_FIELD_GLOBAL_WORK_BUFFER = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucc_coll_args_field.UCC_COLL_ARGS_FIELD_GLOBAL_WORK_BUFFER = 8
     * }
     */
    public static int UCC_COLL_ARGS_FIELD_GLOBAL_WORK_BUFFER() {
        return UCC_COLL_ARGS_FIELD_GLOBAL_WORK_BUFFER;
    }
    private static final int UCC_COLL_ARGS_FIELD_ACTIVE_SET = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ucc_coll_args_field.UCC_COLL_ARGS_FIELD_ACTIVE_SET = 16
     * }
     */
    public static int UCC_COLL_ARGS_FIELD_ACTIVE_SET() {
        return UCC_COLL_ARGS_FIELD_ACTIVE_SET;
    }
    private static final int UCC_COLL_ARGS_FIELD_MEM_MAP_SRC_MEMH = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ucc_coll_args_field.UCC_COLL_ARGS_FIELD_MEM_MAP_SRC_MEMH = 32
     * }
     */
    public static int UCC_COLL_ARGS_FIELD_MEM_MAP_SRC_MEMH() {
        return UCC_COLL_ARGS_FIELD_MEM_MAP_SRC_MEMH;
    }
    private static final int UCC_COLL_ARGS_FIELD_MEM_MAP_DST_MEMH = (int)64L;
    /**
     * {@snippet lang=c :
     * enum ucc_coll_args_field.UCC_COLL_ARGS_FIELD_MEM_MAP_DST_MEMH = 64
     * }
     */
    public static int UCC_COLL_ARGS_FIELD_MEM_MAP_DST_MEMH() {
        return UCC_COLL_ARGS_FIELD_MEM_MAP_DST_MEMH;
    }
    /**
     * {@snippet lang=c :
     * typedef void *ucc_mem_map_mem_h
     * }
     */
    public static final AddressLayout ucc_mem_map_mem_h = Ucc.C_POINTER;

    private static class ucc_collective_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_collective_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_init(ucc_coll_args_t *coll_args, ucc_coll_req_h *request, ucc_team_h team)
     * }
     */
    public static FunctionDescriptor ucc_collective_init$descriptor() {
        return ucc_collective_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_init(ucc_coll_args_t *coll_args, ucc_coll_req_h *request, ucc_team_h team)
     * }
     */
    public static MethodHandle ucc_collective_init$handle() {
        return ucc_collective_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_init(ucc_coll_args_t *coll_args, ucc_coll_req_h *request, ucc_team_h team)
     * }
     */
    public static MemorySegment ucc_collective_init$address() {
        return ucc_collective_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_init(ucc_coll_args_t *coll_args, ucc_coll_req_h *request, ucc_team_h team)
     * }
     */
    public static int ucc_collective_init(MemorySegment coll_args, MemorySegment request, MemorySegment team) {
        var mh$ = ucc_collective_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_collective_init", coll_args, request, team);
            }
            return (int)mh$.invokeExact(coll_args, request, team);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_collective_post {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_collective_post");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_post(ucc_coll_req_h request)
     * }
     */
    public static FunctionDescriptor ucc_collective_post$descriptor() {
        return ucc_collective_post.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_post(ucc_coll_req_h request)
     * }
     */
    public static MethodHandle ucc_collective_post$handle() {
        return ucc_collective_post.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_post(ucc_coll_req_h request)
     * }
     */
    public static MemorySegment ucc_collective_post$address() {
        return ucc_collective_post.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_post(ucc_coll_req_h request)
     * }
     */
    public static int ucc_collective_post(MemorySegment request) {
        var mh$ = ucc_collective_post.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_collective_post", request);
            }
            return (int)mh$.invokeExact(request);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_collective_init_and_post {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_collective_init_and_post");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_init_and_post(ucc_coll_args_t *coll_args, ucc_coll_req_h *request, ucc_team_h team)
     * }
     */
    public static FunctionDescriptor ucc_collective_init_and_post$descriptor() {
        return ucc_collective_init_and_post.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_init_and_post(ucc_coll_args_t *coll_args, ucc_coll_req_h *request, ucc_team_h team)
     * }
     */
    public static MethodHandle ucc_collective_init_and_post$handle() {
        return ucc_collective_init_and_post.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_init_and_post(ucc_coll_args_t *coll_args, ucc_coll_req_h *request, ucc_team_h team)
     * }
     */
    public static MemorySegment ucc_collective_init_and_post$address() {
        return ucc_collective_init_and_post.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_init_and_post(ucc_coll_args_t *coll_args, ucc_coll_req_h *request, ucc_team_h team)
     * }
     */
    public static int ucc_collective_init_and_post(MemorySegment coll_args, MemorySegment request, MemorySegment team) {
        var mh$ = ucc_collective_init_and_post.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_collective_init_and_post", coll_args, request, team);
            }
            return (int)mh$.invokeExact(coll_args, request, team);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_collective_finalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_collective_finalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_finalize(ucc_coll_req_h request)
     * }
     */
    public static FunctionDescriptor ucc_collective_finalize$descriptor() {
        return ucc_collective_finalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_finalize(ucc_coll_req_h request)
     * }
     */
    public static MethodHandle ucc_collective_finalize$handle() {
        return ucc_collective_finalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_finalize(ucc_coll_req_h request)
     * }
     */
    public static MemorySegment ucc_collective_finalize$address() {
        return ucc_collective_finalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_finalize(ucc_coll_req_h request)
     * }
     */
    public static int ucc_collective_finalize(MemorySegment request) {
        var mh$ = ucc_collective_finalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_collective_finalize", request);
            }
            return (int)mh$.invokeExact(request);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UCC_EVENT_COLLECTIVE_POST = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucc_event_type.UCC_EVENT_COLLECTIVE_POST = 1
     * }
     */
    public static int UCC_EVENT_COLLECTIVE_POST() {
        return UCC_EVENT_COLLECTIVE_POST;
    }
    private static final int UCC_EVENT_COLLECTIVE_COMPLETE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucc_event_type.UCC_EVENT_COLLECTIVE_COMPLETE = 2
     * }
     */
    public static int UCC_EVENT_COLLECTIVE_COMPLETE() {
        return UCC_EVENT_COLLECTIVE_COMPLETE;
    }
    private static final int UCC_EVENT_COMPUTE_COMPLETE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ucc_event_type.UCC_EVENT_COMPUTE_COMPLETE = 4
     * }
     */
    public static int UCC_EVENT_COMPUTE_COMPLETE() {
        return UCC_EVENT_COMPUTE_COMPLETE;
    }
    private static final int UCC_EVENT_OVERFLOW = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ucc_event_type.UCC_EVENT_OVERFLOW = 8
     * }
     */
    public static int UCC_EVENT_OVERFLOW() {
        return UCC_EVENT_OVERFLOW;
    }
    private static final int UCC_EE_FIRST = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ucc_ee_type.UCC_EE_FIRST = 0
     * }
     */
    public static int UCC_EE_FIRST() {
        return UCC_EE_FIRST;
    }
    private static final int UCC_EE_CUDA_STREAM = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ucc_ee_type.UCC_EE_CUDA_STREAM = 0
     * }
     */
    public static int UCC_EE_CUDA_STREAM() {
        return UCC_EE_CUDA_STREAM;
    }
    private static final int UCC_EE_CPU_THREAD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ucc_ee_type.UCC_EE_CPU_THREAD = 1
     * }
     */
    public static int UCC_EE_CPU_THREAD() {
        return UCC_EE_CPU_THREAD;
    }
    private static final int UCC_EE_ROCM_STREAM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ucc_ee_type.UCC_EE_ROCM_STREAM = 2
     * }
     */
    public static int UCC_EE_ROCM_STREAM() {
        return UCC_EE_ROCM_STREAM;
    }
    private static final int UCC_EE_LAST = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ucc_ee_type.UCC_EE_LAST = 3
     * }
     */
    public static int UCC_EE_LAST() {
        return UCC_EE_LAST;
    }
    private static final int UCC_EE_UNKNOWN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ucc_ee_type.UCC_EE_UNKNOWN = 3
     * }
     */
    public static int UCC_EE_UNKNOWN() {
        return UCC_EE_UNKNOWN;
    }

    private static class ucc_ee_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_ee_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_create(ucc_team_h team, const ucc_ee_params_t *params, ucc_ee_h *ee)
     * }
     */
    public static FunctionDescriptor ucc_ee_create$descriptor() {
        return ucc_ee_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_create(ucc_team_h team, const ucc_ee_params_t *params, ucc_ee_h *ee)
     * }
     */
    public static MethodHandle ucc_ee_create$handle() {
        return ucc_ee_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_create(ucc_team_h team, const ucc_ee_params_t *params, ucc_ee_h *ee)
     * }
     */
    public static MemorySegment ucc_ee_create$address() {
        return ucc_ee_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_create(ucc_team_h team, const ucc_ee_params_t *params, ucc_ee_h *ee)
     * }
     */
    public static int ucc_ee_create(MemorySegment team, MemorySegment params, MemorySegment ee) {
        var mh$ = ucc_ee_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_ee_create", team, params, ee);
            }
            return (int)mh$.invokeExact(team, params, ee);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_ee_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_ee_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_destroy(ucc_ee_h ee)
     * }
     */
    public static FunctionDescriptor ucc_ee_destroy$descriptor() {
        return ucc_ee_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_destroy(ucc_ee_h ee)
     * }
     */
    public static MethodHandle ucc_ee_destroy$handle() {
        return ucc_ee_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_destroy(ucc_ee_h ee)
     * }
     */
    public static MemorySegment ucc_ee_destroy$address() {
        return ucc_ee_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_destroy(ucc_ee_h ee)
     * }
     */
    public static int ucc_ee_destroy(MemorySegment ee) {
        var mh$ = ucc_ee_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_ee_destroy", ee);
            }
            return (int)mh$.invokeExact(ee);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_ee_get_event {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_ee_get_event");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_get_event(ucc_ee_h ee, ucc_ev_t **ev)
     * }
     */
    public static FunctionDescriptor ucc_ee_get_event$descriptor() {
        return ucc_ee_get_event.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_get_event(ucc_ee_h ee, ucc_ev_t **ev)
     * }
     */
    public static MethodHandle ucc_ee_get_event$handle() {
        return ucc_ee_get_event.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_get_event(ucc_ee_h ee, ucc_ev_t **ev)
     * }
     */
    public static MemorySegment ucc_ee_get_event$address() {
        return ucc_ee_get_event.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_get_event(ucc_ee_h ee, ucc_ev_t **ev)
     * }
     */
    public static int ucc_ee_get_event(MemorySegment ee, MemorySegment ev) {
        var mh$ = ucc_ee_get_event.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_ee_get_event", ee, ev);
            }
            return (int)mh$.invokeExact(ee, ev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_ee_ack_event {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_ee_ack_event");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_ack_event(ucc_ee_h ee, ucc_ev_t *ev)
     * }
     */
    public static FunctionDescriptor ucc_ee_ack_event$descriptor() {
        return ucc_ee_ack_event.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_ack_event(ucc_ee_h ee, ucc_ev_t *ev)
     * }
     */
    public static MethodHandle ucc_ee_ack_event$handle() {
        return ucc_ee_ack_event.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_ack_event(ucc_ee_h ee, ucc_ev_t *ev)
     * }
     */
    public static MemorySegment ucc_ee_ack_event$address() {
        return ucc_ee_ack_event.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_ack_event(ucc_ee_h ee, ucc_ev_t *ev)
     * }
     */
    public static int ucc_ee_ack_event(MemorySegment ee, MemorySegment ev) {
        var mh$ = ucc_ee_ack_event.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_ee_ack_event", ee, ev);
            }
            return (int)mh$.invokeExact(ee, ev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_ee_set_event {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_ee_set_event");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_set_event(ucc_ee_h ee, ucc_ev_t *ev)
     * }
     */
    public static FunctionDescriptor ucc_ee_set_event$descriptor() {
        return ucc_ee_set_event.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_set_event(ucc_ee_h ee, ucc_ev_t *ev)
     * }
     */
    public static MethodHandle ucc_ee_set_event$handle() {
        return ucc_ee_set_event.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_set_event(ucc_ee_h ee, ucc_ev_t *ev)
     * }
     */
    public static MemorySegment ucc_ee_set_event$address() {
        return ucc_ee_set_event.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_set_event(ucc_ee_h ee, ucc_ev_t *ev)
     * }
     */
    public static int ucc_ee_set_event(MemorySegment ee, MemorySegment ev) {
        var mh$ = ucc_ee_set_event.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_ee_set_event", ee, ev);
            }
            return (int)mh$.invokeExact(ee, ev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_ee_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_ee_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_wait(ucc_ee_h ee, ucc_ev_t *ev)
     * }
     */
    public static FunctionDescriptor ucc_ee_wait$descriptor() {
        return ucc_ee_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_wait(ucc_ee_h ee, ucc_ev_t *ev)
     * }
     */
    public static MethodHandle ucc_ee_wait$handle() {
        return ucc_ee_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_wait(ucc_ee_h ee, ucc_ev_t *ev)
     * }
     */
    public static MemorySegment ucc_ee_wait$address() {
        return ucc_ee_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_ee_wait(ucc_ee_h ee, ucc_ev_t *ev)
     * }
     */
    public static int ucc_ee_wait(MemorySegment ee, MemorySegment ev) {
        var mh$ = ucc_ee_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_ee_wait", ee, ev);
            }
            return (int)mh$.invokeExact(ee, ev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_collective_triggered_post {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_collective_triggered_post");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_triggered_post(ucc_ee_h ee, ucc_ev_t *ee_event)
     * }
     */
    public static FunctionDescriptor ucc_collective_triggered_post$descriptor() {
        return ucc_collective_triggered_post.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_triggered_post(ucc_ee_h ee, ucc_ev_t *ee_event)
     * }
     */
    public static MethodHandle ucc_collective_triggered_post$handle() {
        return ucc_collective_triggered_post.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_triggered_post(ucc_ee_h ee, ucc_ev_t *ee_event)
     * }
     */
    public static MemorySegment ucc_collective_triggered_post$address() {
        return ucc_collective_triggered_post.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_collective_triggered_post(ucc_ee_h ee, ucc_ev_t *ee_event)
     * }
     */
    public static int ucc_collective_triggered_post(MemorySegment ee, MemorySegment ee_event) {
        var mh$ = ucc_collective_triggered_post.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_collective_triggered_post", ee, ee_event);
            }
            return (int)mh$.invokeExact(ee, ee_event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UCC_MEM_MAP_MODE_EXPORT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_MEM_MAP_MODE_EXPORT = 0
     * }
     */
    public static int UCC_MEM_MAP_MODE_EXPORT() {
        return UCC_MEM_MAP_MODE_EXPORT;
    }
    private static final int UCC_MEM_MAP_MODE_IMPORT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_MEM_MAP_MODE_IMPORT = 1
     * }
     */
    public static int UCC_MEM_MAP_MODE_IMPORT() {
        return UCC_MEM_MAP_MODE_IMPORT;
    }
    private static final int UCC_MEM_MAP_MODE_EXPORT_OFFLOAD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_MEM_MAP_MODE_EXPORT_OFFLOAD = 2
     * }
     */
    public static int UCC_MEM_MAP_MODE_EXPORT_OFFLOAD() {
        return UCC_MEM_MAP_MODE_EXPORT_OFFLOAD;
    }
    private static final int UCC_MEM_MAP_MODE_IMPORT_OFFLOAD = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_MEM_MAP_MODE_IMPORT_OFFLOAD = 3
     * }
     */
    public static int UCC_MEM_MAP_MODE_IMPORT_OFFLOAD() {
        return UCC_MEM_MAP_MODE_IMPORT_OFFLOAD;
    }
    private static final int UCC_MEM_MAP_MODE_LAST = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.UCC_MEM_MAP_MODE_LAST = 4
     * }
     */
    public static int UCC_MEM_MAP_MODE_LAST() {
        return UCC_MEM_MAP_MODE_LAST;
    }

    private static class ucc_mem_map {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_INT,
            Ucc.C_POINTER,
            Ucc.C_POINTER,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_mem_map");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_mem_map(ucc_context_h context, ucc_mem_map_mode_t mode, const ucc_mem_map_params_t *params, size_t *memh_size, ucc_mem_map_mem_h *memh)
     * }
     */
    public static FunctionDescriptor ucc_mem_map$descriptor() {
        return ucc_mem_map.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_mem_map(ucc_context_h context, ucc_mem_map_mode_t mode, const ucc_mem_map_params_t *params, size_t *memh_size, ucc_mem_map_mem_h *memh)
     * }
     */
    public static MethodHandle ucc_mem_map$handle() {
        return ucc_mem_map.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_mem_map(ucc_context_h context, ucc_mem_map_mode_t mode, const ucc_mem_map_params_t *params, size_t *memh_size, ucc_mem_map_mem_h *memh)
     * }
     */
    public static MemorySegment ucc_mem_map$address() {
        return ucc_mem_map.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_mem_map(ucc_context_h context, ucc_mem_map_mode_t mode, const ucc_mem_map_params_t *params, size_t *memh_size, ucc_mem_map_mem_h *memh)
     * }
     */
    public static int ucc_mem_map(MemorySegment context, int mode, MemorySegment params, MemorySegment memh_size, MemorySegment memh) {
        var mh$ = ucc_mem_map.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_mem_map", context, mode, params, memh_size, memh);
            }
            return (int)mh$.invokeExact(context, mode, params, memh_size, memh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ucc_mem_unmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Ucc.C_INT,
            Ucc.C_POINTER
        );

        public static final MemorySegment ADDR = Ucc.findOrThrow("ucc_mem_unmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ucc_status_t ucc_mem_unmap(ucc_mem_map_mem_h *memh)
     * }
     */
    public static FunctionDescriptor ucc_mem_unmap$descriptor() {
        return ucc_mem_unmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ucc_status_t ucc_mem_unmap(ucc_mem_map_mem_h *memh)
     * }
     */
    public static MethodHandle ucc_mem_unmap$handle() {
        return ucc_mem_unmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ucc_status_t ucc_mem_unmap(ucc_mem_map_mem_h *memh)
     * }
     */
    public static MemorySegment ucc_mem_unmap$address() {
        return ucc_mem_unmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ucc_status_t ucc_mem_unmap(ucc_mem_map_mem_h *memh)
     * }
     */
    public static int ucc_mem_unmap(MemorySegment memh) {
        var mh$ = ucc_mem_unmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ucc_mem_unmap", memh);
            }
            return (int)mh$.invokeExact(memh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final long __STDC_IEC_60559_BFP__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_BFP__ 201404
     * }
     */
    public static long __STDC_IEC_60559_BFP__() {
        return __STDC_IEC_60559_BFP__;
    }
    private static final long __STDC_IEC_60559_COMPLEX__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_COMPLEX__ 201404
     * }
     */
    public static long __STDC_IEC_60559_COMPLEX__() {
        return __STDC_IEC_60559_COMPLEX__;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final int __WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MAX 2147483647
     * }
     */
    public static int __WCHAR_MAX() {
        return __WCHAR_MAX;
    }
    private static final int __WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MIN -2147483648
     * }
     */
    public static int __WCHAR_MIN() {
        return __WCHAR_MIN;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final long INT_FAST16_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final long INT_FAST32_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final long INT_FAST16_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final long INT_FAST32_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final long UINT_FAST16_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX -1
     * }
     */
    public static long UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final long UINT_FAST32_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX -1
     * }
     */
    public static long UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 4294967295
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int UCC_API_VERSION = (int)17235968L;
    /**
     * {@snippet lang=c :
     * #define UCC_API_VERSION 17235968
     * }
     */
    public static int UCC_API_VERSION() {
        return UCC_API_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define UCC_VERSION_STRING "1.7.0"
     * }
     */
    public static MemorySegment UCC_VERSION_STRING() {
        class Holder {
            static final MemorySegment UCC_VERSION_STRING
                = Ucc.LIBRARY_ARENA.allocateFrom("1.7.0");
        }
        return Holder.UCC_VERSION_STRING;
    }
    /**
     * {@snippet lang=c :
     * #define UCC_GIT_REVISION "76fd8dd"
     * }
     */
    public static MemorySegment UCC_GIT_REVISION() {
        class Holder {
            static final MemorySegment UCC_GIT_REVISION
                = Ucc.LIBRARY_ARENA.allocateFrom("76fd8dd");
        }
        return Holder.UCC_GIT_REVISION;
    }
    private static final int EOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }
    /**
     * {@snippet lang=c :
     * #define P_tmpdir "/tmp"
     * }
     */
    public static MemorySegment P_tmpdir() {
        class Holder {
            static final MemorySegment P_tmpdir
                = Ucc.LIBRARY_ARENA.allocateFrom("/tmp");
        }
        return Holder.P_tmpdir;
    }
    private static final int __HAVE_DISTINCT_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT16 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT16() {
        return __HAVE_DISTINCT_FLOAT16;
    }
    private static final int __HAVE_DISTINCT_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128X() {
        return __HAVE_DISTINCT_FLOAT128X;
    }
    private static final int __HAVE_FLOAT128_UNLIKE_LDBL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128_UNLIKE_LDBL 0
     * }
     */
    public static int __HAVE_FLOAT128_UNLIKE_LDBL() {
        return __HAVE_FLOAT128_UNLIKE_LDBL;
    }
    private static final long UCC_DT_INT8 = 0L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_INT8 0
     * }
     */
    public static long UCC_DT_INT8() {
        return UCC_DT_INT8;
    }
    private static final long UCC_DT_INT16 = 8L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_INT16 8
     * }
     */
    public static long UCC_DT_INT16() {
        return UCC_DT_INT16;
    }
    private static final long UCC_DT_INT32 = 16L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_INT32 16
     * }
     */
    public static long UCC_DT_INT32() {
        return UCC_DT_INT32;
    }
    private static final long UCC_DT_INT64 = 24L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_INT64 24
     * }
     */
    public static long UCC_DT_INT64() {
        return UCC_DT_INT64;
    }
    private static final long UCC_DT_INT128 = 32L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_INT128 32
     * }
     */
    public static long UCC_DT_INT128() {
        return UCC_DT_INT128;
    }
    private static final long UCC_DT_UINT8 = 40L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_UINT8 40
     * }
     */
    public static long UCC_DT_UINT8() {
        return UCC_DT_UINT8;
    }
    private static final long UCC_DT_UINT16 = 48L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_UINT16 48
     * }
     */
    public static long UCC_DT_UINT16() {
        return UCC_DT_UINT16;
    }
    private static final long UCC_DT_UINT32 = 56L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_UINT32 56
     * }
     */
    public static long UCC_DT_UINT32() {
        return UCC_DT_UINT32;
    }
    private static final long UCC_DT_UINT64 = 64L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_UINT64 64
     * }
     */
    public static long UCC_DT_UINT64() {
        return UCC_DT_UINT64;
    }
    private static final long UCC_DT_UINT128 = 72L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_UINT128 72
     * }
     */
    public static long UCC_DT_UINT128() {
        return UCC_DT_UINT128;
    }
    private static final long UCC_DT_FLOAT16 = 80L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_FLOAT16 80
     * }
     */
    public static long UCC_DT_FLOAT16() {
        return UCC_DT_FLOAT16;
    }
    private static final long UCC_DT_FLOAT32 = 88L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_FLOAT32 88
     * }
     */
    public static long UCC_DT_FLOAT32() {
        return UCC_DT_FLOAT32;
    }
    private static final long UCC_DT_FLOAT64 = 96L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_FLOAT64 96
     * }
     */
    public static long UCC_DT_FLOAT64() {
        return UCC_DT_FLOAT64;
    }
    private static final long UCC_DT_BFLOAT16 = 104L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_BFLOAT16 104
     * }
     */
    public static long UCC_DT_BFLOAT16() {
        return UCC_DT_BFLOAT16;
    }
    private static final long UCC_DT_FLOAT128 = 112L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_FLOAT128 112
     * }
     */
    public static long UCC_DT_FLOAT128() {
        return UCC_DT_FLOAT128;
    }
    private static final long UCC_DT_FLOAT32_COMPLEX = 120L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_FLOAT32_COMPLEX 120
     * }
     */
    public static long UCC_DT_FLOAT32_COMPLEX() {
        return UCC_DT_FLOAT32_COMPLEX;
    }
    private static final long UCC_DT_FLOAT64_COMPLEX = 128L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_FLOAT64_COMPLEX 128
     * }
     */
    public static long UCC_DT_FLOAT64_COMPLEX() {
        return UCC_DT_FLOAT64_COMPLEX;
    }
    private static final long UCC_DT_FLOAT128_COMPLEX = 136L;
    /**
     * {@snippet lang=c :
     * #define UCC_DT_FLOAT128_COMPLEX 136
     * }
     */
    public static long UCC_DT_FLOAT128_COMPLEX() {
        return UCC_DT_FLOAT128_COMPLEX;
    }
}

