plugins { id 'java-library' }

group = 'io.surfworks.warpforge'
version = '0.0.1-SNAPSHOT'

repositories { mavenCentral() }

dependencies {
    api project(':snakeburger-core')
    api project(':warpforge-data')

    testImplementation project(':warpforge-backend-cpu')
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.2'
    testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.2'
    testImplementation 'org.awaitility:awaitility:4.2.0'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.2'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.10.2'
}

// Note: JDK routing (gradle/jdk-routing.gradle) handles:
// - Babylon JDK (Java 26) toolchain configuration
// - --add-modules jdk.incubator.code,jdk.incubator.vector

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

tasks.withType(Test).configureEach {
    useJUnitPlatform()
}

test {
    useJUnitPlatform {
        excludeTags 'integration', 'fixture-generator', 'nightly'
    }
}

tasks.register('nightlyTest', Test) {
    description = 'Run nightly-only tests (expensive EndToEnd fixtures like BERT)'
    group = 'verification'

    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath

    useJUnitPlatform {
        includeTags 'nightly'
    }

    testLogging {
        events 'passed', 'skipped', 'failed', 'standardOut'
        showStandardStreams = true
    }
}

tasks.register('generateEndToEndFixtures', Test) {
    description = 'Generate EndToEnd test fixtures using snakegrinder-dist native binary'
    group = 'verification'

    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath

    useJUnitPlatform {
        includeTags 'fixture-generator'
    }

    testLogging {
        events 'passed', 'skipped', 'failed', 'standardOut'
        showStandardStreams = true
    }

    // Capture paths at configuration time (outside doLast)
    def versionsEnvPath = project.rootDir.toPath().resolve('snakegrinder-dist/versions.env').toFile()
    def fixturesDirPath = project.file('build/generated-fixtures/e2e')

    // Update VERSION file after successful generation (in build/, never committed)
    doLast {
        fixturesDirPath.mkdirs()

        if (versionsEnvPath.exists()) {
            def pytorchVersion = versionsEnvPath.text.find(/PYTORCH_VERSION="([^"]+)"/) { match, version -> version }
            if (pytorchVersion) {
                def versionFile = new File(fixturesDirPath, 'VERSION')
                versionFile.text = pytorchVersion + '\n'
                logger.lifecycle("Generated fixtures VERSION: PyTorch ${pytorchVersion}")
            }
        }

        def count = fixturesDirPath.listFiles()?.findAll { it.isDirectory() }?.size() ?: 0
        logger.lifecycle("Generated ${count} EndToEnd fixtures to ${fixturesDirPath}")
    }
}

// Check if EndToEnd fixtures exist (they live in build/, never committed)
tasks.register('checkEndToEndFixturesVersion') {
    description = 'Check if EndToEnd fixtures have been generated'
    group = 'verification'

    def fixturesDir = file('build/generated-fixtures/e2e')
    def versionFile = file('build/generated-fixtures/e2e/VERSION')

    doLast {
        if (!fixturesDir.exists() || fixturesDir.listFiles()?.length == 0) {
            logger.warn("EndToEnd fixtures not found. Run: ./gradlew :warpforge-core:generateEndToEndFixtures")
            logger.warn("Tests will be skipped until fixtures are generated.")
            return
        }

        if (versionFile.exists()) {
            def version = versionFile.text.trim()
            logger.lifecycle("EndToEnd fixtures available (PyTorch ${version})")
        } else {
            logger.lifecycle("EndToEnd fixtures available")
        }
    }
}

// Check if fixtures need to be generated
tasks.register('ensureEndToEndFixtures') {
    description = 'Check if EndToEnd fixtures need to be generated'
    group = 'verification'

    def fixturesDir = file('build/generated-fixtures/e2e')

    doLast {
        if (!fixturesDir.exists() || fixturesDir.listFiles()?.length == 0) {
            logger.lifecycle("EndToEnd fixtures not found at ${fixturesDir}")
            logger.lifecycle("Run: ./gradlew :warpforge-core:generateEndToEndFixtures")
        } else {
            def count = fixturesDir.listFiles()?.findAll { it.isDirectory() }?.size() ?: 0
            logger.lifecycle("EndToEnd fixtures available: ${count} fixtures in ${fixturesDir}")
        }
    }
}

// Wire up: test task checks fixtures version first
test.dependsOn checkEndToEndFixturesVersion

// Download EndToEnd fixtures from remote storage (alternative to generating locally)
// All fixtures go to build/ directory - NEVER committed to repository
tasks.register('downloadFixtures') {
    description = 'Download EndToEnd fixtures from remote storage'
    group = 'verification'

    def fixturesDir = file('build/generated-fixtures/e2e')
    def manifestFile = file('src/test/resources/fixtures/MANIFEST.json')

    doLast {
        if (!manifestFile.exists()) {
            throw new GradleException("MANIFEST.json not found at ${manifestFile}")
        }

        def manifest = new groovy.json.JsonSlurper().parse(manifestFile)
        def baseUrl = manifest.base_url

        manifest.fixtures.each { name, info ->
            if (info.download == true) {
                def fixtureDir = new File(fixturesDir, name)
                if (fixtureDir.exists() && new File(fixtureDir, 'model.mlir').exists()) {
                    logger.lifecycle("Fixture '${name}' already exists, skipping")
                    return
                }

                def url = "${baseUrl}/${name}.tar.gz"
                def tarFile = new File(fixturesDir, "${name}.tar.gz")

                logger.lifecycle("Downloading fixture '${name}' (${info.size_mb} MB) from ${url}...")

                // Download
                try {
                    ant.get(src: url, dest: tarFile, verbose: false)
                } catch (Exception e) {
                    logger.warn("Failed to download ${name}: ${e.message}")
                    logger.warn("Fixture URL may not be configured yet. See MANIFEST.json for details.")
                    return
                }

                // Extract
                logger.lifecycle("Extracting ${name}...")
                ant.untar(src: tarFile, dest: fixturesDir, compression: 'gzip')
                tarFile.delete()

                logger.lifecycle("Fixture '${name}' ready")
            }
        }

        logger.lifecycle("All downloadable fixtures processed")
    }
}

// Check if required fixtures are available before nightly tests
tasks.register('checkNightlyFixtures') {
    description = 'Check if nightly test fixtures (BERT) are available'
    group = 'verification'

    def fixturesDir = file('build/generated-fixtures/e2e')

    doLast {
        def missingFixtures = []
        ['bert_squad_mini', 'bert_squad_small', 'bert_squad_base'].each { name ->
            def fixtureDir = new File(fixturesDir, name)
            if (!fixtureDir.exists() || !new File(fixtureDir, 'model.mlir').exists()) {
                missingFixtures << name
            }
        }

        if (!missingFixtures.isEmpty()) {
            logger.warn("Missing nightly fixtures: ${missingFixtures.join(', ')}")
            logger.warn("Run './gradlew :warpforge-core:downloadFixtures' to download them")
            logger.warn("Or run './gradlew :warpforge-core:generateEndToEndFixtures' to generate them locally")
        } else {
            logger.lifecycle("All nightly fixtures available")
        }
    }
}

nightlyTest.dependsOn checkNightlyFixtures

tasks.register('integrationTest', Test) {
    description = 'Run integration tests'
    group = 'verification'

    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath

    useJUnitPlatform {
        includeTags 'integration'
    }

    testLogging {
        events 'passed', 'skipped', 'failed', 'standardOut'
        showStandardStreams = true
    }
}

check.dependsOn integrationTest

// ====================================================================================
// GPU Test Source Set (gtest)
// ====================================================================================
// GPU tests run on BOTH NVIDIA and AMD machines with auto-detected backend.
// These tests validate structured concurrency APIs with real GPU hardware.

sourceSets {
    gtest {
        java {
            srcDir 'src/gtest/java'
        }
        compileClasspath += sourceSets.main.output + sourceSets.test.output
        runtimeClasspath += sourceSets.main.output + sourceSets.test.output
    }
}

configurations {
    gtestImplementation.extendsFrom testImplementation
    gtestRuntimeOnly.extendsFrom testRuntimeOnly
}

dependencies {
    gtestImplementation 'org.junit.jupiter:junit-jupiter:5.11.3'
    gtestRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    // CRITICAL: Include BOTH backends for dual-platform testing
    // Tests auto-detect which backend is available at runtime
    gtestRuntimeOnly project(':warpforge-backend-nvidia')
    gtestRuntimeOnly project(':warpforge-backend-amd')
}

// GPU test task - requires real GPU hardware (runs on BOTH NVIDIA and AMD machines)
tasks.register('gpuTest', Test) {
    description = 'Run GPU tests (requires NVIDIA or AMD GPU)'
    group = 'verification'

    testClassesDirs = sourceSets.gtest.output.classesDirs
    classpath = sourceSets.gtest.runtimeClasspath

    useJUnitPlatform()
    jvmArgs('--enable-preview', '--enable-native-access=ALL-UNNAMED')

    testLogging {
        events 'passed', 'skipped', 'failed'
        showStandardStreams = true
    }
}

// NVIDIA-specific GPU tests (tagged @Tag("nvidia"))
tasks.register('nvidiaGpuTest', Test) {
    description = 'Run NVIDIA-specific GPU tests'
    group = 'verification'

    testClassesDirs = sourceSets.gtest.output.classesDirs
    classpath = sourceSets.gtest.runtimeClasspath

    useJUnitPlatform {
        includeTags 'nvidia'
    }
    jvmArgs('--enable-preview', '--enable-native-access=ALL-UNNAMED')

    testLogging {
        events 'passed', 'skipped', 'failed'
        showStandardStreams = true
    }
}

// AMD-specific GPU tests (tagged @Tag("amd"))
tasks.register('amdGpuTest', Test) {
    description = 'Run AMD-specific GPU tests'
    group = 'verification'

    testClassesDirs = sourceSets.gtest.output.classesDirs
    classpath = sourceSets.gtest.runtimeClasspath

    useJUnitPlatform {
        includeTags 'amd'
    }
    jvmArgs('--enable-preview', '--enable-native-access=ALL-UNNAMED')

    testLogging {
        events 'passed', 'skipped', 'failed'
        showStandardStreams = true
    }
}

// Stress tests (tagged @Tag("stress"), long-running)
tasks.register('stressTest', Test) {
    description = 'Run stress tests (long running)'
    group = 'verification'

    testClassesDirs = sourceSets.gtest.output.classesDirs
    classpath = sourceSets.gtest.runtimeClasspath

    useJUnitPlatform {
        includeTags 'stress'
    }
    jvmArgs('--enable-preview', '--enable-native-access=ALL-UNNAMED', '-Xmx8g')
    timeout = java.time.Duration.ofMinutes(30)

    testLogging {
        events 'passed', 'skipped', 'failed'
        showStandardStreams = true
    }
}
