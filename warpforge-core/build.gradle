plugins { id 'java-library' }

group = 'io.surfworks.warpforge'
version = '0.0.1-SNAPSHOT'

repositories { mavenCentral() }

dependencies {
    api project(':snakeburger-core')

    testImplementation project(':warpforge-backend-cpu')
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.2'
    testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.2'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.2'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.10.2'
}

// Note: JDK routing (gradle/jdk-routing.gradle) handles:
// - Babylon JDK (Java 26) toolchain configuration
// - --add-modules jdk.incubator.code,jdk.incubator.vector

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

tasks.withType(Test).configureEach {
    useJUnitPlatform()
}

test {
    useJUnitPlatform {
        excludeTags 'integration', 'fixture-generator'
    }
}

tasks.register('generateE2EFixtures', Test) {
    description = 'Generate E2E test fixtures using snakegrinder-dist native binary'
    group = 'verification'

    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath

    useJUnitPlatform {
        includeTags 'fixture-generator'
    }

    testLogging {
        events 'passed', 'skipped', 'failed', 'standardOut'
        showStandardStreams = true
    }

    // Update VERSION file after successful generation
    doLast {
        def versionsEnv = rootProject.file('snakegrinder-dist/versions.env')
        if (versionsEnv.exists()) {
            def pytorchVersion = versionsEnv.text.find(/PYTORCH_VERSION="([^"]+)"/) { match, version -> version }
            if (pytorchVersion) {
                def versionFile = file('src/test/resources/fixtures/e2e/VERSION')
                versionFile.text = pytorchVersion + '\n'
                logger.lifecycle("Updated E2E fixtures VERSION to ${pytorchVersion}")
            }
        }
    }
}

// Check if E2E fixtures need regeneration based on PyTorch version
tasks.register('checkE2EFixturesVersion') {
    description = 'Check if E2E fixtures match current PyTorch version'
    group = 'verification'

    def versionsEnvFile = rootProject.file('snakegrinder-dist/versions.env')
    def fixturesVersionFile = file('src/test/resources/fixtures/e2e/VERSION')

    inputs.file(versionsEnvFile).optional()
    inputs.file(fixturesVersionFile).optional()

    doLast {
        if (!versionsEnvFile.exists()) {
            logger.warn("snakegrinder-dist/versions.env not found, skipping E2E fixture version check")
            return
        }

        def pytorchVersion = versionsEnvFile.text.find(/PYTORCH_VERSION="([^"]+)"/) { match, version -> version }
        if (!pytorchVersion) {
            logger.warn("Could not parse PYTORCH_VERSION from versions.env")
            return
        }

        if (!fixturesVersionFile.exists()) {
            throw new GradleException(
                "E2E fixtures VERSION file missing. Run: ./gradlew :warpforge-core:generateE2EFixtures"
            )
        }

        def fixturesVersion = fixturesVersionFile.text.trim()
        if (fixturesVersion != pytorchVersion) {
            throw new GradleException(
                "E2E fixtures are stale: generated with PyTorch ${fixturesVersion}, current is ${pytorchVersion}.\n" +
                "Run: ./gradlew :warpforge-core:generateE2EFixtures"
            )
        }

        logger.lifecycle("E2E fixtures version OK: PyTorch ${pytorchVersion}")
    }
}

// Conditionally regenerate fixtures if PyTorch version changed
tasks.register('ensureE2EFixtures') {
    description = 'Ensure E2E fixtures are up-to-date with current PyTorch version'
    group = 'verification'

    def versionsEnvFile = rootProject.file('snakegrinder-dist/versions.env')
    def fixturesVersionFile = file('src/test/resources/fixtures/e2e/VERSION')

    doLast {
        if (!versionsEnvFile.exists()) {
            logger.lifecycle("snakegrinder-dist/versions.env not found, skipping fixture check")
            return
        }

        def pytorchVersion = versionsEnvFile.text.find(/PYTORCH_VERSION="([^"]+)"/) { match, version -> version }
        if (!pytorchVersion) {
            logger.lifecycle("Could not parse PYTORCH_VERSION, skipping fixture check")
            return
        }

        def needsRegeneration = !fixturesVersionFile.exists() ||
            fixturesVersionFile.text.trim() != pytorchVersion

        if (needsRegeneration) {
            logger.lifecycle("E2E fixtures need regeneration (PyTorch version changed to ${pytorchVersion})")
            // This will trigger the generateE2EFixtures task
            throw new GradleException("REGENERATE_FIXTURES")
        } else {
            logger.lifecycle("E2E fixtures are current (PyTorch ${pytorchVersion})")
        }
    }
}

// Wire up: test task checks fixtures version first
test.dependsOn checkE2EFixturesVersion

tasks.register('integrationTest', Test) {
    description = 'Run integration tests'
    group = 'verification'

    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath

    useJUnitPlatform {
        includeTags 'integration'
    }

    testLogging {
        events 'passed', 'skipped', 'failed', 'standardOut'
        showStandardStreams = true
    }
}

check.dependsOn integrationTest
