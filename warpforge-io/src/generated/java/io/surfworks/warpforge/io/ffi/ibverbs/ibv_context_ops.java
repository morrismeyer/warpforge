// Generated by jextract

package io.surfworks.warpforge.io.ffi.ibverbs;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ibv_context_ops {
 *     int (*_compat_query_device)(struct ibv_context *, struct ibv_device_attr *);
 *     int (*_compat_query_port)(struct ibv_context *, uint8_t, struct _compat_ibv_port_attr *);
 *     void *(*_compat_alloc_pd)(void);
 *     void *(*_compat_dealloc_pd)(void);
 *     void *(*_compat_reg_mr)(void);
 *     void *(*_compat_rereg_mr)(void);
 *     void *(*_compat_dereg_mr)(void);
 *     struct ibv_mw *(*alloc_mw)(struct ibv_pd *, enum ibv_mw_type);
 *     int (*bind_mw)(struct ibv_qp *, struct ibv_mw *, struct ibv_mw_bind *);
 *     int (*dealloc_mw)(struct ibv_mw *);
 *     void *(*_compat_create_cq)(void);
 *     int (*poll_cq)(struct ibv_cq *, int, struct ibv_wc *);
 *     int (*req_notify_cq)(struct ibv_cq *, int);
 *     void *(*_compat_cq_event)(void);
 *     void *(*_compat_resize_cq)(void);
 *     void *(*_compat_destroy_cq)(void);
 *     void *(*_compat_create_srq)(void);
 *     void *(*_compat_modify_srq)(void);
 *     void *(*_compat_query_srq)(void);
 *     void *(*_compat_destroy_srq)(void);
 *     int (*post_srq_recv)(struct ibv_srq *, struct ibv_recv_wr *, struct ibv_recv_wr **);
 *     void *(*_compat_create_qp)(void);
 *     void *(*_compat_query_qp)(void);
 *     void *(*_compat_modify_qp)(void);
 *     void *(*_compat_destroy_qp)(void);
 *     int (*post_send)(struct ibv_qp *, struct ibv_send_wr *, struct ibv_send_wr **);
 *     int (*post_recv)(struct ibv_qp *, struct ibv_recv_wr *, struct ibv_recv_wr **);
 *     void *(*_compat_create_ah)(void);
 *     void *(*_compat_destroy_ah)(void);
 *     void *(*_compat_attach_mcast)(void);
 *     void *(*_compat_detach_mcast)(void);
 *     void *(*_compat_async_event)(void);
 * }
 * }
 */
public class ibv_context_ops {

    ibv_context_ops() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        Ibverbs.C_POINTER.withName("_compat_query_device"),
        Ibverbs.C_POINTER.withName("_compat_query_port"),
        Ibverbs.C_POINTER.withName("_compat_alloc_pd"),
        Ibverbs.C_POINTER.withName("_compat_dealloc_pd"),
        Ibverbs.C_POINTER.withName("_compat_reg_mr"),
        Ibverbs.C_POINTER.withName("_compat_rereg_mr"),
        Ibverbs.C_POINTER.withName("_compat_dereg_mr"),
        Ibverbs.C_POINTER.withName("alloc_mw"),
        Ibverbs.C_POINTER.withName("bind_mw"),
        Ibverbs.C_POINTER.withName("dealloc_mw"),
        Ibverbs.C_POINTER.withName("_compat_create_cq"),
        Ibverbs.C_POINTER.withName("poll_cq"),
        Ibverbs.C_POINTER.withName("req_notify_cq"),
        Ibverbs.C_POINTER.withName("_compat_cq_event"),
        Ibverbs.C_POINTER.withName("_compat_resize_cq"),
        Ibverbs.C_POINTER.withName("_compat_destroy_cq"),
        Ibverbs.C_POINTER.withName("_compat_create_srq"),
        Ibverbs.C_POINTER.withName("_compat_modify_srq"),
        Ibverbs.C_POINTER.withName("_compat_query_srq"),
        Ibverbs.C_POINTER.withName("_compat_destroy_srq"),
        Ibverbs.C_POINTER.withName("post_srq_recv"),
        Ibverbs.C_POINTER.withName("_compat_create_qp"),
        Ibverbs.C_POINTER.withName("_compat_query_qp"),
        Ibverbs.C_POINTER.withName("_compat_modify_qp"),
        Ibverbs.C_POINTER.withName("_compat_destroy_qp"),
        Ibverbs.C_POINTER.withName("post_send"),
        Ibverbs.C_POINTER.withName("post_recv"),
        Ibverbs.C_POINTER.withName("_compat_create_ah"),
        Ibverbs.C_POINTER.withName("_compat_destroy_ah"),
        Ibverbs.C_POINTER.withName("_compat_attach_mcast"),
        Ibverbs.C_POINTER.withName("_compat_detach_mcast"),
        Ibverbs.C_POINTER.withName("_compat_async_event")
    ).withName("ibv_context_ops");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * int (*_compat_query_device)(struct ibv_context *, struct ibv_device_attr *)
     * }
     */
    public static class _compat_query_device {

        _compat_query_device() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_query_device.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_query_device.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_query_device$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_query_device"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*_compat_query_device)(struct ibv_context *, struct ibv_device_attr *)
     * }
     */
    public static final AddressLayout _compat_query_device$layout() {
        return _compat_query_device$LAYOUT;
    }

    private static final long _compat_query_device$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*_compat_query_device)(struct ibv_context *, struct ibv_device_attr *)
     * }
     */
    public static final long _compat_query_device$offset() {
        return _compat_query_device$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*_compat_query_device)(struct ibv_context *, struct ibv_device_attr *)
     * }
     */
    public static MemorySegment _compat_query_device(MemorySegment struct) {
        return struct.get(_compat_query_device$LAYOUT, _compat_query_device$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*_compat_query_device)(struct ibv_context *, struct ibv_device_attr *)
     * }
     */
    public static void _compat_query_device(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_query_device$LAYOUT, _compat_query_device$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*_compat_query_port)(struct ibv_context *, uint8_t, struct _compat_ibv_port_attr *)
     * }
     */
    public static class _compat_query_port {

        _compat_query_port() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, byte _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_CHAR,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_query_port.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_query_port.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, byte _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_query_port$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_query_port"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*_compat_query_port)(struct ibv_context *, uint8_t, struct _compat_ibv_port_attr *)
     * }
     */
    public static final AddressLayout _compat_query_port$layout() {
        return _compat_query_port$LAYOUT;
    }

    private static final long _compat_query_port$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*_compat_query_port)(struct ibv_context *, uint8_t, struct _compat_ibv_port_attr *)
     * }
     */
    public static final long _compat_query_port$offset() {
        return _compat_query_port$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*_compat_query_port)(struct ibv_context *, uint8_t, struct _compat_ibv_port_attr *)
     * }
     */
    public static MemorySegment _compat_query_port(MemorySegment struct) {
        return struct.get(_compat_query_port$LAYOUT, _compat_query_port$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*_compat_query_port)(struct ibv_context *, uint8_t, struct _compat_ibv_port_attr *)
     * }
     */
    public static void _compat_query_port(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_query_port$LAYOUT, _compat_query_port$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_alloc_pd)(void)
     * }
     */
    public static class _compat_alloc_pd {

        _compat_alloc_pd() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_alloc_pd.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_alloc_pd.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_alloc_pd$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_alloc_pd"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_alloc_pd)(void)
     * }
     */
    public static final AddressLayout _compat_alloc_pd$layout() {
        return _compat_alloc_pd$LAYOUT;
    }

    private static final long _compat_alloc_pd$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_alloc_pd)(void)
     * }
     */
    public static final long _compat_alloc_pd$offset() {
        return _compat_alloc_pd$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_alloc_pd)(void)
     * }
     */
    public static MemorySegment _compat_alloc_pd(MemorySegment struct) {
        return struct.get(_compat_alloc_pd$LAYOUT, _compat_alloc_pd$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_alloc_pd)(void)
     * }
     */
    public static void _compat_alloc_pd(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_alloc_pd$LAYOUT, _compat_alloc_pd$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_dealloc_pd)(void)
     * }
     */
    public static class _compat_dealloc_pd {

        _compat_dealloc_pd() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_dealloc_pd.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_dealloc_pd.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_dealloc_pd$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_dealloc_pd"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_dealloc_pd)(void)
     * }
     */
    public static final AddressLayout _compat_dealloc_pd$layout() {
        return _compat_dealloc_pd$LAYOUT;
    }

    private static final long _compat_dealloc_pd$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_dealloc_pd)(void)
     * }
     */
    public static final long _compat_dealloc_pd$offset() {
        return _compat_dealloc_pd$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_dealloc_pd)(void)
     * }
     */
    public static MemorySegment _compat_dealloc_pd(MemorySegment struct) {
        return struct.get(_compat_dealloc_pd$LAYOUT, _compat_dealloc_pd$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_dealloc_pd)(void)
     * }
     */
    public static void _compat_dealloc_pd(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_dealloc_pd$LAYOUT, _compat_dealloc_pd$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_reg_mr)(void)
     * }
     */
    public static class _compat_reg_mr {

        _compat_reg_mr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_reg_mr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_reg_mr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_reg_mr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_reg_mr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_reg_mr)(void)
     * }
     */
    public static final AddressLayout _compat_reg_mr$layout() {
        return _compat_reg_mr$LAYOUT;
    }

    private static final long _compat_reg_mr$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_reg_mr)(void)
     * }
     */
    public static final long _compat_reg_mr$offset() {
        return _compat_reg_mr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_reg_mr)(void)
     * }
     */
    public static MemorySegment _compat_reg_mr(MemorySegment struct) {
        return struct.get(_compat_reg_mr$LAYOUT, _compat_reg_mr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_reg_mr)(void)
     * }
     */
    public static void _compat_reg_mr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_reg_mr$LAYOUT, _compat_reg_mr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_rereg_mr)(void)
     * }
     */
    public static class _compat_rereg_mr {

        _compat_rereg_mr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_rereg_mr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_rereg_mr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_rereg_mr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_rereg_mr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_rereg_mr)(void)
     * }
     */
    public static final AddressLayout _compat_rereg_mr$layout() {
        return _compat_rereg_mr$LAYOUT;
    }

    private static final long _compat_rereg_mr$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_rereg_mr)(void)
     * }
     */
    public static final long _compat_rereg_mr$offset() {
        return _compat_rereg_mr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_rereg_mr)(void)
     * }
     */
    public static MemorySegment _compat_rereg_mr(MemorySegment struct) {
        return struct.get(_compat_rereg_mr$LAYOUT, _compat_rereg_mr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_rereg_mr)(void)
     * }
     */
    public static void _compat_rereg_mr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_rereg_mr$LAYOUT, _compat_rereg_mr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_dereg_mr)(void)
     * }
     */
    public static class _compat_dereg_mr {

        _compat_dereg_mr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_dereg_mr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_dereg_mr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_dereg_mr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_dereg_mr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_dereg_mr)(void)
     * }
     */
    public static final AddressLayout _compat_dereg_mr$layout() {
        return _compat_dereg_mr$LAYOUT;
    }

    private static final long _compat_dereg_mr$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_dereg_mr)(void)
     * }
     */
    public static final long _compat_dereg_mr$offset() {
        return _compat_dereg_mr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_dereg_mr)(void)
     * }
     */
    public static MemorySegment _compat_dereg_mr(MemorySegment struct) {
        return struct.get(_compat_dereg_mr$LAYOUT, _compat_dereg_mr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_dereg_mr)(void)
     * }
     */
    public static void _compat_dereg_mr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_dereg_mr$LAYOUT, _compat_dereg_mr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_mw *(*alloc_mw)(struct ibv_pd *, enum ibv_mw_type)
     * }
     */
    public static class alloc_mw {

        alloc_mw() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(alloc_mw.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(alloc_mw.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout alloc_mw$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("alloc_mw"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_mw *(*alloc_mw)(struct ibv_pd *, enum ibv_mw_type)
     * }
     */
    public static final AddressLayout alloc_mw$layout() {
        return alloc_mw$LAYOUT;
    }

    private static final long alloc_mw$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_mw *(*alloc_mw)(struct ibv_pd *, enum ibv_mw_type)
     * }
     */
    public static final long alloc_mw$offset() {
        return alloc_mw$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_mw *(*alloc_mw)(struct ibv_pd *, enum ibv_mw_type)
     * }
     */
    public static MemorySegment alloc_mw(MemorySegment struct) {
        return struct.get(alloc_mw$LAYOUT, alloc_mw$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_mw *(*alloc_mw)(struct ibv_pd *, enum ibv_mw_type)
     * }
     */
    public static void alloc_mw(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(alloc_mw$LAYOUT, alloc_mw$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*bind_mw)(struct ibv_qp *, struct ibv_mw *, struct ibv_mw_bind *)
     * }
     */
    public static class bind_mw {

        bind_mw() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(bind_mw.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(bind_mw.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout bind_mw$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("bind_mw"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*bind_mw)(struct ibv_qp *, struct ibv_mw *, struct ibv_mw_bind *)
     * }
     */
    public static final AddressLayout bind_mw$layout() {
        return bind_mw$LAYOUT;
    }

    private static final long bind_mw$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*bind_mw)(struct ibv_qp *, struct ibv_mw *, struct ibv_mw_bind *)
     * }
     */
    public static final long bind_mw$offset() {
        return bind_mw$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*bind_mw)(struct ibv_qp *, struct ibv_mw *, struct ibv_mw_bind *)
     * }
     */
    public static MemorySegment bind_mw(MemorySegment struct) {
        return struct.get(bind_mw$LAYOUT, bind_mw$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*bind_mw)(struct ibv_qp *, struct ibv_mw *, struct ibv_mw_bind *)
     * }
     */
    public static void bind_mw(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(bind_mw$LAYOUT, bind_mw$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*dealloc_mw)(struct ibv_mw *)
     * }
     */
    public static class dealloc_mw {

        dealloc_mw() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(dealloc_mw.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(dealloc_mw.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout dealloc_mw$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("dealloc_mw"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*dealloc_mw)(struct ibv_mw *)
     * }
     */
    public static final AddressLayout dealloc_mw$layout() {
        return dealloc_mw$LAYOUT;
    }

    private static final long dealloc_mw$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*dealloc_mw)(struct ibv_mw *)
     * }
     */
    public static final long dealloc_mw$offset() {
        return dealloc_mw$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*dealloc_mw)(struct ibv_mw *)
     * }
     */
    public static MemorySegment dealloc_mw(MemorySegment struct) {
        return struct.get(dealloc_mw$LAYOUT, dealloc_mw$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*dealloc_mw)(struct ibv_mw *)
     * }
     */
    public static void dealloc_mw(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(dealloc_mw$LAYOUT, dealloc_mw$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_create_cq)(void)
     * }
     */
    public static class _compat_create_cq {

        _compat_create_cq() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_create_cq.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_create_cq.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_create_cq$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_create_cq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_create_cq)(void)
     * }
     */
    public static final AddressLayout _compat_create_cq$layout() {
        return _compat_create_cq$LAYOUT;
    }

    private static final long _compat_create_cq$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_create_cq)(void)
     * }
     */
    public static final long _compat_create_cq$offset() {
        return _compat_create_cq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_create_cq)(void)
     * }
     */
    public static MemorySegment _compat_create_cq(MemorySegment struct) {
        return struct.get(_compat_create_cq$LAYOUT, _compat_create_cq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_create_cq)(void)
     * }
     */
    public static void _compat_create_cq(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_create_cq$LAYOUT, _compat_create_cq$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*poll_cq)(struct ibv_cq *, int, struct ibv_wc *)
     * }
     */
    public static class poll_cq {

        poll_cq() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(poll_cq.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(poll_cq.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout poll_cq$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("poll_cq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*poll_cq)(struct ibv_cq *, int, struct ibv_wc *)
     * }
     */
    public static final AddressLayout poll_cq$layout() {
        return poll_cq$LAYOUT;
    }

    private static final long poll_cq$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*poll_cq)(struct ibv_cq *, int, struct ibv_wc *)
     * }
     */
    public static final long poll_cq$offset() {
        return poll_cq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*poll_cq)(struct ibv_cq *, int, struct ibv_wc *)
     * }
     */
    public static MemorySegment poll_cq(MemorySegment struct) {
        return struct.get(poll_cq$LAYOUT, poll_cq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*poll_cq)(struct ibv_cq *, int, struct ibv_wc *)
     * }
     */
    public static void poll_cq(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(poll_cq$LAYOUT, poll_cq$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*req_notify_cq)(struct ibv_cq *, int)
     * }
     */
    public static class req_notify_cq {

        req_notify_cq() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(req_notify_cq.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(req_notify_cq.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout req_notify_cq$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("req_notify_cq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*req_notify_cq)(struct ibv_cq *, int)
     * }
     */
    public static final AddressLayout req_notify_cq$layout() {
        return req_notify_cq$LAYOUT;
    }

    private static final long req_notify_cq$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*req_notify_cq)(struct ibv_cq *, int)
     * }
     */
    public static final long req_notify_cq$offset() {
        return req_notify_cq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*req_notify_cq)(struct ibv_cq *, int)
     * }
     */
    public static MemorySegment req_notify_cq(MemorySegment struct) {
        return struct.get(req_notify_cq$LAYOUT, req_notify_cq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*req_notify_cq)(struct ibv_cq *, int)
     * }
     */
    public static void req_notify_cq(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(req_notify_cq$LAYOUT, req_notify_cq$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_cq_event)(void)
     * }
     */
    public static class _compat_cq_event {

        _compat_cq_event() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_cq_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_cq_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_cq_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_cq_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_cq_event)(void)
     * }
     */
    public static final AddressLayout _compat_cq_event$layout() {
        return _compat_cq_event$LAYOUT;
    }

    private static final long _compat_cq_event$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_cq_event)(void)
     * }
     */
    public static final long _compat_cq_event$offset() {
        return _compat_cq_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_cq_event)(void)
     * }
     */
    public static MemorySegment _compat_cq_event(MemorySegment struct) {
        return struct.get(_compat_cq_event$LAYOUT, _compat_cq_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_cq_event)(void)
     * }
     */
    public static void _compat_cq_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_cq_event$LAYOUT, _compat_cq_event$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_resize_cq)(void)
     * }
     */
    public static class _compat_resize_cq {

        _compat_resize_cq() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_resize_cq.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_resize_cq.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_resize_cq$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_resize_cq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_resize_cq)(void)
     * }
     */
    public static final AddressLayout _compat_resize_cq$layout() {
        return _compat_resize_cq$LAYOUT;
    }

    private static final long _compat_resize_cq$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_resize_cq)(void)
     * }
     */
    public static final long _compat_resize_cq$offset() {
        return _compat_resize_cq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_resize_cq)(void)
     * }
     */
    public static MemorySegment _compat_resize_cq(MemorySegment struct) {
        return struct.get(_compat_resize_cq$LAYOUT, _compat_resize_cq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_resize_cq)(void)
     * }
     */
    public static void _compat_resize_cq(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_resize_cq$LAYOUT, _compat_resize_cq$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_destroy_cq)(void)
     * }
     */
    public static class _compat_destroy_cq {

        _compat_destroy_cq() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_destroy_cq.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_destroy_cq.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_destroy_cq$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_destroy_cq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_cq)(void)
     * }
     */
    public static final AddressLayout _compat_destroy_cq$layout() {
        return _compat_destroy_cq$LAYOUT;
    }

    private static final long _compat_destroy_cq$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_cq)(void)
     * }
     */
    public static final long _compat_destroy_cq$offset() {
        return _compat_destroy_cq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_cq)(void)
     * }
     */
    public static MemorySegment _compat_destroy_cq(MemorySegment struct) {
        return struct.get(_compat_destroy_cq$LAYOUT, _compat_destroy_cq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_cq)(void)
     * }
     */
    public static void _compat_destroy_cq(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_destroy_cq$LAYOUT, _compat_destroy_cq$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_create_srq)(void)
     * }
     */
    public static class _compat_create_srq {

        _compat_create_srq() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_create_srq.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_create_srq.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_create_srq$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_create_srq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_create_srq)(void)
     * }
     */
    public static final AddressLayout _compat_create_srq$layout() {
        return _compat_create_srq$LAYOUT;
    }

    private static final long _compat_create_srq$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_create_srq)(void)
     * }
     */
    public static final long _compat_create_srq$offset() {
        return _compat_create_srq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_create_srq)(void)
     * }
     */
    public static MemorySegment _compat_create_srq(MemorySegment struct) {
        return struct.get(_compat_create_srq$LAYOUT, _compat_create_srq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_create_srq)(void)
     * }
     */
    public static void _compat_create_srq(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_create_srq$LAYOUT, _compat_create_srq$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_modify_srq)(void)
     * }
     */
    public static class _compat_modify_srq {

        _compat_modify_srq() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_modify_srq.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_modify_srq.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_modify_srq$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_modify_srq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_modify_srq)(void)
     * }
     */
    public static final AddressLayout _compat_modify_srq$layout() {
        return _compat_modify_srq$LAYOUT;
    }

    private static final long _compat_modify_srq$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_modify_srq)(void)
     * }
     */
    public static final long _compat_modify_srq$offset() {
        return _compat_modify_srq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_modify_srq)(void)
     * }
     */
    public static MemorySegment _compat_modify_srq(MemorySegment struct) {
        return struct.get(_compat_modify_srq$LAYOUT, _compat_modify_srq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_modify_srq)(void)
     * }
     */
    public static void _compat_modify_srq(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_modify_srq$LAYOUT, _compat_modify_srq$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_query_srq)(void)
     * }
     */
    public static class _compat_query_srq {

        _compat_query_srq() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_query_srq.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_query_srq.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_query_srq$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_query_srq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_query_srq)(void)
     * }
     */
    public static final AddressLayout _compat_query_srq$layout() {
        return _compat_query_srq$LAYOUT;
    }

    private static final long _compat_query_srq$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_query_srq)(void)
     * }
     */
    public static final long _compat_query_srq$offset() {
        return _compat_query_srq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_query_srq)(void)
     * }
     */
    public static MemorySegment _compat_query_srq(MemorySegment struct) {
        return struct.get(_compat_query_srq$LAYOUT, _compat_query_srq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_query_srq)(void)
     * }
     */
    public static void _compat_query_srq(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_query_srq$LAYOUT, _compat_query_srq$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_destroy_srq)(void)
     * }
     */
    public static class _compat_destroy_srq {

        _compat_destroy_srq() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_destroy_srq.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_destroy_srq.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_destroy_srq$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_destroy_srq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_srq)(void)
     * }
     */
    public static final AddressLayout _compat_destroy_srq$layout() {
        return _compat_destroy_srq$LAYOUT;
    }

    private static final long _compat_destroy_srq$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_srq)(void)
     * }
     */
    public static final long _compat_destroy_srq$offset() {
        return _compat_destroy_srq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_srq)(void)
     * }
     */
    public static MemorySegment _compat_destroy_srq(MemorySegment struct) {
        return struct.get(_compat_destroy_srq$LAYOUT, _compat_destroy_srq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_srq)(void)
     * }
     */
    public static void _compat_destroy_srq(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_destroy_srq$LAYOUT, _compat_destroy_srq$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*post_srq_recv)(struct ibv_srq *, struct ibv_recv_wr *, struct ibv_recv_wr **)
     * }
     */
    public static class post_srq_recv {

        post_srq_recv() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(post_srq_recv.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(post_srq_recv.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout post_srq_recv$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("post_srq_recv"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*post_srq_recv)(struct ibv_srq *, struct ibv_recv_wr *, struct ibv_recv_wr **)
     * }
     */
    public static final AddressLayout post_srq_recv$layout() {
        return post_srq_recv$LAYOUT;
    }

    private static final long post_srq_recv$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*post_srq_recv)(struct ibv_srq *, struct ibv_recv_wr *, struct ibv_recv_wr **)
     * }
     */
    public static final long post_srq_recv$offset() {
        return post_srq_recv$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*post_srq_recv)(struct ibv_srq *, struct ibv_recv_wr *, struct ibv_recv_wr **)
     * }
     */
    public static MemorySegment post_srq_recv(MemorySegment struct) {
        return struct.get(post_srq_recv$LAYOUT, post_srq_recv$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*post_srq_recv)(struct ibv_srq *, struct ibv_recv_wr *, struct ibv_recv_wr **)
     * }
     */
    public static void post_srq_recv(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(post_srq_recv$LAYOUT, post_srq_recv$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_create_qp)(void)
     * }
     */
    public static class _compat_create_qp {

        _compat_create_qp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_create_qp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_create_qp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_create_qp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_create_qp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_create_qp)(void)
     * }
     */
    public static final AddressLayout _compat_create_qp$layout() {
        return _compat_create_qp$LAYOUT;
    }

    private static final long _compat_create_qp$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_create_qp)(void)
     * }
     */
    public static final long _compat_create_qp$offset() {
        return _compat_create_qp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_create_qp)(void)
     * }
     */
    public static MemorySegment _compat_create_qp(MemorySegment struct) {
        return struct.get(_compat_create_qp$LAYOUT, _compat_create_qp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_create_qp)(void)
     * }
     */
    public static void _compat_create_qp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_create_qp$LAYOUT, _compat_create_qp$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_query_qp)(void)
     * }
     */
    public static class _compat_query_qp {

        _compat_query_qp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_query_qp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_query_qp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_query_qp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_query_qp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_query_qp)(void)
     * }
     */
    public static final AddressLayout _compat_query_qp$layout() {
        return _compat_query_qp$LAYOUT;
    }

    private static final long _compat_query_qp$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_query_qp)(void)
     * }
     */
    public static final long _compat_query_qp$offset() {
        return _compat_query_qp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_query_qp)(void)
     * }
     */
    public static MemorySegment _compat_query_qp(MemorySegment struct) {
        return struct.get(_compat_query_qp$LAYOUT, _compat_query_qp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_query_qp)(void)
     * }
     */
    public static void _compat_query_qp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_query_qp$LAYOUT, _compat_query_qp$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_modify_qp)(void)
     * }
     */
    public static class _compat_modify_qp {

        _compat_modify_qp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_modify_qp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_modify_qp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_modify_qp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_modify_qp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_modify_qp)(void)
     * }
     */
    public static final AddressLayout _compat_modify_qp$layout() {
        return _compat_modify_qp$LAYOUT;
    }

    private static final long _compat_modify_qp$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_modify_qp)(void)
     * }
     */
    public static final long _compat_modify_qp$offset() {
        return _compat_modify_qp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_modify_qp)(void)
     * }
     */
    public static MemorySegment _compat_modify_qp(MemorySegment struct) {
        return struct.get(_compat_modify_qp$LAYOUT, _compat_modify_qp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_modify_qp)(void)
     * }
     */
    public static void _compat_modify_qp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_modify_qp$LAYOUT, _compat_modify_qp$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_destroy_qp)(void)
     * }
     */
    public static class _compat_destroy_qp {

        _compat_destroy_qp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_destroy_qp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_destroy_qp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_destroy_qp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_destroy_qp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_qp)(void)
     * }
     */
    public static final AddressLayout _compat_destroy_qp$layout() {
        return _compat_destroy_qp$LAYOUT;
    }

    private static final long _compat_destroy_qp$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_qp)(void)
     * }
     */
    public static final long _compat_destroy_qp$offset() {
        return _compat_destroy_qp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_qp)(void)
     * }
     */
    public static MemorySegment _compat_destroy_qp(MemorySegment struct) {
        return struct.get(_compat_destroy_qp$LAYOUT, _compat_destroy_qp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_qp)(void)
     * }
     */
    public static void _compat_destroy_qp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_destroy_qp$LAYOUT, _compat_destroy_qp$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*post_send)(struct ibv_qp *, struct ibv_send_wr *, struct ibv_send_wr **)
     * }
     */
    public static class post_send {

        post_send() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(post_send.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(post_send.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout post_send$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("post_send"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*post_send)(struct ibv_qp *, struct ibv_send_wr *, struct ibv_send_wr **)
     * }
     */
    public static final AddressLayout post_send$layout() {
        return post_send$LAYOUT;
    }

    private static final long post_send$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*post_send)(struct ibv_qp *, struct ibv_send_wr *, struct ibv_send_wr **)
     * }
     */
    public static final long post_send$offset() {
        return post_send$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*post_send)(struct ibv_qp *, struct ibv_send_wr *, struct ibv_send_wr **)
     * }
     */
    public static MemorySegment post_send(MemorySegment struct) {
        return struct.get(post_send$LAYOUT, post_send$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*post_send)(struct ibv_qp *, struct ibv_send_wr *, struct ibv_send_wr **)
     * }
     */
    public static void post_send(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(post_send$LAYOUT, post_send$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*post_recv)(struct ibv_qp *, struct ibv_recv_wr *, struct ibv_recv_wr **)
     * }
     */
    public static class post_recv {

        post_recv() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(post_recv.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(post_recv.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout post_recv$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("post_recv"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*post_recv)(struct ibv_qp *, struct ibv_recv_wr *, struct ibv_recv_wr **)
     * }
     */
    public static final AddressLayout post_recv$layout() {
        return post_recv$LAYOUT;
    }

    private static final long post_recv$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*post_recv)(struct ibv_qp *, struct ibv_recv_wr *, struct ibv_recv_wr **)
     * }
     */
    public static final long post_recv$offset() {
        return post_recv$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*post_recv)(struct ibv_qp *, struct ibv_recv_wr *, struct ibv_recv_wr **)
     * }
     */
    public static MemorySegment post_recv(MemorySegment struct) {
        return struct.get(post_recv$LAYOUT, post_recv$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*post_recv)(struct ibv_qp *, struct ibv_recv_wr *, struct ibv_recv_wr **)
     * }
     */
    public static void post_recv(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(post_recv$LAYOUT, post_recv$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_create_ah)(void)
     * }
     */
    public static class _compat_create_ah {

        _compat_create_ah() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_create_ah.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_create_ah.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_create_ah$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_create_ah"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_create_ah)(void)
     * }
     */
    public static final AddressLayout _compat_create_ah$layout() {
        return _compat_create_ah$LAYOUT;
    }

    private static final long _compat_create_ah$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_create_ah)(void)
     * }
     */
    public static final long _compat_create_ah$offset() {
        return _compat_create_ah$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_create_ah)(void)
     * }
     */
    public static MemorySegment _compat_create_ah(MemorySegment struct) {
        return struct.get(_compat_create_ah$LAYOUT, _compat_create_ah$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_create_ah)(void)
     * }
     */
    public static void _compat_create_ah(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_create_ah$LAYOUT, _compat_create_ah$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_destroy_ah)(void)
     * }
     */
    public static class _compat_destroy_ah {

        _compat_destroy_ah() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_destroy_ah.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_destroy_ah.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_destroy_ah$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_destroy_ah"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_ah)(void)
     * }
     */
    public static final AddressLayout _compat_destroy_ah$layout() {
        return _compat_destroy_ah$LAYOUT;
    }

    private static final long _compat_destroy_ah$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_ah)(void)
     * }
     */
    public static final long _compat_destroy_ah$offset() {
        return _compat_destroy_ah$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_ah)(void)
     * }
     */
    public static MemorySegment _compat_destroy_ah(MemorySegment struct) {
        return struct.get(_compat_destroy_ah$LAYOUT, _compat_destroy_ah$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_destroy_ah)(void)
     * }
     */
    public static void _compat_destroy_ah(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_destroy_ah$LAYOUT, _compat_destroy_ah$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_attach_mcast)(void)
     * }
     */
    public static class _compat_attach_mcast {

        _compat_attach_mcast() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_attach_mcast.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_attach_mcast.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_attach_mcast$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_attach_mcast"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_attach_mcast)(void)
     * }
     */
    public static final AddressLayout _compat_attach_mcast$layout() {
        return _compat_attach_mcast$LAYOUT;
    }

    private static final long _compat_attach_mcast$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_attach_mcast)(void)
     * }
     */
    public static final long _compat_attach_mcast$offset() {
        return _compat_attach_mcast$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_attach_mcast)(void)
     * }
     */
    public static MemorySegment _compat_attach_mcast(MemorySegment struct) {
        return struct.get(_compat_attach_mcast$LAYOUT, _compat_attach_mcast$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_attach_mcast)(void)
     * }
     */
    public static void _compat_attach_mcast(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_attach_mcast$LAYOUT, _compat_attach_mcast$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_detach_mcast)(void)
     * }
     */
    public static class _compat_detach_mcast {

        _compat_detach_mcast() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_detach_mcast.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_detach_mcast.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_detach_mcast$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_detach_mcast"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_detach_mcast)(void)
     * }
     */
    public static final AddressLayout _compat_detach_mcast$layout() {
        return _compat_detach_mcast$LAYOUT;
    }

    private static final long _compat_detach_mcast$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_detach_mcast)(void)
     * }
     */
    public static final long _compat_detach_mcast$offset() {
        return _compat_detach_mcast$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_detach_mcast)(void)
     * }
     */
    public static MemorySegment _compat_detach_mcast(MemorySegment struct) {
        return struct.get(_compat_detach_mcast$LAYOUT, _compat_detach_mcast$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_detach_mcast)(void)
     * }
     */
    public static void _compat_detach_mcast(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_detach_mcast$LAYOUT, _compat_detach_mcast$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void *(*_compat_async_event)(void)
     * }
     */
    public static class _compat_async_event {

        _compat_async_event() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(_compat_async_event.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(_compat_async_event.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout _compat_async_event$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("_compat_async_event"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *(*_compat_async_event)(void)
     * }
     */
    public static final AddressLayout _compat_async_event$layout() {
        return _compat_async_event$LAYOUT;
    }

    private static final long _compat_async_event$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *(*_compat_async_event)(void)
     * }
     */
    public static final long _compat_async_event$offset() {
        return _compat_async_event$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *(*_compat_async_event)(void)
     * }
     */
    public static MemorySegment _compat_async_event(MemorySegment struct) {
        return struct.get(_compat_async_event$LAYOUT, _compat_async_event$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *(*_compat_async_event)(void)
     * }
     */
    public static void _compat_async_event(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(_compat_async_event$LAYOUT, _compat_async_event$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

