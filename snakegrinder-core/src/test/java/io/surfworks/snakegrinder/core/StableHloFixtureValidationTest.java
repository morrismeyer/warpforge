package io.surfworks.snakegrinder.core;

import org.junit.jupiter.api.Assumptions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * StableHLO Fixture Validation Tests
 *
 * Validates that generated MLIR fixtures are well-formed and contain valid
 * StableHLO operations. These tests run in JVM mode and don't require the
 * native image.
 *
 * The fixtures are generated by StableHloFixtureGenerator and stored in:
 *   snakegrinder-core/src/test/resources/fixtures/stablehlo/
 *
 * Run with: ./gradlew :snakegrinder-core:test
 */
class StableHloFixtureValidationTest {

    private static Path fixturesDir;
    private static List<Path> allFixtures;

    @BeforeAll
    static void setup() throws IOException {
        Path projectRoot = findProjectRoot();
        fixturesDir = projectRoot.resolve("snakegrinder-core/src/test/resources/fixtures/stablehlo");

        if (Files.exists(fixturesDir)) {
            allFixtures = Files.walk(fixturesDir)
                    .filter(p -> p.toString().endsWith(".mlir"))
                    .sorted()
                    .toList();
        } else {
            allFixtures = List.of();
        }
    }

    private static Path findProjectRoot() {
        Path current = Paths.get("").toAbsolutePath();
        while (current != null) {
            if (Files.exists(current.resolve("settings.gradle"))) return current;
            current = current.getParent();
        }
        return Paths.get(System.getProperty("user.dir"));
    }

    static Stream<Path> fixtureFiles() {
        if (allFixtures == null || allFixtures.isEmpty()) {
            return Stream.empty();
        }
        return allFixtures.stream();
    }

    // ========================================================================
    // Fixture Existence Tests
    // ========================================================================

    @Test
    void fixturesDirectoryExists() {
        assertTrue(Files.exists(fixturesDir),
                "Fixtures directory should exist. Run ./gradlew :snakegrinder-core:generateFixtures first.");
    }

    @Test
    void atLeastOneFixtureExists() {
        Assumptions.assumeTrue(Files.exists(fixturesDir), "Fixtures directory doesn't exist");
        assertFalse(allFixtures.isEmpty(),
                "At least one MLIR fixture should exist. Run ./gradlew :snakegrinder-core:generateFixtures first.");
    }

    // ========================================================================
    // MLIR Structure Validation
    // ========================================================================

    @ParameterizedTest(name = "{0}")
    @MethodSource("fixtureFiles")
    void fixtureHasModuleDeclaration(Path fixture) throws IOException {
        Assumptions.assumeTrue(Files.exists(fixture));
        String mlir = Files.readString(fixture);

        Pattern modulePattern = Pattern.compile("module\\s+@\\w+\\s*\\{");
        assertTrue(modulePattern.matcher(mlir).find(),
                "Fixture " + fixture.getFileName() + " should have module declaration");
    }

    @ParameterizedTest(name = "{0}")
    @MethodSource("fixtureFiles")
    void fixtureHasFunctionDeclaration(Path fixture) throws IOException {
        Assumptions.assumeTrue(Files.exists(fixture));
        String mlir = Files.readString(fixture);

        Pattern funcPattern = Pattern.compile("func\\.func\\s+(public\\s+)?@\\w+");
        assertTrue(funcPattern.matcher(mlir).find(),
                "Fixture " + fixture.getFileName() + " should have func.func declaration");
    }

    @ParameterizedTest(name = "{0}")
    @MethodSource("fixtureFiles")
    void fixtureHasReturn(Path fixture) throws IOException {
        Assumptions.assumeTrue(Files.exists(fixture));
        String mlir = Files.readString(fixture);

        assertTrue(mlir.contains("stablehlo.return"),
                "Fixture " + fixture.getFileName() + " should have stablehlo.return");
    }

    @ParameterizedTest(name = "{0}")
    @MethodSource("fixtureFiles")
    void fixtureHasBalancedBraces(Path fixture) throws IOException {
        Assumptions.assumeTrue(Files.exists(fixture));
        String mlir = Files.readString(fixture);

        long openBraces = mlir.chars().filter(c -> c == '{').count();
        long closeBraces = mlir.chars().filter(c -> c == '}').count();
        assertEquals(openBraces, closeBraces,
                "Fixture " + fixture.getFileName() + " should have balanced braces");

        long openParens = mlir.chars().filter(c -> c == '(').count();
        long closeParens = mlir.chars().filter(c -> c == ')').count();
        assertEquals(openParens, closeParens,
                "Fixture " + fixture.getFileName() + " should have balanced parentheses");
    }

    @ParameterizedTest(name = "{0}")
    @MethodSource("fixtureFiles")
    void fixtureHasValidTensorTypes(Path fixture) throws IOException {
        Assumptions.assumeTrue(Files.exists(fixture));
        String mlir = Files.readString(fixture);

        // All tensor types should have valid format
        Pattern tensorPattern = Pattern.compile("tensor<([^>]+)>");
        Matcher matcher = tensorPattern.matcher(mlir);

        while (matcher.find()) {
            String tensorType = matcher.group(1);
            // Should end with element type (f32, f64, i32, i64, etc.)
            assertTrue(tensorType.matches(".*x?(f16|f32|f64|bf16|i8|i16|i32|i64|ui8|ui16|ui32|ui64)"),
                    "Invalid tensor type in " + fixture.getFileName() + ": tensor<" + tensorType + ">");
        }
    }

    @ParameterizedTest(name = "{0}")
    @MethodSource("fixtureFiles")
    void fixtureHasNoNullCharacters(Path fixture) throws IOException {
        Assumptions.assumeTrue(Files.exists(fixture));
        String mlir = Files.readString(fixture);

        assertFalse(mlir.contains("\0"),
                "Fixture " + fixture.getFileName() + " should not contain null characters");
    }

    // ========================================================================
    // Coverage Analysis
    // ========================================================================

    @Test
    void reportCoverage() throws IOException {
        Assumptions.assumeTrue(Files.exists(fixturesDir) && !allFixtures.isEmpty());

        Map<String, Set<String>> opsByCategory = new TreeMap<>();
        Set<String> allOps = new TreeSet<>();

        for (Path fixture : allFixtures) {
            String mlir = Files.readString(fixture);
            String category = fixture.getParent().getFileName().toString();

            Pattern opPattern = Pattern.compile("stablehlo\\.(\\w+)");
            Matcher matcher = opPattern.matcher(mlir);

            Set<String> categoryOps = opsByCategory.computeIfAbsent(category, k -> new TreeSet<>());
            while (matcher.find()) {
                String op = matcher.group(1);
                categoryOps.add(op);
                allOps.add(op);
            }
        }

        System.out.println();
        System.out.println("=== StableHLO Operation Coverage Report ===");
        System.out.println();
        System.out.println("Total fixtures: " + allFixtures.size());
        System.out.println("Total unique operations: " + allOps.size());
        System.out.println();

        System.out.println("Operations by category:");
        for (Map.Entry<String, Set<String>> entry : opsByCategory.entrySet()) {
            System.out.println("  " + entry.getKey() + ": " + entry.getValue());
        }

        System.out.println();
        System.out.println("All operations found: " + allOps);
        System.out.println();

        // List operations that snakeburger tests for but we don't have fixtures for
        Set<String> snakeburgerOps = Set.of(
                "abs", "add", "all_gather", "all_reduce", "all_to_all", "and", "atan",
                "batch_norm_inference", "bitcast_convert", "broadcast_in_dim", "case",
                "cbrt", "ceil", "cholesky", "clamp", "collective_broadcast", "collective_permute",
                "compare", "complex", "composite", "concatenate", "constant", "convert",
                "convolution", "cosine", "count_leading_zeros", "custom_call", "divide",
                "dot", "dot_general", "dynamic_broadcast_in_dim", "dynamic_gather",
                "dynamic_iota", "dynamic_pad", "dynamic_reshape", "dynamic_slice",
                "dynamic_update_slice", "exponential", "exponential_minus_one", "fft",
                "floor", "gather", "get_dimension_size", "get_tuple_element", "imag",
                "iota", "is_finite", "log", "log_plus_one", "logistic", "map", "maximum",
                "minimum", "multiply", "negate", "not", "optimization_barrier", "or",
                "pad", "partition_id", "popcnt", "power", "real", "reduce", "reduce_precision",
                "reduce_scatter", "reduce_window", "remainder", "replica_id", "reshape",
                "return", "reverse", "rng", "round_nearest_afz", "round_nearest_even",
                "rsqrt", "scatter", "select", "select_and_scatter", "shift_left",
                "shift_right_arithmetic", "shift_right_logical", "sign", "sine", "slice",
                "sort", "sqrt", "subtract", "tan", "tanh", "transpose", "triangular_solve",
                "tuple", "uniform_dequantize", "uniform_quantize", "unsupported_op", "xor"
        );

        Set<String> missingOps = new TreeSet<>(snakeburgerOps);
        missingOps.removeAll(allOps);

        System.out.println("Operations tested by snakeburger but NOT in fixtures (" + missingOps.size() + "):");
        System.out.println("  " + missingOps);
        System.out.println();

        int coverage = (int) ((1.0 - (double) missingOps.size() / snakeburgerOps.size()) * 100);
        System.out.println("Coverage: " + coverage + "% (" + allOps.size() + "/" + snakeburgerOps.size() + " operations)");
    }

    // ========================================================================
    // Category-Specific Tests
    // ========================================================================

    @Nested
    class ElementwiseFixtures {

        @Test
        void addFixtureContainsAddOp() throws IOException {
            Path fixture = fixturesDir.resolve("elementwise/add.mlir");
            Assumptions.assumeTrue(Files.exists(fixture));
            String mlir = Files.readString(fixture);
            assertTrue(mlir.contains("stablehlo.add"), "add.mlir should contain stablehlo.add");
        }
    }

    @Nested
    class MatrixFixtures {

        @Test
        void linearFixtureContainsDotGeneral() throws IOException {
            Path fixture = fixturesDir.resolve("matrix/linear.mlir");
            Assumptions.assumeTrue(Files.exists(fixture));
            String mlir = Files.readString(fixture);
            assertTrue(mlir.contains("stablehlo.dot_general"),
                    "linear.mlir should contain stablehlo.dot_general");
        }

        @Test
        void matmulFixtureContainsDotGeneral() throws IOException {
            Path fixture = fixturesDir.resolve("matrix/matmul.mlir");
            Assumptions.assumeTrue(Files.exists(fixture));
            String mlir = Files.readString(fixture);
            assertTrue(mlir.contains("stablehlo.dot_general"),
                    "matmul.mlir should contain stablehlo.dot_general");
        }
    }

    @Nested
    class ActivationFixtures {

        @Test
        void reluFixtureContainsMaximum() throws IOException {
            Path fixture = fixturesDir.resolve("activation/relu.mlir");
            Assumptions.assumeTrue(Files.exists(fixture));
            String mlir = Files.readString(fixture);
            assertTrue(mlir.contains("stablehlo.maximum"),
                    "relu.mlir should contain stablehlo.maximum");
        }
    }

    @Nested
    class CompositeFixtures {

        @Test
        void simpleMlpFixtureIsComplete() throws IOException {
            Path fixture = fixturesDir.resolve("composite/simple_mlp.mlir");
            Assumptions.assumeTrue(Files.exists(fixture));
            String mlir = Files.readString(fixture);

            assertTrue(mlir.contains("stablehlo.dot_general"), "MLP should have dot_general");
            assertTrue(mlir.contains("stablehlo.maximum"), "MLP should have maximum (ReLU)");
            assertTrue(mlir.contains("stablehlo.add"), "MLP should have add (bias)");
            assertTrue(mlir.contains("stablehlo.constant"), "MLP should have constants");
        }
    }
}
