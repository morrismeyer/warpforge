// Generated by jextract

package io.surfworks.warpforge.io.ffi.rdmacm;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ibv_cq_ex {
 *     struct ibv_context *context;
 *     struct ibv_comp_channel *channel;
 *     void *cq_context;
 *     uint32_t handle;
 *     int cqe;
 *     pthread_mutex_t mutex;
 *     pthread_cond_t cond;
 *     uint32_t comp_events_completed;
 *     uint32_t async_events_completed;
 *     uint32_t comp_mask;
 *     enum ibv_wc_status status;
 *     uint64_t wr_id;
 *     int (*start_poll)(struct ibv_cq_ex *, struct ibv_poll_cq_attr *);
 *     int (*next_poll)(struct ibv_cq_ex *);
 *     void (*end_poll)(struct ibv_cq_ex *);
 *     enum ibv_wc_opcode (*read_opcode)(struct ibv_cq_ex *);
 *     uint32_t (*read_vendor_err)(struct ibv_cq_ex *);
 *     uint32_t (*read_byte_len)(struct ibv_cq_ex *);
 *     __be32 (*read_imm_data)(struct ibv_cq_ex *);
 *     uint32_t (*read_qp_num)(struct ibv_cq_ex *);
 *     uint32_t (*read_src_qp)(struct ibv_cq_ex *);
 *     unsigned int (*read_wc_flags)(struct ibv_cq_ex *);
 *     uint32_t (*read_slid)(struct ibv_cq_ex *);
 *     uint8_t (*read_sl)(struct ibv_cq_ex *);
 *     uint8_t (*read_dlid_path_bits)(struct ibv_cq_ex *);
 *     uint64_t (*read_completion_ts)(struct ibv_cq_ex *);
 *     uint16_t (*read_cvlan)(struct ibv_cq_ex *);
 *     uint32_t (*read_flow_tag)(struct ibv_cq_ex *);
 *     void (*read_tm_info)(struct ibv_cq_ex *, struct ibv_wc_tm_info *);
 *     uint64_t (*read_completion_wallclock_ns)(struct ibv_cq_ex *);
 * }
 * }
 */
public class ibv_cq_ex {

    ibv_cq_ex() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        RdmaCm.C_POINTER.withName("context"),
        RdmaCm.C_POINTER.withName("channel"),
        RdmaCm.C_POINTER.withName("cq_context"),
        RdmaCm.C_INT.withName("handle"),
        RdmaCm.C_INT.withName("cqe"),
        pthread_mutex_t.layout().withName("mutex"),
        pthread_cond_t.layout().withName("cond"),
        RdmaCm.C_INT.withName("comp_events_completed"),
        RdmaCm.C_INT.withName("async_events_completed"),
        RdmaCm.C_INT.withName("comp_mask"),
        RdmaCm.C_INT.withName("status"),
        RdmaCm.C_LONG.withName("wr_id"),
        RdmaCm.C_POINTER.withName("start_poll"),
        RdmaCm.C_POINTER.withName("next_poll"),
        RdmaCm.C_POINTER.withName("end_poll"),
        RdmaCm.C_POINTER.withName("read_opcode"),
        RdmaCm.C_POINTER.withName("read_vendor_err"),
        RdmaCm.C_POINTER.withName("read_byte_len"),
        RdmaCm.C_POINTER.withName("read_imm_data"),
        RdmaCm.C_POINTER.withName("read_qp_num"),
        RdmaCm.C_POINTER.withName("read_src_qp"),
        RdmaCm.C_POINTER.withName("read_wc_flags"),
        RdmaCm.C_POINTER.withName("read_slid"),
        RdmaCm.C_POINTER.withName("read_sl"),
        RdmaCm.C_POINTER.withName("read_dlid_path_bits"),
        RdmaCm.C_POINTER.withName("read_completion_ts"),
        RdmaCm.C_POINTER.withName("read_cvlan"),
        RdmaCm.C_POINTER.withName("read_flow_tag"),
        RdmaCm.C_POINTER.withName("read_tm_info"),
        RdmaCm.C_POINTER.withName("read_completion_wallclock_ns")
    ).withName("ibv_cq_ex");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout context$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("context"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_context *context
     * }
     */
    public static final AddressLayout context$layout() {
        return context$LAYOUT;
    }

    private static final long context$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_context *context
     * }
     */
    public static final long context$offset() {
        return context$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_context *context
     * }
     */
    public static MemorySegment context(MemorySegment struct) {
        return struct.get(context$LAYOUT, context$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_context *context
     * }
     */
    public static void context(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(context$LAYOUT, context$OFFSET, fieldValue);
    }

    private static final AddressLayout channel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("channel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_comp_channel *channel
     * }
     */
    public static final AddressLayout channel$layout() {
        return channel$LAYOUT;
    }

    private static final long channel$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_comp_channel *channel
     * }
     */
    public static final long channel$offset() {
        return channel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_comp_channel *channel
     * }
     */
    public static MemorySegment channel(MemorySegment struct) {
        return struct.get(channel$LAYOUT, channel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_comp_channel *channel
     * }
     */
    public static void channel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(channel$LAYOUT, channel$OFFSET, fieldValue);
    }

    private static final AddressLayout cq_context$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cq_context"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *cq_context
     * }
     */
    public static final AddressLayout cq_context$layout() {
        return cq_context$LAYOUT;
    }

    private static final long cq_context$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *cq_context
     * }
     */
    public static final long cq_context$offset() {
        return cq_context$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *cq_context
     * }
     */
    public static MemorySegment cq_context(MemorySegment struct) {
        return struct.get(cq_context$LAYOUT, cq_context$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *cq_context
     * }
     */
    public static void cq_context(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cq_context$LAYOUT, cq_context$OFFSET, fieldValue);
    }

    private static final OfInt handle$LAYOUT = (OfInt)$LAYOUT.select(groupElement("handle"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t handle
     * }
     */
    public static final OfInt handle$layout() {
        return handle$LAYOUT;
    }

    private static final long handle$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t handle
     * }
     */
    public static final long handle$offset() {
        return handle$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t handle
     * }
     */
    public static int handle(MemorySegment struct) {
        return struct.get(handle$LAYOUT, handle$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t handle
     * }
     */
    public static void handle(MemorySegment struct, int fieldValue) {
        struct.set(handle$LAYOUT, handle$OFFSET, fieldValue);
    }

    private static final OfInt cqe$LAYOUT = (OfInt)$LAYOUT.select(groupElement("cqe"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int cqe
     * }
     */
    public static final OfInt cqe$layout() {
        return cqe$LAYOUT;
    }

    private static final long cqe$OFFSET = 28;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int cqe
     * }
     */
    public static final long cqe$offset() {
        return cqe$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int cqe
     * }
     */
    public static int cqe(MemorySegment struct) {
        return struct.get(cqe$LAYOUT, cqe$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int cqe
     * }
     */
    public static void cqe(MemorySegment struct, int fieldValue) {
        struct.set(cqe$LAYOUT, cqe$OFFSET, fieldValue);
    }

    private static final GroupLayout mutex$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("mutex"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * pthread_mutex_t mutex
     * }
     */
    public static final GroupLayout mutex$layout() {
        return mutex$LAYOUT;
    }

    private static final long mutex$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * pthread_mutex_t mutex
     * }
     */
    public static final long mutex$offset() {
        return mutex$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * pthread_mutex_t mutex
     * }
     */
    public static MemorySegment mutex(MemorySegment struct) {
        return struct.asSlice(mutex$OFFSET, mutex$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * pthread_mutex_t mutex
     * }
     */
    public static void mutex(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, mutex$OFFSET, mutex$LAYOUT.byteSize());
    }

    private static final GroupLayout cond$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("cond"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * pthread_cond_t cond
     * }
     */
    public static final GroupLayout cond$layout() {
        return cond$LAYOUT;
    }

    private static final long cond$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * pthread_cond_t cond
     * }
     */
    public static final long cond$offset() {
        return cond$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * pthread_cond_t cond
     * }
     */
    public static MemorySegment cond(MemorySegment struct) {
        return struct.asSlice(cond$OFFSET, cond$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * pthread_cond_t cond
     * }
     */
    public static void cond(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, cond$OFFSET, cond$LAYOUT.byteSize());
    }

    private static final OfInt comp_events_completed$LAYOUT = (OfInt)$LAYOUT.select(groupElement("comp_events_completed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t comp_events_completed
     * }
     */
    public static final OfInt comp_events_completed$layout() {
        return comp_events_completed$LAYOUT;
    }

    private static final long comp_events_completed$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t comp_events_completed
     * }
     */
    public static final long comp_events_completed$offset() {
        return comp_events_completed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t comp_events_completed
     * }
     */
    public static int comp_events_completed(MemorySegment struct) {
        return struct.get(comp_events_completed$LAYOUT, comp_events_completed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t comp_events_completed
     * }
     */
    public static void comp_events_completed(MemorySegment struct, int fieldValue) {
        struct.set(comp_events_completed$LAYOUT, comp_events_completed$OFFSET, fieldValue);
    }

    private static final OfInt async_events_completed$LAYOUT = (OfInt)$LAYOUT.select(groupElement("async_events_completed"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t async_events_completed
     * }
     */
    public static final OfInt async_events_completed$layout() {
        return async_events_completed$LAYOUT;
    }

    private static final long async_events_completed$OFFSET = 124;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t async_events_completed
     * }
     */
    public static final long async_events_completed$offset() {
        return async_events_completed$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t async_events_completed
     * }
     */
    public static int async_events_completed(MemorySegment struct) {
        return struct.get(async_events_completed$LAYOUT, async_events_completed$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t async_events_completed
     * }
     */
    public static void async_events_completed(MemorySegment struct, int fieldValue) {
        struct.set(async_events_completed$LAYOUT, async_events_completed$OFFSET, fieldValue);
    }

    private static final OfInt comp_mask$LAYOUT = (OfInt)$LAYOUT.select(groupElement("comp_mask"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t comp_mask
     * }
     */
    public static final OfInt comp_mask$layout() {
        return comp_mask$LAYOUT;
    }

    private static final long comp_mask$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t comp_mask
     * }
     */
    public static final long comp_mask$offset() {
        return comp_mask$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t comp_mask
     * }
     */
    public static int comp_mask(MemorySegment struct) {
        return struct.get(comp_mask$LAYOUT, comp_mask$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t comp_mask
     * }
     */
    public static void comp_mask(MemorySegment struct, int fieldValue) {
        struct.set(comp_mask$LAYOUT, comp_mask$OFFSET, fieldValue);
    }

    private static final OfInt status$LAYOUT = (OfInt)$LAYOUT.select(groupElement("status"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum ibv_wc_status status
     * }
     */
    public static final OfInt status$layout() {
        return status$LAYOUT;
    }

    private static final long status$OFFSET = 132;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum ibv_wc_status status
     * }
     */
    public static final long status$offset() {
        return status$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum ibv_wc_status status
     * }
     */
    public static int status(MemorySegment struct) {
        return struct.get(status$LAYOUT, status$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum ibv_wc_status status
     * }
     */
    public static void status(MemorySegment struct, int fieldValue) {
        struct.set(status$LAYOUT, status$OFFSET, fieldValue);
    }

    private static final OfLong wr_id$LAYOUT = (OfLong)$LAYOUT.select(groupElement("wr_id"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t wr_id
     * }
     */
    public static final OfLong wr_id$layout() {
        return wr_id$LAYOUT;
    }

    private static final long wr_id$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t wr_id
     * }
     */
    public static final long wr_id$offset() {
        return wr_id$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t wr_id
     * }
     */
    public static long wr_id(MemorySegment struct) {
        return struct.get(wr_id$LAYOUT, wr_id$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t wr_id
     * }
     */
    public static void wr_id(MemorySegment struct, long fieldValue) {
        struct.set(wr_id$LAYOUT, wr_id$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*start_poll)(struct ibv_cq_ex *, struct ibv_poll_cq_attr *)
     * }
     */
    public static class start_poll {

        start_poll() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(start_poll.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(start_poll.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout start_poll$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("start_poll"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*start_poll)(struct ibv_cq_ex *, struct ibv_poll_cq_attr *)
     * }
     */
    public static final AddressLayout start_poll$layout() {
        return start_poll$LAYOUT;
    }

    private static final long start_poll$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*start_poll)(struct ibv_cq_ex *, struct ibv_poll_cq_attr *)
     * }
     */
    public static final long start_poll$offset() {
        return start_poll$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*start_poll)(struct ibv_cq_ex *, struct ibv_poll_cq_attr *)
     * }
     */
    public static MemorySegment start_poll(MemorySegment struct) {
        return struct.get(start_poll$LAYOUT, start_poll$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*start_poll)(struct ibv_cq_ex *, struct ibv_poll_cq_attr *)
     * }
     */
    public static void start_poll(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(start_poll$LAYOUT, start_poll$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*next_poll)(struct ibv_cq_ex *)
     * }
     */
    public static class next_poll {

        next_poll() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(next_poll.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(next_poll.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout next_poll$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("next_poll"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*next_poll)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout next_poll$layout() {
        return next_poll$LAYOUT;
    }

    private static final long next_poll$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*next_poll)(struct ibv_cq_ex *)
     * }
     */
    public static final long next_poll$offset() {
        return next_poll$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*next_poll)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment next_poll(MemorySegment struct) {
        return struct.get(next_poll$LAYOUT, next_poll$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*next_poll)(struct ibv_cq_ex *)
     * }
     */
    public static void next_poll(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(next_poll$LAYOUT, next_poll$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*end_poll)(struct ibv_cq_ex *)
     * }
     */
    public static class end_poll {

        end_poll() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(end_poll.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(end_poll.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout end_poll$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("end_poll"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*end_poll)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout end_poll$layout() {
        return end_poll$LAYOUT;
    }

    private static final long end_poll$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*end_poll)(struct ibv_cq_ex *)
     * }
     */
    public static final long end_poll$offset() {
        return end_poll$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*end_poll)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment end_poll(MemorySegment struct) {
        return struct.get(end_poll$LAYOUT, end_poll$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*end_poll)(struct ibv_cq_ex *)
     * }
     */
    public static void end_poll(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(end_poll$LAYOUT, end_poll$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * enum ibv_wc_opcode (*read_opcode)(struct ibv_cq_ex *)
     * }
     */
    public static class read_opcode {

        read_opcode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(read_opcode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_opcode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_opcode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_opcode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum ibv_wc_opcode (*read_opcode)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout read_opcode$layout() {
        return read_opcode$LAYOUT;
    }

    private static final long read_opcode$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum ibv_wc_opcode (*read_opcode)(struct ibv_cq_ex *)
     * }
     */
    public static final long read_opcode$offset() {
        return read_opcode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum ibv_wc_opcode (*read_opcode)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment read_opcode(MemorySegment struct) {
        return struct.get(read_opcode$LAYOUT, read_opcode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum ibv_wc_opcode (*read_opcode)(struct ibv_cq_ex *)
     * }
     */
    public static void read_opcode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_opcode$LAYOUT, read_opcode$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint32_t (*read_vendor_err)(struct ibv_cq_ex *)
     * }
     */
    public static class read_vendor_err {

        read_vendor_err() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(read_vendor_err.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_vendor_err.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_vendor_err$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_vendor_err"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t (*read_vendor_err)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout read_vendor_err$layout() {
        return read_vendor_err$LAYOUT;
    }

    private static final long read_vendor_err$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t (*read_vendor_err)(struct ibv_cq_ex *)
     * }
     */
    public static final long read_vendor_err$offset() {
        return read_vendor_err$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t (*read_vendor_err)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment read_vendor_err(MemorySegment struct) {
        return struct.get(read_vendor_err$LAYOUT, read_vendor_err$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t (*read_vendor_err)(struct ibv_cq_ex *)
     * }
     */
    public static void read_vendor_err(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_vendor_err$LAYOUT, read_vendor_err$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint32_t (*read_byte_len)(struct ibv_cq_ex *)
     * }
     */
    public static class read_byte_len {

        read_byte_len() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(read_byte_len.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_byte_len.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_byte_len$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_byte_len"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t (*read_byte_len)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout read_byte_len$layout() {
        return read_byte_len$LAYOUT;
    }

    private static final long read_byte_len$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t (*read_byte_len)(struct ibv_cq_ex *)
     * }
     */
    public static final long read_byte_len$offset() {
        return read_byte_len$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t (*read_byte_len)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment read_byte_len(MemorySegment struct) {
        return struct.get(read_byte_len$LAYOUT, read_byte_len$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t (*read_byte_len)(struct ibv_cq_ex *)
     * }
     */
    public static void read_byte_len(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_byte_len$LAYOUT, read_byte_len$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * __be32 (*read_imm_data)(struct ibv_cq_ex *)
     * }
     */
    public static class read_imm_data {

        read_imm_data() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(read_imm_data.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_imm_data.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_imm_data$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_imm_data"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * __be32 (*read_imm_data)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout read_imm_data$layout() {
        return read_imm_data$LAYOUT;
    }

    private static final long read_imm_data$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * __be32 (*read_imm_data)(struct ibv_cq_ex *)
     * }
     */
    public static final long read_imm_data$offset() {
        return read_imm_data$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * __be32 (*read_imm_data)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment read_imm_data(MemorySegment struct) {
        return struct.get(read_imm_data$LAYOUT, read_imm_data$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * __be32 (*read_imm_data)(struct ibv_cq_ex *)
     * }
     */
    public static void read_imm_data(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_imm_data$LAYOUT, read_imm_data$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint32_t (*read_qp_num)(struct ibv_cq_ex *)
     * }
     */
    public static class read_qp_num {

        read_qp_num() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(read_qp_num.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_qp_num.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_qp_num$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_qp_num"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t (*read_qp_num)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout read_qp_num$layout() {
        return read_qp_num$LAYOUT;
    }

    private static final long read_qp_num$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t (*read_qp_num)(struct ibv_cq_ex *)
     * }
     */
    public static final long read_qp_num$offset() {
        return read_qp_num$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t (*read_qp_num)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment read_qp_num(MemorySegment struct) {
        return struct.get(read_qp_num$LAYOUT, read_qp_num$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t (*read_qp_num)(struct ibv_cq_ex *)
     * }
     */
    public static void read_qp_num(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_qp_num$LAYOUT, read_qp_num$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint32_t (*read_src_qp)(struct ibv_cq_ex *)
     * }
     */
    public static class read_src_qp {

        read_src_qp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(read_src_qp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_src_qp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_src_qp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_src_qp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t (*read_src_qp)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout read_src_qp$layout() {
        return read_src_qp$LAYOUT;
    }

    private static final long read_src_qp$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t (*read_src_qp)(struct ibv_cq_ex *)
     * }
     */
    public static final long read_src_qp$offset() {
        return read_src_qp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t (*read_src_qp)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment read_src_qp(MemorySegment struct) {
        return struct.get(read_src_qp$LAYOUT, read_src_qp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t (*read_src_qp)(struct ibv_cq_ex *)
     * }
     */
    public static void read_src_qp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_src_qp$LAYOUT, read_src_qp$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * unsigned int (*read_wc_flags)(struct ibv_cq_ex *)
     * }
     */
    public static class read_wc_flags {

        read_wc_flags() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(read_wc_flags.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_wc_flags.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_wc_flags$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_wc_flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int (*read_wc_flags)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout read_wc_flags$layout() {
        return read_wc_flags$LAYOUT;
    }

    private static final long read_wc_flags$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int (*read_wc_flags)(struct ibv_cq_ex *)
     * }
     */
    public static final long read_wc_flags$offset() {
        return read_wc_flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int (*read_wc_flags)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment read_wc_flags(MemorySegment struct) {
        return struct.get(read_wc_flags$LAYOUT, read_wc_flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int (*read_wc_flags)(struct ibv_cq_ex *)
     * }
     */
    public static void read_wc_flags(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_wc_flags$LAYOUT, read_wc_flags$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint32_t (*read_slid)(struct ibv_cq_ex *)
     * }
     */
    public static class read_slid {

        read_slid() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(read_slid.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_slid.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_slid$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_slid"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t (*read_slid)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout read_slid$layout() {
        return read_slid$LAYOUT;
    }

    private static final long read_slid$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t (*read_slid)(struct ibv_cq_ex *)
     * }
     */
    public static final long read_slid$offset() {
        return read_slid$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t (*read_slid)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment read_slid(MemorySegment struct) {
        return struct.get(read_slid$LAYOUT, read_slid$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t (*read_slid)(struct ibv_cq_ex *)
     * }
     */
    public static void read_slid(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_slid$LAYOUT, read_slid$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint8_t (*read_sl)(struct ibv_cq_ex *)
     * }
     */
    public static class read_sl {

        read_sl() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_CHAR,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(read_sl.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_sl.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_sl$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_sl"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t (*read_sl)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout read_sl$layout() {
        return read_sl$LAYOUT;
    }

    private static final long read_sl$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t (*read_sl)(struct ibv_cq_ex *)
     * }
     */
    public static final long read_sl$offset() {
        return read_sl$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t (*read_sl)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment read_sl(MemorySegment struct) {
        return struct.get(read_sl$LAYOUT, read_sl$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t (*read_sl)(struct ibv_cq_ex *)
     * }
     */
    public static void read_sl(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_sl$LAYOUT, read_sl$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint8_t (*read_dlid_path_bits)(struct ibv_cq_ex *)
     * }
     */
    public static class read_dlid_path_bits {

        read_dlid_path_bits() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            byte apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_CHAR,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(read_dlid_path_bits.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_dlid_path_bits.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static byte invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (byte) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_dlid_path_bits$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_dlid_path_bits"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t (*read_dlid_path_bits)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout read_dlid_path_bits$layout() {
        return read_dlid_path_bits$LAYOUT;
    }

    private static final long read_dlid_path_bits$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t (*read_dlid_path_bits)(struct ibv_cq_ex *)
     * }
     */
    public static final long read_dlid_path_bits$offset() {
        return read_dlid_path_bits$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t (*read_dlid_path_bits)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment read_dlid_path_bits(MemorySegment struct) {
        return struct.get(read_dlid_path_bits$LAYOUT, read_dlid_path_bits$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t (*read_dlid_path_bits)(struct ibv_cq_ex *)
     * }
     */
    public static void read_dlid_path_bits(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_dlid_path_bits$LAYOUT, read_dlid_path_bits$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint64_t (*read_completion_ts)(struct ibv_cq_ex *)
     * }
     */
    public static class read_completion_ts {

        read_completion_ts() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(read_completion_ts.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_completion_ts.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_completion_ts$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_completion_ts"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t (*read_completion_ts)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout read_completion_ts$layout() {
        return read_completion_ts$LAYOUT;
    }

    private static final long read_completion_ts$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t (*read_completion_ts)(struct ibv_cq_ex *)
     * }
     */
    public static final long read_completion_ts$offset() {
        return read_completion_ts$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t (*read_completion_ts)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment read_completion_ts(MemorySegment struct) {
        return struct.get(read_completion_ts$LAYOUT, read_completion_ts$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t (*read_completion_ts)(struct ibv_cq_ex *)
     * }
     */
    public static void read_completion_ts(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_completion_ts$LAYOUT, read_completion_ts$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint16_t (*read_cvlan)(struct ibv_cq_ex *)
     * }
     */
    public static class read_cvlan {

        read_cvlan() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            short apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_SHORT,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(read_cvlan.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_cvlan.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static short invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (short) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_cvlan$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_cvlan"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint16_t (*read_cvlan)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout read_cvlan$layout() {
        return read_cvlan$LAYOUT;
    }

    private static final long read_cvlan$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint16_t (*read_cvlan)(struct ibv_cq_ex *)
     * }
     */
    public static final long read_cvlan$offset() {
        return read_cvlan$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint16_t (*read_cvlan)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment read_cvlan(MemorySegment struct) {
        return struct.get(read_cvlan$LAYOUT, read_cvlan$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint16_t (*read_cvlan)(struct ibv_cq_ex *)
     * }
     */
    public static void read_cvlan(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_cvlan$LAYOUT, read_cvlan$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint32_t (*read_flow_tag)(struct ibv_cq_ex *)
     * }
     */
    public static class read_flow_tag {

        read_flow_tag() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(read_flow_tag.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_flow_tag.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_flow_tag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_flow_tag"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t (*read_flow_tag)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout read_flow_tag$layout() {
        return read_flow_tag$LAYOUT;
    }

    private static final long read_flow_tag$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t (*read_flow_tag)(struct ibv_cq_ex *)
     * }
     */
    public static final long read_flow_tag$offset() {
        return read_flow_tag$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t (*read_flow_tag)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment read_flow_tag(MemorySegment struct) {
        return struct.get(read_flow_tag$LAYOUT, read_flow_tag$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t (*read_flow_tag)(struct ibv_cq_ex *)
     * }
     */
    public static void read_flow_tag(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_flow_tag$LAYOUT, read_flow_tag$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*read_tm_info)(struct ibv_cq_ex *, struct ibv_wc_tm_info *)
     * }
     */
    public static class read_tm_info {

        read_tm_info() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(read_tm_info.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_tm_info.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_tm_info$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_tm_info"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*read_tm_info)(struct ibv_cq_ex *, struct ibv_wc_tm_info *)
     * }
     */
    public static final AddressLayout read_tm_info$layout() {
        return read_tm_info$LAYOUT;
    }

    private static final long read_tm_info$OFFSET = 272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*read_tm_info)(struct ibv_cq_ex *, struct ibv_wc_tm_info *)
     * }
     */
    public static final long read_tm_info$offset() {
        return read_tm_info$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*read_tm_info)(struct ibv_cq_ex *, struct ibv_wc_tm_info *)
     * }
     */
    public static MemorySegment read_tm_info(MemorySegment struct) {
        return struct.get(read_tm_info$LAYOUT, read_tm_info$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*read_tm_info)(struct ibv_cq_ex *, struct ibv_wc_tm_info *)
     * }
     */
    public static void read_tm_info(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_tm_info$LAYOUT, read_tm_info$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * uint64_t (*read_completion_wallclock_ns)(struct ibv_cq_ex *)
     * }
     */
    public static class read_completion_wallclock_ns {

        read_completion_wallclock_ns() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            long apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG,
            RdmaCm.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = RdmaCm.upcallHandle(read_completion_wallclock_ns.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_completion_wallclock_ns.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static long invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (long) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_completion_wallclock_ns$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_completion_wallclock_ns"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t (*read_completion_wallclock_ns)(struct ibv_cq_ex *)
     * }
     */
    public static final AddressLayout read_completion_wallclock_ns$layout() {
        return read_completion_wallclock_ns$LAYOUT;
    }

    private static final long read_completion_wallclock_ns$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t (*read_completion_wallclock_ns)(struct ibv_cq_ex *)
     * }
     */
    public static final long read_completion_wallclock_ns$offset() {
        return read_completion_wallclock_ns$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t (*read_completion_wallclock_ns)(struct ibv_cq_ex *)
     * }
     */
    public static MemorySegment read_completion_wallclock_ns(MemorySegment struct) {
        return struct.get(read_completion_wallclock_ns$LAYOUT, read_completion_wallclock_ns$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t (*read_completion_wallclock_ns)(struct ibv_cq_ex *)
     * }
     */
    public static void read_completion_wallclock_ns(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_completion_wallclock_ns$LAYOUT, read_completion_wallclock_ns$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

