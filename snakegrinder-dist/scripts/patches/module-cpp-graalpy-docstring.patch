--- a/torch/csrc/Module.cpp
+++ b/torch/csrc/Module.cpp
@@ -436,40 +436,14 @@
     doc_str = all_docs.back().c_str();
   }

-  if (Py_TYPE(obj) == &PyCFunction_Type) {
-    PyCFunctionObject* f = (PyCFunctionObject*)obj;
-    if (f->m_ml->ml_doc) {
-      return PyErr_Format(
-          PyExc_RuntimeError,
-          "function '%s' already has a docstring",
-          f->m_ml->ml_name);
-    }
-    f->m_ml->ml_doc = doc_str;
-  } else if (strcmp(Py_TYPE(obj)->tp_name, "method_descriptor") == 0) {
-    PyMethodDescrObject* m = (PyMethodDescrObject*)obj;
-    if (m->d_method->ml_doc) {
-      return PyErr_Format(
-          PyExc_RuntimeError,
-          "method '%s' already has a docstring",
-          m->d_method->ml_name);
-    }
-    m->d_method->ml_doc = doc_str;
-  } else if (strcmp(Py_TYPE(obj)->tp_name, "getset_descriptor") == 0) {
-    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-cstyle-cast)
-    PyGetSetDescrObject* m = (PyGetSetDescrObject*)obj;
-    if (m->d_getset->doc) {
-      return PyErr_Format(
-          PyExc_RuntimeError,
-          "attribute '%s' already has a docstring",
-          m->d_getset->name);
-    }
-    m->d_getset->doc = doc_str;
-  } else if (Py_TYPE(obj) == &PyType_Type) {
-    PyTypeObject* t = (PyTypeObject*)obj;
-    if (t->tp_doc) {
-      return PyErr_Format(
-          PyExc_RuntimeError, "Type '%s' already has a docstring", t->tp_name);
-    }
-    t->tp_doc = doc_str;
-  } else {
+  // GraalPy change - use generic PyObject_GetDoc/SetDoc API
+  if (PyObject_GetDoc(obj)) {
     return PyErr_Format(
-        PyExc_TypeError,
-        "don't know how to add docstring to type '%s'",
-        Py_TYPE(obj)->tp_name);
+        PyExc_RuntimeError,
+        "object '%100R' already has a docstring",
+        obj);
+  }
+  // GraalPy change
+  if (PyObject_SetDoc(obj, doc_str) < 0) {
+      return NULL;
   }

   Py_INCREF(obj);
