plugins { id 'application' }

group = 'io.surfworks.snakeburger'
version = '0.0.1-SNAPSHOT'

repositories { mavenCentral() }

dependencies {
    implementation project(':snakeburger-core')
    implementation project(':warpforge-license')
}

application {
    mainClass = 'io.surfworks.snakeburger.cli.SnakeBurgerMain'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(26)
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.compilerArgs.addAll(['--add-modules', 'jdk.incubator.code'])
}

tasks.withType(JavaExec).configureEach {
    jvmArgs += ['--add-modules', 'jdk.incubator.code']
}


// =============================================================================
// jlink: Create self-contained runtime image with Babylon JDK
// =============================================================================

def isMac = System.getProperty('os.name', '').toLowerCase().contains('mac')
def isLinux = System.getProperty('os.name', '').toLowerCase().contains('linux')

// Capture rootDir at configuration time for configuration cache compatibility
def projectRootDir = rootDir

// Find Babylon JDK home at configuration time
def babylonJdkHome = {
    File babylonRoot = new File(projectRootDir, '../babylon')
    File bDir = new File(babylonRoot, 'build')
    if (!bDir.exists()) return null

    if (isMac) {
        def javacFiles = fileTree(bDir) {
            include '**/Contents/Home/bin/javac'
        }.files
        if (!javacFiles.isEmpty()) {
            return javacFiles.iterator().next().parentFile.parentFile
        }
    }

    def javacFiles = fileTree(bDir) {
        include '**/jdk/bin/javac'
        include '**/images/**/bin/javac'
        exclude '**/support/**'
        exclude '**/interim-image/**'
        exclude '**/jre/**'
    }.files

    if (javacFiles.isEmpty()) return null

    def sorted = javacFiles.toList().sort { it.absolutePath }
    def pick = sorted.find { f ->
        def p = f.absolutePath
        (p.contains('/jdk/') || p.endsWith('/jdk/bin/javac')) && !p.contains('support') && !p.contains('interim')
    } ?: sorted[0]

    return pick.parentFile.parentFile
}.call()  // Execute immediately at configuration time

// jlink task to create self-contained runtime (JDK only, non-modular app)
tasks.register('jlinkRuntime', Exec) {
    group = 'distribution'
    description = 'Create a minimal JDK runtime with jdk.incubator.code using jlink'

    // Mark as not compatible with configuration cache (runs external jlink process)
    notCompatibleWithConfigurationCache("Runs external jlink process")

    def outputDir = file("${buildDir}/jlink-runtime")
    outputs.dir(outputDir)

    // Capture at configuration time
    def babylonHome = babylonJdkHome

    doFirst {
        if (babylonHome == null) {
            throw new GradleException(
                'Babylon JDK not found. Run: ./gradlew :babylon-runtime:ensureBabylonReady'
            )
        }

        def jlink = new File(babylonHome, 'bin/jlink')
        if (!jlink.exists()) {
            throw new GradleException("jlink not found at: ${jlink.absolutePath}")
        }

        // Clean output directory (use File.deleteDir() for config cache compatibility)
        if (outputDir.exists()) {
            outputDir.deleteDir()
        }

        // Modules to include - jdk.incubator.code plus standard modules needed
        def modules = [
            'jdk.incubator.code',  // Babylon code reflection
            'java.base',
            'java.logging',
        ].join(',')

        println "Babylon JDK: ${babylonHome}"
        println "Creating runtime with modules: ${modules}"
        println "Output: ${outputDir}"

        commandLine(
            jlink.absolutePath,
            '--module-path', "${babylonHome}/jmods",
            '--add-modules', modules,
            '--output', outputDir.absolutePath,
            '--strip-debug',
            '--compress', 'zip-6',
            '--no-header-files',
            '--no-man-pages'
        )
    }

    doLast {
        // Remove ct.sym (compiler symbols) - not needed at runtime, saves ~11MB
        def ctSym = new File(outputDir, 'lib/ct.sym')
        if (ctSym.exists()) {
            ctSym.delete()
            println "Removed ct.sym (not needed at runtime)"
        }
    }
}

// Assemble the full distribution: runtime + JARs + launcher
tasks.register('jlinkDist') {
    group = 'distribution'
    description = 'Create a self-contained distribution with jlink runtime and application JARs'

    // Mark as not compatible with configuration cache (uses file operations)
    notCompatibleWithConfigurationCache("Assembles distribution with file copies")

    dependsOn 'jlinkRuntime', 'jar', ':snakeburger-core:jar'

    def distDir = file("${buildDir}/snakeburger-dist")
    def runtimeSourceDir = file("${buildDir}/jlink-runtime")
    outputs.dir(distDir)

    // Capture values at configuration time for config cache compatibility
    def cliJarFile = tasks.jar.archiveFile
    def coreJarFile = project(':snakeburger-core').tasks.jar.archiveFile
    def mainClassName = application.mainClass

    doLast {
        // Clean and create dist directory (use File method, not Gradle's delete())
        if (distDir.exists()) {
            distDir.deleteDir()
        }
        distDir.mkdirs()

        // Copy jlink runtime preserving permissions
        def runtimeDestDir = new File(distDir, "runtime")
        ant.copy(todir: runtimeDestDir.absolutePath) {
            fileset(dir: runtimeSourceDir.absolutePath)
        }
        // Restore executable permissions on binaries (ant.copy doesn't preserve them)
        new File(runtimeDestDir, "bin").listFiles()?.each { it.setExecutable(true) }
        new File(runtimeDestDir, "lib/jspawnhelper").with { if (it.exists()) it.setExecutable(true) }

        // Copy application JARs
        def libDir = new File(distDir, "lib")
        libDir.mkdirs()
        ant.copy(todir: libDir.absolutePath) {
            fileset(file: cliJarFile.get().asFile.absolutePath)
            fileset(file: coreJarFile.get().asFile.absolutePath)
        }

        // Create launcher script (Unix)
        def launcherUnix = new File(distDir, "snakeburger")
        def mainClass = mainClassName.get()
        launcherUnix.text = """\
#!/bin/sh
SCRIPT_DIR="\$(cd "\$(dirname "\$0")" && pwd)"
exec "\$SCRIPT_DIR/runtime/bin/java" \\
    --add-modules jdk.incubator.code \\
    -cp "\$SCRIPT_DIR/lib/*" \\
    ${mainClass} "\$@"
""".stripIndent()
        launcherUnix.setExecutable(true)

        // Create launcher script (Windows)
        def launcherWin = new File(distDir, "snakeburger.bat")
        launcherWin.text = """\
@echo off
set SCRIPT_DIR=%~dp0
"%SCRIPT_DIR%runtime\\bin\\java" ^
    --add-modules jdk.incubator.code ^
    -cp "%SCRIPT_DIR%lib\\*" ^
    ${mainClass} %*
""".stripIndent()

        // Report sizes
        def runtimeSize = 0
        runtimeDestDir.eachFileRecurse { runtimeSize += it.size() }
        def libSize = 0
        libDir.eachFile { libSize += it.size() }

        println ""
        println "Distribution created: ${distDir}"
        println "  Runtime size: ${(runtimeSize / 1024 / 1024).round(1)} MB"
        println "  Lib size: ${(libSize / 1024).round(1)} KB"
        println "  Total: ${((runtimeSize + libSize) / 1024 / 1024).round(1)} MB"
        println ""
        println "To run: ${distDir}/snakeburger"
    }
}

// Create a distributable archive
tasks.register('jlinkZip', Zip) {
    group = 'distribution'
    description = 'Create a distributable zip with the jlink distribution'

    dependsOn 'jlinkDist'

    archiveBaseName = 'snakeburger'
    archiveClassifier = isLinux ? 'linux-x64' : (isMac ? 'macos' : 'unknown')

    from("${buildDir}/snakeburger-dist") {
        into 'snakeburger'
    }

    doLast {
        println "Created: ${archiveFile.get().asFile}"
    }
}

// Convenience task
tasks.register('packageSnakeBurger') {
    group = 'distribution'
    description = 'Build the complete SnakeBurger distribution'
    dependsOn 'jlinkDist'
}

// =============================================================================
// Platform-specific packaging via jpackage scripts
// =============================================================================

// macOS DMG installer
tasks.register('buildSnakeBurgerDmg', Exec) {
    group = 'distribution'
    description = 'Create macOS DMG installer (macOS only)'

    dependsOn 'jlinkDist'
    onlyIf { isMac }

    workingDir projectRootDir
    commandLine 'bash', 'tools/snakeburger-jpackage/build-snakeburger-cli-dmg.sh'

    doFirst {
        println "Building macOS DMG installer..."
    }

    doLast {
        println "DMG created in: ${buildDir}/"
    }
}

// macOS PKG installer
tasks.register('buildSnakeBurgerPkg', Exec) {
    group = 'distribution'
    description = 'Create macOS PKG installer (macOS only)'

    dependsOn 'jlinkDist'
    onlyIf { isMac }

    workingDir projectRootDir
    commandLine 'bash', 'tools/snakeburger-jpackage/build-snakeburger-cli-pkg.sh'

    doFirst {
        println "Building macOS PKG installer..."
    }

    doLast {
        println "PKG created in: ${buildDir}/"
    }
}

// Linux DEB package
tasks.register('buildSnakeBurgerDeb', Exec) {
    group = 'distribution'
    description = 'Create Linux DEB package (Linux only)'

    dependsOn 'jlinkDist'
    onlyIf { isLinux }

    workingDir projectRootDir
    commandLine 'bash', 'tools/snakeburger-jpackage/build-snakeburger-cli-deb.sh'

    doFirst {
        println "Building Linux DEB package..."
    }

    doLast {
        println "DEB package created in: ${buildDir}/"
    }
}

// Linux RPM package
tasks.register('buildSnakeBurgerRpm', Exec) {
    group = 'distribution'
    description = 'Create Linux RPM package (Linux only)'

    dependsOn 'jlinkDist'
    onlyIf { isLinux }

    workingDir projectRootDir
    commandLine 'bash', 'tools/snakeburger-jpackage/build-snakeburger-cli-rpm.sh'

    doFirst {
        println "Building Linux RPM package..."
    }

    doLast {
        println "RPM package created in: ${buildDir}/"
    }
}

// Linux AppImage
tasks.register('buildSnakeBurgerAppImage', Exec) {
    group = 'distribution'
    description = 'Create Linux AppImage (Linux only)'

    dependsOn 'jlinkDist'
    onlyIf { isLinux }

    workingDir projectRootDir
    commandLine 'bash', 'tools/snakeburger-jpackage/build-snakeburger-cli-linux-appimage.sh'

    doFirst {
        println "Building Linux AppImage..."
    }

    doLast {
        println "AppImage created in: ${buildDir}/"
    }
}

// Build all platform packages (for current platform)
tasks.register('buildSnakeBurgerAll') {
    group = 'distribution'
    description = 'Build all platform-specific installers for current platform'

    dependsOn 'jlinkDist'

    if (isMac) {
        dependsOn 'buildSnakeBurgerDmg', 'buildSnakeBurgerPkg'
    } else if (isLinux) {
        dependsOn 'buildSnakeBurgerDeb', 'buildSnakeBurgerRpm', 'buildSnakeBurgerAppImage'
    }
}
