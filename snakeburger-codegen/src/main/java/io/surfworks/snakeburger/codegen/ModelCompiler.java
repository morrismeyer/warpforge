package io.surfworks.snakeburger.codegen;

import io.surfworks.snakeburger.stablehlo.StableHloAst;
import io.surfworks.snakeburger.stablehlo.StableHloParser;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;

/**
 * CLI for compiling StableHLO MLIR to model JARs.
 *
 * <p>Usage:
 * <pre>
 * java --add-modules jdk.incubator.code io.surfworks.snakeburger.codegen.ModelCompiler \
 *     --input model.mlir \
 *     --output model.jar \
 *     [--class-name io.surfworks.warpforge.generated.Model] \
 *     [--function main]
 * </pre>
 */
public final class ModelCompiler {

    private static final String DEFAULT_CLASS_NAME = "io.surfworks.warpforge.generated.Model";

    public static void main(String[] args) {
        try {
            CompilerArgs parsedArgs = parseArgs(args);
            run(parsedArgs);
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            if (System.getenv("DEBUG") != null) {
                e.printStackTrace();
            }
            System.exit(1);
        }
    }

    /**
     * Run the compiler with parsed arguments.
     */
    public static void run(CompilerArgs args) throws CodegenException, IOException {
        // Read MLIR source
        String mlirSource = Files.readString(args.inputPath, StandardCharsets.UTF_8);

        // Parse MLIR to AST
        StableHloAst.Module module = StableHloParser.parse(mlirSource);

        // Find the function to compile
        StableHloAst.Function function = findFunction(module, args.functionName);

        System.out.println("Compiling function: " + function.name());
        System.out.println("  Arguments: " + function.arguments().size());
        System.out.println("  Operations: " + function.body().size());
        System.out.println("  Output class: " + args.className);

        // Generate the model class
        var generated = ModelClassGenerator.generate(args.className, function, mlirSource);

        System.out.println("  Generated bytecode: " + generated.bytecode().length + " bytes");

        // Build the JAR
        ModelJarBuilder.build(
            args.outputPath,
            generated.className(),
            generated.bytecode(),
            generated.metadata(),
            mlirSource
        );

        System.out.println("  Output JAR: " + args.outputPath);
        System.out.println("Compilation complete.");
    }

    /**
     * Compile MLIR source to a model JAR (programmatic API).
     *
     * @param mlirSource  The MLIR source code
     * @param outputPath  Path to write the JAR
     * @param className   Fully qualified class name for the generated model
     * @throws CodegenException if compilation fails
     */
    public static void compile(String mlirSource, Path outputPath, String className) throws CodegenException {
        StableHloAst.Module module = StableHloParser.parse(mlirSource);
        StableHloAst.Function function = findFunction(module, null);

        var generated = ModelClassGenerator.generate(className, function, mlirSource);

        ModelJarBuilder.build(
            outputPath,
            generated.className(),
            generated.bytecode(),
            generated.metadata(),
            mlirSource
        );
    }

    /**
     * Compile MLIR source to model bytecode (without JAR packaging).
     *
     * @param mlirSource  The MLIR source code
     * @param className   Fully qualified class name for the generated model
     * @return Generated class information
     * @throws CodegenException if compilation fails
     */
    public static ModelClassGenerator.GeneratedClass compileToBytes(
            String mlirSource,
            String className) throws CodegenException {

        StableHloAst.Module module = StableHloParser.parse(mlirSource);
        StableHloAst.Function function = findFunction(module, null);

        return ModelClassGenerator.generate(className, function, mlirSource);
    }

    private static StableHloAst.Function findFunction(StableHloAst.Module module, String functionName) {
        if (functionName != null && !functionName.isBlank()) {
            return module.getFunction(functionName)
                .orElseThrow(() -> new IllegalArgumentException(
                    "Function '" + functionName + "' not found in module"));
        }

        // Try public functions first
        var publicFunctions = module.functions().stream()
            .filter(StableHloAst.Function::isPublic)
            .toList();

        if (!publicFunctions.isEmpty()) {
            return publicFunctions.getFirst();
        }

        // Fall back to first function
        if (module.functions().isEmpty()) {
            throw new IllegalArgumentException("Module has no functions");
        }

        return module.functions().getFirst();
    }

    private static CompilerArgs parseArgs(String[] args) {
        Path inputPath = null;
        Path outputPath = null;
        String className = DEFAULT_CLASS_NAME;
        String functionName = null;

        for (int i = 0; i < args.length; i++) {
            switch (args[i]) {
                case "--input", "-i" -> {
                    if (++i >= args.length) throw new IllegalArgumentException("Missing value for --input");
                    inputPath = Path.of(args[i]);
                }
                case "--output", "-o" -> {
                    if (++i >= args.length) throw new IllegalArgumentException("Missing value for --output");
                    outputPath = Path.of(args[i]);
                }
                case "--class-name", "-c" -> {
                    if (++i >= args.length) throw new IllegalArgumentException("Missing value for --class-name");
                    className = args[i];
                }
                case "--function", "-f" -> {
                    if (++i >= args.length) throw new IllegalArgumentException("Missing value for --function");
                    functionName = args[i];
                }
                case "--help", "-h" -> {
                    printUsage();
                    System.exit(0);
                }
                default -> throw new IllegalArgumentException("Unknown argument: " + args[i]);
            }
        }

        if (inputPath == null) {
            throw new IllegalArgumentException("--input is required");
        }
        if (outputPath == null) {
            throw new IllegalArgumentException("--output is required");
        }

        return new CompilerArgs(inputPath, outputPath, className, functionName);
    }

    private static void printUsage() {
        System.out.println("WarpForge Model Compiler v" + ModelClassGenerator.GENERATOR_VERSION);
        System.out.println();
        System.out.println("Usage: ModelCompiler --input <mlir> --output <jar> [options]");
        System.out.println();
        System.out.println("Options:");
        System.out.println("  --input, -i <path>      Input MLIR file (required)");
        System.out.println("  --output, -o <path>     Output JAR file (required)");
        System.out.println("  --class-name, -c <name> Generated class name (default: " + DEFAULT_CLASS_NAME + ")");
        System.out.println("  --function, -f <name>   Function to compile (default: first public function)");
        System.out.println("  --help, -h              Show this help");
    }

    /**
     * Parsed compiler arguments.
     */
    public record CompilerArgs(
        Path inputPath,
        Path outputPath,
        String className,
        String functionName
    ) {}
}
