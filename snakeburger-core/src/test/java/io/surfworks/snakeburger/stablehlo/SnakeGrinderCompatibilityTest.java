package io.surfworks.snakeburger.stablehlo;

import io.surfworks.snakeburger.stablehlo.StableHloAst.AddOp;
import io.surfworks.snakeburger.stablehlo.StableHloAst.ConstantOp;
import io.surfworks.snakeburger.stablehlo.StableHloAst.DotGeneralOp;
import io.surfworks.snakeburger.stablehlo.StableHloAst.Function;
import io.surfworks.snakeburger.stablehlo.StableHloAst.MaximumOp;
import io.surfworks.snakeburger.stablehlo.StableHloAst.Module;

import org.junit.jupiter.api.Assumptions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

/**
 * Cross-project integration tests: Parse MLIR fixtures generated by snakegrinder.
 *
 * These tests verify that snakeburger's StableHloParser can successfully parse
 * the StableHLO MLIR output produced by snakegrinder's FX-to-StableHLO converter.
 *
 * This is the critical integration point between the two projects:
 * - snakegrinder: PyTorch → FX Graph → StableHLO MLIR (text)
 * - snakeburger: StableHLO MLIR (text) → AST → Babylon Code Reflection
 *
 * Prerequisites:
 * - Run: ./gradlew :snakegrinder-core:generateFixtures
 *
 * Run: ./gradlew :snakeburger-core:test --tests "SnakeGrinderCompatibilityTest"
 */
class SnakeGrinderCompatibilityTest {

    private static Path fixturesDir;
    private static List<Path> allFixtures;

    @BeforeAll
    static void setup() throws IOException {
        Path projectRoot = findProjectRoot();
        fixturesDir = projectRoot.resolve("snakegrinder-core/src/test/resources/fixtures/stablehlo");

        if (Files.exists(fixturesDir)) {
            allFixtures = Files.walk(fixturesDir)
                    .filter(p -> p.toString().endsWith(".mlir"))
                    .filter(p -> !p.toString().contains(".error"))
                    .sorted()
                    .toList();
        } else {
            allFixtures = List.of();
        }
    }

    private static Path findProjectRoot() {
        Path current = Paths.get("").toAbsolutePath();
        while (current != null) {
            if (Files.exists(current.resolve("settings.gradle"))) return current;
            current = current.getParent();
        }
        return Paths.get(System.getProperty("user.dir"));
    }

    static Stream<Path> fixtureFiles() {
        if (allFixtures == null || allFixtures.isEmpty()) {
            return Stream.empty();
        }
        return allFixtures.stream();
    }

    // ========================================================================
    // Fixture Availability Tests
    // ========================================================================

    @Test
    void snakegrinderFixturesExist() {
        assertTrue(Files.exists(fixturesDir),
                "Snakegrinder fixtures directory should exist at: " + fixturesDir +
                "\nRun: ./gradlew :snakegrinder-core:generateFixtures");
    }

    @Test
    void atLeastOneFixtureAvailable() {
        Assumptions.assumeTrue(Files.exists(fixturesDir),
                "Fixtures directory doesn't exist - run generateFixtures first");
        assertFalse(allFixtures.isEmpty(),
                "At least one MLIR fixture should exist");
    }

    // ========================================================================
    // Parse All Fixtures
    // ========================================================================

    @ParameterizedTest(name = "parse: {0}")
    @MethodSource("fixtureFiles")
    void canParseSnakegrinderFixture(Path fixture) throws IOException {
        Assumptions.assumeTrue(Files.exists(fixture));

        String mlir = Files.readString(fixture);
        String fixtureName = fixturesDir.relativize(fixture).toString();

        // Skip fixtures that contain "Unsupported function" markers
        // These are incomplete MLIR from unsupported PyTorch ops
        if (mlir.contains("// Unsupported function") || mlir.contains("// Unsupported")) {
            System.out.println("SKIP (unsupported ops): " + fixtureName);
            Assumptions.assumeTrue(false, "Fixture contains unsupported operations");
        }

        try {
            Module module = StableHloParser.parse(mlir);

            assertNotNull(module, "Parser should return a module for " + fixtureName);
            assertNotNull(module.name(), "Module should have a name");
            assertFalse(module.functions().isEmpty(),
                    "Module should have at least one function");

            System.out.println("OK: " + fixtureName +
                    " (module=" + module.name() +
                    ", functions=" + module.functions().size() + ")");

        } catch (Exception e) {
            fail("Failed to parse " + fixtureName + ": " + e.getMessage() +
                    "\n\nMLIR content:\n" + mlir);
        }
    }

    // ========================================================================
    // Detailed Parsing Tests for Working Fixtures
    // ========================================================================

    @Nested
    class ElementwiseFixturesParsing {

        @Test
        void parseAddFixture() throws IOException {
            Path fixture = fixturesDir.resolve("elementwise/add.mlir");
            Assumptions.assumeTrue(Files.exists(fixture));

            String mlir = Files.readString(fixture);
            Module module = StableHloParser.parse(mlir);

            assertEquals("main", module.name());
            assertEquals(1, module.functions().size());

            Function forward = module.functions().get(0);
            assertEquals("forward", forward.name());
            assertTrue(forward.isPublic());
            assertEquals(2, forward.arguments().size()); // x, y inputs

            // Should contain add operation
            boolean hasAdd = forward.body().stream()
                    .anyMatch(op -> op instanceof AddOp);
            assertTrue(hasAdd, "add.mlir should contain AddOp");
        }
    }

    @Nested
    class MatrixFixturesParsing {

        @Test
        void parseLinearFixture() throws IOException {
            Path fixture = fixturesDir.resolve("matrix/linear.mlir");
            Assumptions.assumeTrue(Files.exists(fixture));

            String mlir = Files.readString(fixture);
            Module module = StableHloParser.parse(mlir);

            assertEquals("main", module.name());

            Function forward = module.functions().get(0);
            assertEquals("forward", forward.name());
            assertEquals(1, forward.arguments().size()); // single input

            // Should contain dot_general (matmul) and add (bias)
            boolean hasDotGeneral = forward.body().stream()
                    .anyMatch(op -> op instanceof DotGeneralOp);
            assertTrue(hasDotGeneral, "linear.mlir should contain DotGeneralOp");

            boolean hasAdd = forward.body().stream()
                    .anyMatch(op -> op instanceof AddOp);
            assertTrue(hasAdd, "linear.mlir should contain AddOp for bias");

            // Should have constants for weights and bias
            long constantCount = forward.body().stream()
                    .filter(op -> op instanceof ConstantOp)
                    .count();
            assertTrue(constantCount >= 2,
                    "linear.mlir should have constants for weight and bias, found: " + constantCount);
        }

        @Test
        void parseMatmulFixture() throws IOException {
            Path fixture = fixturesDir.resolve("matrix/matmul.mlir");
            Assumptions.assumeTrue(Files.exists(fixture));

            String mlir = Files.readString(fixture);
            Module module = StableHloParser.parse(mlir);

            Function forward = module.functions().get(0);
            assertEquals(2, forward.arguments().size()); // two matrix inputs

            boolean hasDotGeneral = forward.body().stream()
                    .anyMatch(op -> op instanceof DotGeneralOp);
            assertTrue(hasDotGeneral, "matmul.mlir should contain DotGeneralOp");
        }
    }

    @Nested
    class ActivationFixturesParsing {

        @Test
        void parseReluFixture() throws IOException {
            Path fixture = fixturesDir.resolve("activation/relu.mlir");
            Assumptions.assumeTrue(Files.exists(fixture));

            String mlir = Files.readString(fixture);
            Module module = StableHloParser.parse(mlir);

            Function forward = module.functions().get(0);

            // ReLU is max(x, 0) - should have maximum op
            boolean hasMaximum = forward.body().stream()
                    .anyMatch(op -> op instanceof MaximumOp);
            assertTrue(hasMaximum, "relu.mlir should contain MaximumOp");

            // Should have zero constant
            boolean hasZeroConstant = forward.body().stream()
                    .filter(op -> op instanceof ConstantOp)
                    .anyMatch(op -> {
                        ConstantOp constOp = (ConstantOp) op;
                        return constOp.value().toString().contains("0.0") ||
                               constOp.value().toString().contains("0>");
                    });
            assertTrue(hasZeroConstant, "relu.mlir should have zero constant for max(x, 0)");
        }
    }

    @Nested
    class CompositeFixturesParsing {

        @Test
        void parseSimpleMlpFixture() throws IOException {
            Path fixture = fixturesDir.resolve("composite/simple_mlp.mlir");
            Assumptions.assumeTrue(Files.exists(fixture));

            String mlir = Files.readString(fixture);
            Module module = StableHloParser.parse(mlir);

            Function forward = module.functions().get(0);

            // MLP should have multiple operations
            assertTrue(forward.body().size() > 5,
                    "MLP should have multiple operations, found: " + forward.body().size());

            // Count operation types
            long dotGeneralCount = forward.body().stream()
                    .filter(op -> op instanceof DotGeneralOp).count();
            long addCount = forward.body().stream()
                    .filter(op -> op instanceof AddOp).count();
            long maximumCount = forward.body().stream()
                    .filter(op -> op instanceof MaximumOp).count();

            assertTrue(dotGeneralCount >= 2,
                    "MLP should have at least 2 dot_general ops (2 linear layers)");
            assertTrue(addCount >= 2,
                    "MLP should have at least 2 add ops (bias additions)");
            assertTrue(maximumCount >= 1,
                    "MLP should have at least 1 maximum op (ReLU)");

            System.out.println("SimpleMLP structure: " +
                    "dot_general=" + dotGeneralCount +
                    ", add=" + addCount +
                    ", maximum=" + maximumCount +
                    ", total_ops=" + forward.body().size());
        }

        @Test
        void parseResidualBlockFixture() throws IOException {
            Path fixture = fixturesDir.resolve("composite/residual_block.mlir");
            Assumptions.assumeTrue(Files.exists(fixture));

            String mlir = Files.readString(fixture);
            Module module = StableHloParser.parse(mlir);

            Function forward = module.functions().get(0);

            // Residual block: x + relu(fc2(relu(fc1(x))))
            // Should have add ops for both bias and residual connection
            long addCount = forward.body().stream()
                    .filter(op -> op instanceof AddOp).count();
            assertTrue(addCount >= 3,
                    "Residual block should have at least 3 add ops (2 bias + 1 residual)");
        }
    }

    // ========================================================================
    // Type Checking Integration
    // ========================================================================

    @ParameterizedTest(name = "typecheck: {0}")
    @MethodSource("fixtureFiles")
    void canTypeCheckSnakegrinderFixture(Path fixture) throws IOException {
        Assumptions.assumeTrue(Files.exists(fixture));

        String mlir = Files.readString(fixture);
        String fixtureName = fixturesDir.relativize(fixture).toString();

        // Skip fixtures with unsupported ops
        if (mlir.contains("// Unsupported")) {
            Assumptions.assumeTrue(false, "Fixture contains unsupported operations");
        }

        try {
            Module module = StableHloParser.parse(mlir);
            StableHloTypeChecker checker = new StableHloTypeChecker();
            var errors = checker.validate(module);
            if (errors.isEmpty()) {
                System.out.println("TYPECHECK OK: " + fixtureName);
            } else {
                System.out.println("TYPECHECK WARN: " + fixtureName + " - " + errors.size() + " errors");
            }
        } catch (Exception e) {
            // Type checking failures are informative but not critical at this stage
            System.out.println("TYPECHECK WARN: " + fixtureName + " - " + e.getMessage());
        }
    }

    // ========================================================================
    // Coverage Report
    // ========================================================================

    @Test
    void reportParsingCompatibility() throws IOException {
        Assumptions.assumeTrue(Files.exists(fixturesDir) && !allFixtures.isEmpty());

        int total = 0;
        int parsed = 0;
        int skipped = 0;
        int failed = 0;
        List<String> failures = new ArrayList<>();

        for (Path fixture : allFixtures) {
            total++;
            String mlir = Files.readString(fixture);
            String name = fixturesDir.relativize(fixture).toString();

            if (mlir.contains("// Unsupported")) {
                skipped++;
                continue;
            }

            try {
                Module module = StableHloParser.parse(mlir);
                if (module != null && !module.functions().isEmpty()) {
                    parsed++;
                } else {
                    failed++;
                    failures.add(name + " (empty result)");
                }
            } catch (Exception e) {
                failed++;
                failures.add(name + ": " + e.getMessage());
            }
        }

        System.out.println();
        System.out.println("=== SnakeGrinder → SnakeBurger Compatibility Report ===");
        System.out.println();
        System.out.println("Total fixtures:     " + total);
        System.out.println("Successfully parsed: " + parsed);
        System.out.println("Skipped (unsupported): " + skipped);
        System.out.println("Failed to parse:    " + failed);
        System.out.println();

        if (!failures.isEmpty()) {
            System.out.println("Failures:");
            failures.forEach(f -> System.out.println("  - " + f));
            System.out.println();
        }

        int parseRate = total > 0 ? (parsed * 100 / (total - skipped)) : 0;
        System.out.println("Parse success rate: " + parseRate + "% (of non-skipped fixtures)");
        System.out.println();

        // Don't fail the test - this is informational
        // The individual parameterized tests handle actual assertions
    }
}
