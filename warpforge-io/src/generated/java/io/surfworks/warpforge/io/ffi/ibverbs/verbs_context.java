// Generated by jextract

package io.surfworks.warpforge.io.ffi.ibverbs;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct verbs_context {
 *     int (*query_port)(struct ibv_context *, uint8_t, struct ibv_port_attr *, size_t);
 *     int (*advise_mr)(struct ibv_pd *, enum ib_uverbs_advise_mr_advice, uint32_t, struct ibv_sge *, uint32_t);
 *     struct ibv_mr *(*alloc_null_mr)(struct ibv_pd *);
 *     int (*read_counters)(struct ibv_counters *, uint64_t *, uint32_t, uint32_t);
 *     int (*attach_counters_point_flow)(struct ibv_counters *, struct ibv_counter_attach_attr *, struct ibv_flow *);
 *     struct ibv_counters *(*create_counters)(struct ibv_context *, struct ibv_counters_init_attr *);
 *     int (*destroy_counters)(struct ibv_counters *);
 *     struct ibv_mr *(*reg_dm_mr)(struct ibv_pd *, struct ibv_dm *, uint64_t, size_t, unsigned int);
 *     struct ibv_dm *(*alloc_dm)(struct ibv_context *, struct ibv_alloc_dm_attr *);
 *     int (*free_dm)(struct ibv_dm *);
 *     int (*modify_flow_action_esp)(struct ibv_flow_action *, struct ibv_flow_action_esp_attr *);
 *     int (*destroy_flow_action)(struct ibv_flow_action *);
 *     struct ibv_flow_action *(*create_flow_action_esp)(struct ibv_context *, struct ibv_flow_action_esp_attr *);
 *     int (*modify_qp_rate_limit)(struct ibv_qp *, struct ibv_qp_rate_limit_attr *);
 *     struct ibv_pd *(*alloc_parent_domain)(struct ibv_context *, struct ibv_parent_domain_init_attr *);
 *     int (*dealloc_td)(struct ibv_td *);
 *     struct ibv_td *(*alloc_td)(struct ibv_context *, struct ibv_td_init_attr *);
 *     int (*modify_cq)(struct ibv_cq *, struct ibv_modify_cq_attr *);
 *     int (*post_srq_ops)(struct ibv_srq *, struct ibv_ops_wr *, struct ibv_ops_wr **);
 *     int (*destroy_rwq_ind_table)(struct ibv_rwq_ind_table *);
 *     struct ibv_rwq_ind_table *(*create_rwq_ind_table)(struct ibv_context *, struct ibv_rwq_ind_table_init_attr *);
 *     int (*destroy_wq)(struct ibv_wq *);
 *     int (*modify_wq)(struct ibv_wq *, struct ibv_wq_attr *);
 *     struct ibv_wq *(*create_wq)(struct ibv_context *, struct ibv_wq_init_attr *);
 *     int (*query_rt_values)(struct ibv_context *, struct ibv_values_ex *);
 *     struct ibv_cq_ex *(*create_cq_ex)(struct ibv_context *, struct ibv_cq_init_attr_ex *);
 *     struct verbs_ex_private *priv;
 *     int (*query_device_ex)(struct ibv_context *, const struct ibv_query_device_ex_input *, struct ibv_device_attr_ex *, size_t);
 *     int (*ibv_destroy_flow)(struct ibv_flow *);
 *     void (*ABI_placeholder2)(void);
 *     struct ibv_flow *(*ibv_create_flow)(struct ibv_qp *, struct ibv_flow_attr *);
 *     void (*ABI_placeholder1)(void);
 *     struct ibv_qp *(*open_qp)(struct ibv_context *, struct ibv_qp_open_attr *);
 *     struct ibv_qp *(*create_qp_ex)(struct ibv_context *, struct ibv_qp_init_attr_ex *);
 *     int (*get_srq_num)(struct ibv_srq *, uint32_t *);
 *     struct ibv_srq *(*create_srq_ex)(struct ibv_context *, struct ibv_srq_init_attr_ex *);
 *     struct ibv_xrcd *(*open_xrcd)(struct ibv_context *, struct ibv_xrcd_init_attr *);
 *     int (*close_xrcd)(struct ibv_xrcd *);
 *     uint64_t _ABI_placeholder3;
 *     size_t sz;
 *     struct ibv_context context;
 * }
 * }
 */
public class verbs_context {

    verbs_context() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        Ibverbs.C_POINTER.withName("query_port"),
        Ibverbs.C_POINTER.withName("advise_mr"),
        Ibverbs.C_POINTER.withName("alloc_null_mr"),
        Ibverbs.C_POINTER.withName("read_counters"),
        Ibverbs.C_POINTER.withName("attach_counters_point_flow"),
        Ibverbs.C_POINTER.withName("create_counters"),
        Ibverbs.C_POINTER.withName("destroy_counters"),
        Ibverbs.C_POINTER.withName("reg_dm_mr"),
        Ibverbs.C_POINTER.withName("alloc_dm"),
        Ibverbs.C_POINTER.withName("free_dm"),
        Ibverbs.C_POINTER.withName("modify_flow_action_esp"),
        Ibverbs.C_POINTER.withName("destroy_flow_action"),
        Ibverbs.C_POINTER.withName("create_flow_action_esp"),
        Ibverbs.C_POINTER.withName("modify_qp_rate_limit"),
        Ibverbs.C_POINTER.withName("alloc_parent_domain"),
        Ibverbs.C_POINTER.withName("dealloc_td"),
        Ibverbs.C_POINTER.withName("alloc_td"),
        Ibverbs.C_POINTER.withName("modify_cq"),
        Ibverbs.C_POINTER.withName("post_srq_ops"),
        Ibverbs.C_POINTER.withName("destroy_rwq_ind_table"),
        Ibverbs.C_POINTER.withName("create_rwq_ind_table"),
        Ibverbs.C_POINTER.withName("destroy_wq"),
        Ibverbs.C_POINTER.withName("modify_wq"),
        Ibverbs.C_POINTER.withName("create_wq"),
        Ibverbs.C_POINTER.withName("query_rt_values"),
        Ibverbs.C_POINTER.withName("create_cq_ex"),
        Ibverbs.C_POINTER.withName("priv"),
        Ibverbs.C_POINTER.withName("query_device_ex"),
        Ibverbs.C_POINTER.withName("ibv_destroy_flow"),
        Ibverbs.C_POINTER.withName("ABI_placeholder2"),
        Ibverbs.C_POINTER.withName("ibv_create_flow"),
        Ibverbs.C_POINTER.withName("ABI_placeholder1"),
        Ibverbs.C_POINTER.withName("open_qp"),
        Ibverbs.C_POINTER.withName("create_qp_ex"),
        Ibverbs.C_POINTER.withName("get_srq_num"),
        Ibverbs.C_POINTER.withName("create_srq_ex"),
        Ibverbs.C_POINTER.withName("open_xrcd"),
        Ibverbs.C_POINTER.withName("close_xrcd"),
        Ibverbs.C_LONG.withName("_ABI_placeholder3"),
        Ibverbs.C_LONG.withName("sz"),
        ibv_context.layout().withName("context")
    ).withName("verbs_context");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * int (*query_port)(struct ibv_context *, uint8_t, struct ibv_port_attr *, size_t)
     * }
     */
    public static class query_port {

        query_port() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, byte _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_CHAR,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(query_port.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(query_port.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, byte _x1, MemorySegment _x2, long _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout query_port$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("query_port"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*query_port)(struct ibv_context *, uint8_t, struct ibv_port_attr *, size_t)
     * }
     */
    public static final AddressLayout query_port$layout() {
        return query_port$LAYOUT;
    }

    private static final long query_port$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*query_port)(struct ibv_context *, uint8_t, struct ibv_port_attr *, size_t)
     * }
     */
    public static final long query_port$offset() {
        return query_port$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*query_port)(struct ibv_context *, uint8_t, struct ibv_port_attr *, size_t)
     * }
     */
    public static MemorySegment query_port(MemorySegment struct) {
        return struct.get(query_port$LAYOUT, query_port$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*query_port)(struct ibv_context *, uint8_t, struct ibv_port_attr *, size_t)
     * }
     */
    public static void query_port(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(query_port$LAYOUT, query_port$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*advise_mr)(struct ibv_pd *, enum ib_uverbs_advise_mr_advice, uint32_t, struct ibv_sge *, uint32_t)
     * }
     */
    public static class advise_mr {

        advise_mr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, int _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT,
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(advise_mr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(advise_mr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3, int _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout advise_mr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("advise_mr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*advise_mr)(struct ibv_pd *, enum ib_uverbs_advise_mr_advice, uint32_t, struct ibv_sge *, uint32_t)
     * }
     */
    public static final AddressLayout advise_mr$layout() {
        return advise_mr$LAYOUT;
    }

    private static final long advise_mr$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*advise_mr)(struct ibv_pd *, enum ib_uverbs_advise_mr_advice, uint32_t, struct ibv_sge *, uint32_t)
     * }
     */
    public static final long advise_mr$offset() {
        return advise_mr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*advise_mr)(struct ibv_pd *, enum ib_uverbs_advise_mr_advice, uint32_t, struct ibv_sge *, uint32_t)
     * }
     */
    public static MemorySegment advise_mr(MemorySegment struct) {
        return struct.get(advise_mr$LAYOUT, advise_mr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*advise_mr)(struct ibv_pd *, enum ib_uverbs_advise_mr_advice, uint32_t, struct ibv_sge *, uint32_t)
     * }
     */
    public static void advise_mr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(advise_mr$LAYOUT, advise_mr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_mr *(*alloc_null_mr)(struct ibv_pd *)
     * }
     */
    public static class alloc_null_mr {

        alloc_null_mr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(alloc_null_mr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(alloc_null_mr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout alloc_null_mr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("alloc_null_mr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_mr *(*alloc_null_mr)(struct ibv_pd *)
     * }
     */
    public static final AddressLayout alloc_null_mr$layout() {
        return alloc_null_mr$LAYOUT;
    }

    private static final long alloc_null_mr$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_mr *(*alloc_null_mr)(struct ibv_pd *)
     * }
     */
    public static final long alloc_null_mr$offset() {
        return alloc_null_mr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_mr *(*alloc_null_mr)(struct ibv_pd *)
     * }
     */
    public static MemorySegment alloc_null_mr(MemorySegment struct) {
        return struct.get(alloc_null_mr$LAYOUT, alloc_null_mr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_mr *(*alloc_null_mr)(struct ibv_pd *)
     * }
     */
    public static void alloc_null_mr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(alloc_null_mr$LAYOUT, alloc_null_mr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*read_counters)(struct ibv_counters *, uint64_t *, uint32_t, uint32_t)
     * }
     */
    public static class read_counters {

        read_counters() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_INT,
            Ibverbs.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(read_counters.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(read_counters.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout read_counters$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("read_counters"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*read_counters)(struct ibv_counters *, uint64_t *, uint32_t, uint32_t)
     * }
     */
    public static final AddressLayout read_counters$layout() {
        return read_counters$LAYOUT;
    }

    private static final long read_counters$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*read_counters)(struct ibv_counters *, uint64_t *, uint32_t, uint32_t)
     * }
     */
    public static final long read_counters$offset() {
        return read_counters$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*read_counters)(struct ibv_counters *, uint64_t *, uint32_t, uint32_t)
     * }
     */
    public static MemorySegment read_counters(MemorySegment struct) {
        return struct.get(read_counters$LAYOUT, read_counters$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*read_counters)(struct ibv_counters *, uint64_t *, uint32_t, uint32_t)
     * }
     */
    public static void read_counters(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(read_counters$LAYOUT, read_counters$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*attach_counters_point_flow)(struct ibv_counters *, struct ibv_counter_attach_attr *, struct ibv_flow *)
     * }
     */
    public static class attach_counters_point_flow {

        attach_counters_point_flow() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(attach_counters_point_flow.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(attach_counters_point_flow.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout attach_counters_point_flow$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("attach_counters_point_flow"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*attach_counters_point_flow)(struct ibv_counters *, struct ibv_counter_attach_attr *, struct ibv_flow *)
     * }
     */
    public static final AddressLayout attach_counters_point_flow$layout() {
        return attach_counters_point_flow$LAYOUT;
    }

    private static final long attach_counters_point_flow$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*attach_counters_point_flow)(struct ibv_counters *, struct ibv_counter_attach_attr *, struct ibv_flow *)
     * }
     */
    public static final long attach_counters_point_flow$offset() {
        return attach_counters_point_flow$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*attach_counters_point_flow)(struct ibv_counters *, struct ibv_counter_attach_attr *, struct ibv_flow *)
     * }
     */
    public static MemorySegment attach_counters_point_flow(MemorySegment struct) {
        return struct.get(attach_counters_point_flow$LAYOUT, attach_counters_point_flow$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*attach_counters_point_flow)(struct ibv_counters *, struct ibv_counter_attach_attr *, struct ibv_flow *)
     * }
     */
    public static void attach_counters_point_flow(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(attach_counters_point_flow$LAYOUT, attach_counters_point_flow$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_counters *(*create_counters)(struct ibv_context *, struct ibv_counters_init_attr *)
     * }
     */
    public static class create_counters {

        create_counters() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(create_counters.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create_counters.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create_counters$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create_counters"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_counters *(*create_counters)(struct ibv_context *, struct ibv_counters_init_attr *)
     * }
     */
    public static final AddressLayout create_counters$layout() {
        return create_counters$LAYOUT;
    }

    private static final long create_counters$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_counters *(*create_counters)(struct ibv_context *, struct ibv_counters_init_attr *)
     * }
     */
    public static final long create_counters$offset() {
        return create_counters$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_counters *(*create_counters)(struct ibv_context *, struct ibv_counters_init_attr *)
     * }
     */
    public static MemorySegment create_counters(MemorySegment struct) {
        return struct.get(create_counters$LAYOUT, create_counters$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_counters *(*create_counters)(struct ibv_context *, struct ibv_counters_init_attr *)
     * }
     */
    public static void create_counters(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create_counters$LAYOUT, create_counters$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*destroy_counters)(struct ibv_counters *)
     * }
     */
    public static class destroy_counters {

        destroy_counters() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(destroy_counters.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(destroy_counters.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout destroy_counters$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("destroy_counters"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*destroy_counters)(struct ibv_counters *)
     * }
     */
    public static final AddressLayout destroy_counters$layout() {
        return destroy_counters$LAYOUT;
    }

    private static final long destroy_counters$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*destroy_counters)(struct ibv_counters *)
     * }
     */
    public static final long destroy_counters$offset() {
        return destroy_counters$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*destroy_counters)(struct ibv_counters *)
     * }
     */
    public static MemorySegment destroy_counters(MemorySegment struct) {
        return struct.get(destroy_counters$LAYOUT, destroy_counters$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*destroy_counters)(struct ibv_counters *)
     * }
     */
    public static void destroy_counters(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(destroy_counters$LAYOUT, destroy_counters$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_mr *(*reg_dm_mr)(struct ibv_pd *, struct ibv_dm *, uint64_t, size_t, unsigned int)
     * }
     */
    public static class reg_dm_mr {

        reg_dm_mr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, int _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG,
            Ibverbs.C_LONG,
            Ibverbs.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(reg_dm_mr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(reg_dm_mr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, int _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout reg_dm_mr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reg_dm_mr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_mr *(*reg_dm_mr)(struct ibv_pd *, struct ibv_dm *, uint64_t, size_t, unsigned int)
     * }
     */
    public static final AddressLayout reg_dm_mr$layout() {
        return reg_dm_mr$LAYOUT;
    }

    private static final long reg_dm_mr$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_mr *(*reg_dm_mr)(struct ibv_pd *, struct ibv_dm *, uint64_t, size_t, unsigned int)
     * }
     */
    public static final long reg_dm_mr$offset() {
        return reg_dm_mr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_mr *(*reg_dm_mr)(struct ibv_pd *, struct ibv_dm *, uint64_t, size_t, unsigned int)
     * }
     */
    public static MemorySegment reg_dm_mr(MemorySegment struct) {
        return struct.get(reg_dm_mr$LAYOUT, reg_dm_mr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_mr *(*reg_dm_mr)(struct ibv_pd *, struct ibv_dm *, uint64_t, size_t, unsigned int)
     * }
     */
    public static void reg_dm_mr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reg_dm_mr$LAYOUT, reg_dm_mr$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_dm *(*alloc_dm)(struct ibv_context *, struct ibv_alloc_dm_attr *)
     * }
     */
    public static class alloc_dm {

        alloc_dm() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(alloc_dm.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(alloc_dm.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout alloc_dm$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("alloc_dm"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_dm *(*alloc_dm)(struct ibv_context *, struct ibv_alloc_dm_attr *)
     * }
     */
    public static final AddressLayout alloc_dm$layout() {
        return alloc_dm$LAYOUT;
    }

    private static final long alloc_dm$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_dm *(*alloc_dm)(struct ibv_context *, struct ibv_alloc_dm_attr *)
     * }
     */
    public static final long alloc_dm$offset() {
        return alloc_dm$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_dm *(*alloc_dm)(struct ibv_context *, struct ibv_alloc_dm_attr *)
     * }
     */
    public static MemorySegment alloc_dm(MemorySegment struct) {
        return struct.get(alloc_dm$LAYOUT, alloc_dm$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_dm *(*alloc_dm)(struct ibv_context *, struct ibv_alloc_dm_attr *)
     * }
     */
    public static void alloc_dm(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(alloc_dm$LAYOUT, alloc_dm$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*free_dm)(struct ibv_dm *)
     * }
     */
    public static class free_dm {

        free_dm() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(free_dm.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(free_dm.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout free_dm$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("free_dm"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*free_dm)(struct ibv_dm *)
     * }
     */
    public static final AddressLayout free_dm$layout() {
        return free_dm$LAYOUT;
    }

    private static final long free_dm$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*free_dm)(struct ibv_dm *)
     * }
     */
    public static final long free_dm$offset() {
        return free_dm$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*free_dm)(struct ibv_dm *)
     * }
     */
    public static MemorySegment free_dm(MemorySegment struct) {
        return struct.get(free_dm$LAYOUT, free_dm$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*free_dm)(struct ibv_dm *)
     * }
     */
    public static void free_dm(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(free_dm$LAYOUT, free_dm$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*modify_flow_action_esp)(struct ibv_flow_action *, struct ibv_flow_action_esp_attr *)
     * }
     */
    public static class modify_flow_action_esp {

        modify_flow_action_esp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(modify_flow_action_esp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(modify_flow_action_esp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout modify_flow_action_esp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("modify_flow_action_esp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*modify_flow_action_esp)(struct ibv_flow_action *, struct ibv_flow_action_esp_attr *)
     * }
     */
    public static final AddressLayout modify_flow_action_esp$layout() {
        return modify_flow_action_esp$LAYOUT;
    }

    private static final long modify_flow_action_esp$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*modify_flow_action_esp)(struct ibv_flow_action *, struct ibv_flow_action_esp_attr *)
     * }
     */
    public static final long modify_flow_action_esp$offset() {
        return modify_flow_action_esp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*modify_flow_action_esp)(struct ibv_flow_action *, struct ibv_flow_action_esp_attr *)
     * }
     */
    public static MemorySegment modify_flow_action_esp(MemorySegment struct) {
        return struct.get(modify_flow_action_esp$LAYOUT, modify_flow_action_esp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*modify_flow_action_esp)(struct ibv_flow_action *, struct ibv_flow_action_esp_attr *)
     * }
     */
    public static void modify_flow_action_esp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(modify_flow_action_esp$LAYOUT, modify_flow_action_esp$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*destroy_flow_action)(struct ibv_flow_action *)
     * }
     */
    public static class destroy_flow_action {

        destroy_flow_action() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(destroy_flow_action.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(destroy_flow_action.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout destroy_flow_action$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("destroy_flow_action"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*destroy_flow_action)(struct ibv_flow_action *)
     * }
     */
    public static final AddressLayout destroy_flow_action$layout() {
        return destroy_flow_action$LAYOUT;
    }

    private static final long destroy_flow_action$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*destroy_flow_action)(struct ibv_flow_action *)
     * }
     */
    public static final long destroy_flow_action$offset() {
        return destroy_flow_action$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*destroy_flow_action)(struct ibv_flow_action *)
     * }
     */
    public static MemorySegment destroy_flow_action(MemorySegment struct) {
        return struct.get(destroy_flow_action$LAYOUT, destroy_flow_action$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*destroy_flow_action)(struct ibv_flow_action *)
     * }
     */
    public static void destroy_flow_action(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(destroy_flow_action$LAYOUT, destroy_flow_action$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_flow_action *(*create_flow_action_esp)(struct ibv_context *, struct ibv_flow_action_esp_attr *)
     * }
     */
    public static class create_flow_action_esp {

        create_flow_action_esp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(create_flow_action_esp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create_flow_action_esp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create_flow_action_esp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create_flow_action_esp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_flow_action *(*create_flow_action_esp)(struct ibv_context *, struct ibv_flow_action_esp_attr *)
     * }
     */
    public static final AddressLayout create_flow_action_esp$layout() {
        return create_flow_action_esp$LAYOUT;
    }

    private static final long create_flow_action_esp$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_flow_action *(*create_flow_action_esp)(struct ibv_context *, struct ibv_flow_action_esp_attr *)
     * }
     */
    public static final long create_flow_action_esp$offset() {
        return create_flow_action_esp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_flow_action *(*create_flow_action_esp)(struct ibv_context *, struct ibv_flow_action_esp_attr *)
     * }
     */
    public static MemorySegment create_flow_action_esp(MemorySegment struct) {
        return struct.get(create_flow_action_esp$LAYOUT, create_flow_action_esp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_flow_action *(*create_flow_action_esp)(struct ibv_context *, struct ibv_flow_action_esp_attr *)
     * }
     */
    public static void create_flow_action_esp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create_flow_action_esp$LAYOUT, create_flow_action_esp$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*modify_qp_rate_limit)(struct ibv_qp *, struct ibv_qp_rate_limit_attr *)
     * }
     */
    public static class modify_qp_rate_limit {

        modify_qp_rate_limit() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(modify_qp_rate_limit.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(modify_qp_rate_limit.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout modify_qp_rate_limit$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("modify_qp_rate_limit"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*modify_qp_rate_limit)(struct ibv_qp *, struct ibv_qp_rate_limit_attr *)
     * }
     */
    public static final AddressLayout modify_qp_rate_limit$layout() {
        return modify_qp_rate_limit$LAYOUT;
    }

    private static final long modify_qp_rate_limit$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*modify_qp_rate_limit)(struct ibv_qp *, struct ibv_qp_rate_limit_attr *)
     * }
     */
    public static final long modify_qp_rate_limit$offset() {
        return modify_qp_rate_limit$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*modify_qp_rate_limit)(struct ibv_qp *, struct ibv_qp_rate_limit_attr *)
     * }
     */
    public static MemorySegment modify_qp_rate_limit(MemorySegment struct) {
        return struct.get(modify_qp_rate_limit$LAYOUT, modify_qp_rate_limit$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*modify_qp_rate_limit)(struct ibv_qp *, struct ibv_qp_rate_limit_attr *)
     * }
     */
    public static void modify_qp_rate_limit(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(modify_qp_rate_limit$LAYOUT, modify_qp_rate_limit$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_pd *(*alloc_parent_domain)(struct ibv_context *, struct ibv_parent_domain_init_attr *)
     * }
     */
    public static class alloc_parent_domain {

        alloc_parent_domain() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(alloc_parent_domain.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(alloc_parent_domain.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout alloc_parent_domain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("alloc_parent_domain"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_pd *(*alloc_parent_domain)(struct ibv_context *, struct ibv_parent_domain_init_attr *)
     * }
     */
    public static final AddressLayout alloc_parent_domain$layout() {
        return alloc_parent_domain$LAYOUT;
    }

    private static final long alloc_parent_domain$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_pd *(*alloc_parent_domain)(struct ibv_context *, struct ibv_parent_domain_init_attr *)
     * }
     */
    public static final long alloc_parent_domain$offset() {
        return alloc_parent_domain$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_pd *(*alloc_parent_domain)(struct ibv_context *, struct ibv_parent_domain_init_attr *)
     * }
     */
    public static MemorySegment alloc_parent_domain(MemorySegment struct) {
        return struct.get(alloc_parent_domain$LAYOUT, alloc_parent_domain$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_pd *(*alloc_parent_domain)(struct ibv_context *, struct ibv_parent_domain_init_attr *)
     * }
     */
    public static void alloc_parent_domain(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(alloc_parent_domain$LAYOUT, alloc_parent_domain$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*dealloc_td)(struct ibv_td *)
     * }
     */
    public static class dealloc_td {

        dealloc_td() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(dealloc_td.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(dealloc_td.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout dealloc_td$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("dealloc_td"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*dealloc_td)(struct ibv_td *)
     * }
     */
    public static final AddressLayout dealloc_td$layout() {
        return dealloc_td$LAYOUT;
    }

    private static final long dealloc_td$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*dealloc_td)(struct ibv_td *)
     * }
     */
    public static final long dealloc_td$offset() {
        return dealloc_td$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*dealloc_td)(struct ibv_td *)
     * }
     */
    public static MemorySegment dealloc_td(MemorySegment struct) {
        return struct.get(dealloc_td$LAYOUT, dealloc_td$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*dealloc_td)(struct ibv_td *)
     * }
     */
    public static void dealloc_td(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(dealloc_td$LAYOUT, dealloc_td$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_td *(*alloc_td)(struct ibv_context *, struct ibv_td_init_attr *)
     * }
     */
    public static class alloc_td {

        alloc_td() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(alloc_td.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(alloc_td.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout alloc_td$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("alloc_td"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_td *(*alloc_td)(struct ibv_context *, struct ibv_td_init_attr *)
     * }
     */
    public static final AddressLayout alloc_td$layout() {
        return alloc_td$LAYOUT;
    }

    private static final long alloc_td$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_td *(*alloc_td)(struct ibv_context *, struct ibv_td_init_attr *)
     * }
     */
    public static final long alloc_td$offset() {
        return alloc_td$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_td *(*alloc_td)(struct ibv_context *, struct ibv_td_init_attr *)
     * }
     */
    public static MemorySegment alloc_td(MemorySegment struct) {
        return struct.get(alloc_td$LAYOUT, alloc_td$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_td *(*alloc_td)(struct ibv_context *, struct ibv_td_init_attr *)
     * }
     */
    public static void alloc_td(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(alloc_td$LAYOUT, alloc_td$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*modify_cq)(struct ibv_cq *, struct ibv_modify_cq_attr *)
     * }
     */
    public static class modify_cq {

        modify_cq() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(modify_cq.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(modify_cq.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout modify_cq$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("modify_cq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*modify_cq)(struct ibv_cq *, struct ibv_modify_cq_attr *)
     * }
     */
    public static final AddressLayout modify_cq$layout() {
        return modify_cq$LAYOUT;
    }

    private static final long modify_cq$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*modify_cq)(struct ibv_cq *, struct ibv_modify_cq_attr *)
     * }
     */
    public static final long modify_cq$offset() {
        return modify_cq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*modify_cq)(struct ibv_cq *, struct ibv_modify_cq_attr *)
     * }
     */
    public static MemorySegment modify_cq(MemorySegment struct) {
        return struct.get(modify_cq$LAYOUT, modify_cq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*modify_cq)(struct ibv_cq *, struct ibv_modify_cq_attr *)
     * }
     */
    public static void modify_cq(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(modify_cq$LAYOUT, modify_cq$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*post_srq_ops)(struct ibv_srq *, struct ibv_ops_wr *, struct ibv_ops_wr **)
     * }
     */
    public static class post_srq_ops {

        post_srq_ops() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(post_srq_ops.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(post_srq_ops.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout post_srq_ops$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("post_srq_ops"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*post_srq_ops)(struct ibv_srq *, struct ibv_ops_wr *, struct ibv_ops_wr **)
     * }
     */
    public static final AddressLayout post_srq_ops$layout() {
        return post_srq_ops$LAYOUT;
    }

    private static final long post_srq_ops$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*post_srq_ops)(struct ibv_srq *, struct ibv_ops_wr *, struct ibv_ops_wr **)
     * }
     */
    public static final long post_srq_ops$offset() {
        return post_srq_ops$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*post_srq_ops)(struct ibv_srq *, struct ibv_ops_wr *, struct ibv_ops_wr **)
     * }
     */
    public static MemorySegment post_srq_ops(MemorySegment struct) {
        return struct.get(post_srq_ops$LAYOUT, post_srq_ops$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*post_srq_ops)(struct ibv_srq *, struct ibv_ops_wr *, struct ibv_ops_wr **)
     * }
     */
    public static void post_srq_ops(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(post_srq_ops$LAYOUT, post_srq_ops$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*destroy_rwq_ind_table)(struct ibv_rwq_ind_table *)
     * }
     */
    public static class destroy_rwq_ind_table {

        destroy_rwq_ind_table() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(destroy_rwq_ind_table.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(destroy_rwq_ind_table.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout destroy_rwq_ind_table$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("destroy_rwq_ind_table"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*destroy_rwq_ind_table)(struct ibv_rwq_ind_table *)
     * }
     */
    public static final AddressLayout destroy_rwq_ind_table$layout() {
        return destroy_rwq_ind_table$LAYOUT;
    }

    private static final long destroy_rwq_ind_table$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*destroy_rwq_ind_table)(struct ibv_rwq_ind_table *)
     * }
     */
    public static final long destroy_rwq_ind_table$offset() {
        return destroy_rwq_ind_table$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*destroy_rwq_ind_table)(struct ibv_rwq_ind_table *)
     * }
     */
    public static MemorySegment destroy_rwq_ind_table(MemorySegment struct) {
        return struct.get(destroy_rwq_ind_table$LAYOUT, destroy_rwq_ind_table$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*destroy_rwq_ind_table)(struct ibv_rwq_ind_table *)
     * }
     */
    public static void destroy_rwq_ind_table(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(destroy_rwq_ind_table$LAYOUT, destroy_rwq_ind_table$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_rwq_ind_table *(*create_rwq_ind_table)(struct ibv_context *, struct ibv_rwq_ind_table_init_attr *)
     * }
     */
    public static class create_rwq_ind_table {

        create_rwq_ind_table() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(create_rwq_ind_table.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create_rwq_ind_table.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create_rwq_ind_table$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create_rwq_ind_table"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_rwq_ind_table *(*create_rwq_ind_table)(struct ibv_context *, struct ibv_rwq_ind_table_init_attr *)
     * }
     */
    public static final AddressLayout create_rwq_ind_table$layout() {
        return create_rwq_ind_table$LAYOUT;
    }

    private static final long create_rwq_ind_table$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_rwq_ind_table *(*create_rwq_ind_table)(struct ibv_context *, struct ibv_rwq_ind_table_init_attr *)
     * }
     */
    public static final long create_rwq_ind_table$offset() {
        return create_rwq_ind_table$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_rwq_ind_table *(*create_rwq_ind_table)(struct ibv_context *, struct ibv_rwq_ind_table_init_attr *)
     * }
     */
    public static MemorySegment create_rwq_ind_table(MemorySegment struct) {
        return struct.get(create_rwq_ind_table$LAYOUT, create_rwq_ind_table$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_rwq_ind_table *(*create_rwq_ind_table)(struct ibv_context *, struct ibv_rwq_ind_table_init_attr *)
     * }
     */
    public static void create_rwq_ind_table(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create_rwq_ind_table$LAYOUT, create_rwq_ind_table$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*destroy_wq)(struct ibv_wq *)
     * }
     */
    public static class destroy_wq {

        destroy_wq() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(destroy_wq.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(destroy_wq.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout destroy_wq$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("destroy_wq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*destroy_wq)(struct ibv_wq *)
     * }
     */
    public static final AddressLayout destroy_wq$layout() {
        return destroy_wq$LAYOUT;
    }

    private static final long destroy_wq$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*destroy_wq)(struct ibv_wq *)
     * }
     */
    public static final long destroy_wq$offset() {
        return destroy_wq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*destroy_wq)(struct ibv_wq *)
     * }
     */
    public static MemorySegment destroy_wq(MemorySegment struct) {
        return struct.get(destroy_wq$LAYOUT, destroy_wq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*destroy_wq)(struct ibv_wq *)
     * }
     */
    public static void destroy_wq(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(destroy_wq$LAYOUT, destroy_wq$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*modify_wq)(struct ibv_wq *, struct ibv_wq_attr *)
     * }
     */
    public static class modify_wq {

        modify_wq() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(modify_wq.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(modify_wq.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout modify_wq$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("modify_wq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*modify_wq)(struct ibv_wq *, struct ibv_wq_attr *)
     * }
     */
    public static final AddressLayout modify_wq$layout() {
        return modify_wq$LAYOUT;
    }

    private static final long modify_wq$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*modify_wq)(struct ibv_wq *, struct ibv_wq_attr *)
     * }
     */
    public static final long modify_wq$offset() {
        return modify_wq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*modify_wq)(struct ibv_wq *, struct ibv_wq_attr *)
     * }
     */
    public static MemorySegment modify_wq(MemorySegment struct) {
        return struct.get(modify_wq$LAYOUT, modify_wq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*modify_wq)(struct ibv_wq *, struct ibv_wq_attr *)
     * }
     */
    public static void modify_wq(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(modify_wq$LAYOUT, modify_wq$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_wq *(*create_wq)(struct ibv_context *, struct ibv_wq_init_attr *)
     * }
     */
    public static class create_wq {

        create_wq() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(create_wq.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create_wq.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create_wq$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create_wq"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_wq *(*create_wq)(struct ibv_context *, struct ibv_wq_init_attr *)
     * }
     */
    public static final AddressLayout create_wq$layout() {
        return create_wq$LAYOUT;
    }

    private static final long create_wq$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_wq *(*create_wq)(struct ibv_context *, struct ibv_wq_init_attr *)
     * }
     */
    public static final long create_wq$offset() {
        return create_wq$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_wq *(*create_wq)(struct ibv_context *, struct ibv_wq_init_attr *)
     * }
     */
    public static MemorySegment create_wq(MemorySegment struct) {
        return struct.get(create_wq$LAYOUT, create_wq$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_wq *(*create_wq)(struct ibv_context *, struct ibv_wq_init_attr *)
     * }
     */
    public static void create_wq(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create_wq$LAYOUT, create_wq$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*query_rt_values)(struct ibv_context *, struct ibv_values_ex *)
     * }
     */
    public static class query_rt_values {

        query_rt_values() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(query_rt_values.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(query_rt_values.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout query_rt_values$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("query_rt_values"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*query_rt_values)(struct ibv_context *, struct ibv_values_ex *)
     * }
     */
    public static final AddressLayout query_rt_values$layout() {
        return query_rt_values$LAYOUT;
    }

    private static final long query_rt_values$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*query_rt_values)(struct ibv_context *, struct ibv_values_ex *)
     * }
     */
    public static final long query_rt_values$offset() {
        return query_rt_values$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*query_rt_values)(struct ibv_context *, struct ibv_values_ex *)
     * }
     */
    public static MemorySegment query_rt_values(MemorySegment struct) {
        return struct.get(query_rt_values$LAYOUT, query_rt_values$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*query_rt_values)(struct ibv_context *, struct ibv_values_ex *)
     * }
     */
    public static void query_rt_values(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(query_rt_values$LAYOUT, query_rt_values$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_cq_ex *(*create_cq_ex)(struct ibv_context *, struct ibv_cq_init_attr_ex *)
     * }
     */
    public static class create_cq_ex {

        create_cq_ex() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(create_cq_ex.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create_cq_ex.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create_cq_ex$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create_cq_ex"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_cq_ex *(*create_cq_ex)(struct ibv_context *, struct ibv_cq_init_attr_ex *)
     * }
     */
    public static final AddressLayout create_cq_ex$layout() {
        return create_cq_ex$LAYOUT;
    }

    private static final long create_cq_ex$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_cq_ex *(*create_cq_ex)(struct ibv_context *, struct ibv_cq_init_attr_ex *)
     * }
     */
    public static final long create_cq_ex$offset() {
        return create_cq_ex$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_cq_ex *(*create_cq_ex)(struct ibv_context *, struct ibv_cq_init_attr_ex *)
     * }
     */
    public static MemorySegment create_cq_ex(MemorySegment struct) {
        return struct.get(create_cq_ex$LAYOUT, create_cq_ex$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_cq_ex *(*create_cq_ex)(struct ibv_context *, struct ibv_cq_init_attr_ex *)
     * }
     */
    public static void create_cq_ex(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create_cq_ex$LAYOUT, create_cq_ex$OFFSET, fieldValue);
    }

    private static final AddressLayout priv$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("priv"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct verbs_ex_private *priv
     * }
     */
    public static final AddressLayout priv$layout() {
        return priv$LAYOUT;
    }

    private static final long priv$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct verbs_ex_private *priv
     * }
     */
    public static final long priv$offset() {
        return priv$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct verbs_ex_private *priv
     * }
     */
    public static MemorySegment priv(MemorySegment struct) {
        return struct.get(priv$LAYOUT, priv$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct verbs_ex_private *priv
     * }
     */
    public static void priv(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(priv$LAYOUT, priv$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*query_device_ex)(struct ibv_context *, const struct ibv_query_device_ex_input *, struct ibv_device_attr_ex *, size_t)
     * }
     */
    public static class query_device_ex {

        query_device_ex() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_LONG
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(query_device_ex.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(query_device_ex.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout query_device_ex$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("query_device_ex"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*query_device_ex)(struct ibv_context *, const struct ibv_query_device_ex_input *, struct ibv_device_attr_ex *, size_t)
     * }
     */
    public static final AddressLayout query_device_ex$layout() {
        return query_device_ex$LAYOUT;
    }

    private static final long query_device_ex$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*query_device_ex)(struct ibv_context *, const struct ibv_query_device_ex_input *, struct ibv_device_attr_ex *, size_t)
     * }
     */
    public static final long query_device_ex$offset() {
        return query_device_ex$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*query_device_ex)(struct ibv_context *, const struct ibv_query_device_ex_input *, struct ibv_device_attr_ex *, size_t)
     * }
     */
    public static MemorySegment query_device_ex(MemorySegment struct) {
        return struct.get(query_device_ex$LAYOUT, query_device_ex$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*query_device_ex)(struct ibv_context *, const struct ibv_query_device_ex_input *, struct ibv_device_attr_ex *, size_t)
     * }
     */
    public static void query_device_ex(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(query_device_ex$LAYOUT, query_device_ex$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*ibv_destroy_flow)(struct ibv_flow *)
     * }
     */
    public static class ibv_destroy_flow {

        ibv_destroy_flow() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(ibv_destroy_flow.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ibv_destroy_flow.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ibv_destroy_flow$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ibv_destroy_flow"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*ibv_destroy_flow)(struct ibv_flow *)
     * }
     */
    public static final AddressLayout ibv_destroy_flow$layout() {
        return ibv_destroy_flow$LAYOUT;
    }

    private static final long ibv_destroy_flow$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*ibv_destroy_flow)(struct ibv_flow *)
     * }
     */
    public static final long ibv_destroy_flow$offset() {
        return ibv_destroy_flow$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*ibv_destroy_flow)(struct ibv_flow *)
     * }
     */
    public static MemorySegment ibv_destroy_flow(MemorySegment struct) {
        return struct.get(ibv_destroy_flow$LAYOUT, ibv_destroy_flow$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*ibv_destroy_flow)(struct ibv_flow *)
     * }
     */
    public static void ibv_destroy_flow(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ibv_destroy_flow$LAYOUT, ibv_destroy_flow$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ABI_placeholder2)(void)
     * }
     */
    public static class ABI_placeholder2 {

        ABI_placeholder2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid();

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(ABI_placeholder2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ABI_placeholder2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr) {
            try {
                 DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ABI_placeholder2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ABI_placeholder2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ABI_placeholder2)(void)
     * }
     */
    public static final AddressLayout ABI_placeholder2$layout() {
        return ABI_placeholder2$LAYOUT;
    }

    private static final long ABI_placeholder2$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ABI_placeholder2)(void)
     * }
     */
    public static final long ABI_placeholder2$offset() {
        return ABI_placeholder2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ABI_placeholder2)(void)
     * }
     */
    public static MemorySegment ABI_placeholder2(MemorySegment struct) {
        return struct.get(ABI_placeholder2$LAYOUT, ABI_placeholder2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ABI_placeholder2)(void)
     * }
     */
    public static void ABI_placeholder2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ABI_placeholder2$LAYOUT, ABI_placeholder2$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_flow *(*ibv_create_flow)(struct ibv_qp *, struct ibv_flow_attr *)
     * }
     */
    public static class ibv_create_flow {

        ibv_create_flow() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(ibv_create_flow.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ibv_create_flow.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ibv_create_flow$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ibv_create_flow"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_flow *(*ibv_create_flow)(struct ibv_qp *, struct ibv_flow_attr *)
     * }
     */
    public static final AddressLayout ibv_create_flow$layout() {
        return ibv_create_flow$LAYOUT;
    }

    private static final long ibv_create_flow$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_flow *(*ibv_create_flow)(struct ibv_qp *, struct ibv_flow_attr *)
     * }
     */
    public static final long ibv_create_flow$offset() {
        return ibv_create_flow$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_flow *(*ibv_create_flow)(struct ibv_qp *, struct ibv_flow_attr *)
     * }
     */
    public static MemorySegment ibv_create_flow(MemorySegment struct) {
        return struct.get(ibv_create_flow$LAYOUT, ibv_create_flow$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_flow *(*ibv_create_flow)(struct ibv_qp *, struct ibv_flow_attr *)
     * }
     */
    public static void ibv_create_flow(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ibv_create_flow$LAYOUT, ibv_create_flow$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*ABI_placeholder1)(void)
     * }
     */
    public static class ABI_placeholder1 {

        ABI_placeholder1() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid();

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(ABI_placeholder1.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ABI_placeholder1.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr) {
            try {
                 DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout ABI_placeholder1$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("ABI_placeholder1"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ABI_placeholder1)(void)
     * }
     */
    public static final AddressLayout ABI_placeholder1$layout() {
        return ABI_placeholder1$LAYOUT;
    }

    private static final long ABI_placeholder1$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ABI_placeholder1)(void)
     * }
     */
    public static final long ABI_placeholder1$offset() {
        return ABI_placeholder1$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ABI_placeholder1)(void)
     * }
     */
    public static MemorySegment ABI_placeholder1(MemorySegment struct) {
        return struct.get(ABI_placeholder1$LAYOUT, ABI_placeholder1$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ABI_placeholder1)(void)
     * }
     */
    public static void ABI_placeholder1(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ABI_placeholder1$LAYOUT, ABI_placeholder1$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_qp *(*open_qp)(struct ibv_context *, struct ibv_qp_open_attr *)
     * }
     */
    public static class open_qp {

        open_qp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(open_qp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(open_qp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout open_qp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("open_qp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_qp *(*open_qp)(struct ibv_context *, struct ibv_qp_open_attr *)
     * }
     */
    public static final AddressLayout open_qp$layout() {
        return open_qp$LAYOUT;
    }

    private static final long open_qp$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_qp *(*open_qp)(struct ibv_context *, struct ibv_qp_open_attr *)
     * }
     */
    public static final long open_qp$offset() {
        return open_qp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_qp *(*open_qp)(struct ibv_context *, struct ibv_qp_open_attr *)
     * }
     */
    public static MemorySegment open_qp(MemorySegment struct) {
        return struct.get(open_qp$LAYOUT, open_qp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_qp *(*open_qp)(struct ibv_context *, struct ibv_qp_open_attr *)
     * }
     */
    public static void open_qp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(open_qp$LAYOUT, open_qp$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_qp *(*create_qp_ex)(struct ibv_context *, struct ibv_qp_init_attr_ex *)
     * }
     */
    public static class create_qp_ex {

        create_qp_ex() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(create_qp_ex.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create_qp_ex.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create_qp_ex$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create_qp_ex"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_qp *(*create_qp_ex)(struct ibv_context *, struct ibv_qp_init_attr_ex *)
     * }
     */
    public static final AddressLayout create_qp_ex$layout() {
        return create_qp_ex$LAYOUT;
    }

    private static final long create_qp_ex$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_qp *(*create_qp_ex)(struct ibv_context *, struct ibv_qp_init_attr_ex *)
     * }
     */
    public static final long create_qp_ex$offset() {
        return create_qp_ex$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_qp *(*create_qp_ex)(struct ibv_context *, struct ibv_qp_init_attr_ex *)
     * }
     */
    public static MemorySegment create_qp_ex(MemorySegment struct) {
        return struct.get(create_qp_ex$LAYOUT, create_qp_ex$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_qp *(*create_qp_ex)(struct ibv_context *, struct ibv_qp_init_attr_ex *)
     * }
     */
    public static void create_qp_ex(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create_qp_ex$LAYOUT, create_qp_ex$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*get_srq_num)(struct ibv_srq *, uint32_t *)
     * }
     */
    public static class get_srq_num {

        get_srq_num() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(get_srq_num.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(get_srq_num.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout get_srq_num$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("get_srq_num"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*get_srq_num)(struct ibv_srq *, uint32_t *)
     * }
     */
    public static final AddressLayout get_srq_num$layout() {
        return get_srq_num$LAYOUT;
    }

    private static final long get_srq_num$OFFSET = 272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*get_srq_num)(struct ibv_srq *, uint32_t *)
     * }
     */
    public static final long get_srq_num$offset() {
        return get_srq_num$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*get_srq_num)(struct ibv_srq *, uint32_t *)
     * }
     */
    public static MemorySegment get_srq_num(MemorySegment struct) {
        return struct.get(get_srq_num$LAYOUT, get_srq_num$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*get_srq_num)(struct ibv_srq *, uint32_t *)
     * }
     */
    public static void get_srq_num(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(get_srq_num$LAYOUT, get_srq_num$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_srq *(*create_srq_ex)(struct ibv_context *, struct ibv_srq_init_attr_ex *)
     * }
     */
    public static class create_srq_ex {

        create_srq_ex() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(create_srq_ex.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(create_srq_ex.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout create_srq_ex$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("create_srq_ex"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_srq *(*create_srq_ex)(struct ibv_context *, struct ibv_srq_init_attr_ex *)
     * }
     */
    public static final AddressLayout create_srq_ex$layout() {
        return create_srq_ex$LAYOUT;
    }

    private static final long create_srq_ex$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_srq *(*create_srq_ex)(struct ibv_context *, struct ibv_srq_init_attr_ex *)
     * }
     */
    public static final long create_srq_ex$offset() {
        return create_srq_ex$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_srq *(*create_srq_ex)(struct ibv_context *, struct ibv_srq_init_attr_ex *)
     * }
     */
    public static MemorySegment create_srq_ex(MemorySegment struct) {
        return struct.get(create_srq_ex$LAYOUT, create_srq_ex$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_srq *(*create_srq_ex)(struct ibv_context *, struct ibv_srq_init_attr_ex *)
     * }
     */
    public static void create_srq_ex(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(create_srq_ex$LAYOUT, create_srq_ex$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct ibv_xrcd *(*open_xrcd)(struct ibv_context *, struct ibv_xrcd_init_attr *)
     * }
     */
    public static class open_xrcd {

        open_xrcd() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(open_xrcd.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(open_xrcd.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout open_xrcd$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("open_xrcd"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_xrcd *(*open_xrcd)(struct ibv_context *, struct ibv_xrcd_init_attr *)
     * }
     */
    public static final AddressLayout open_xrcd$layout() {
        return open_xrcd$LAYOUT;
    }

    private static final long open_xrcd$OFFSET = 288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_xrcd *(*open_xrcd)(struct ibv_context *, struct ibv_xrcd_init_attr *)
     * }
     */
    public static final long open_xrcd$offset() {
        return open_xrcd$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_xrcd *(*open_xrcd)(struct ibv_context *, struct ibv_xrcd_init_attr *)
     * }
     */
    public static MemorySegment open_xrcd(MemorySegment struct) {
        return struct.get(open_xrcd$LAYOUT, open_xrcd$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_xrcd *(*open_xrcd)(struct ibv_context *, struct ibv_xrcd_init_attr *)
     * }
     */
    public static void open_xrcd(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(open_xrcd$LAYOUT, open_xrcd$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*close_xrcd)(struct ibv_xrcd *)
     * }
     */
    public static class close_xrcd {

        close_xrcd() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Ibverbs.C_INT,
            Ibverbs.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Ibverbs.upcallHandle(close_xrcd.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(close_xrcd.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout close_xrcd$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("close_xrcd"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*close_xrcd)(struct ibv_xrcd *)
     * }
     */
    public static final AddressLayout close_xrcd$layout() {
        return close_xrcd$LAYOUT;
    }

    private static final long close_xrcd$OFFSET = 296;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*close_xrcd)(struct ibv_xrcd *)
     * }
     */
    public static final long close_xrcd$offset() {
        return close_xrcd$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*close_xrcd)(struct ibv_xrcd *)
     * }
     */
    public static MemorySegment close_xrcd(MemorySegment struct) {
        return struct.get(close_xrcd$LAYOUT, close_xrcd$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*close_xrcd)(struct ibv_xrcd *)
     * }
     */
    public static void close_xrcd(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(close_xrcd$LAYOUT, close_xrcd$OFFSET, fieldValue);
    }

    private static final OfLong _ABI_placeholder3$LAYOUT = (OfLong)$LAYOUT.select(groupElement("_ABI_placeholder3"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t _ABI_placeholder3
     * }
     */
    public static final OfLong _ABI_placeholder3$layout() {
        return _ABI_placeholder3$LAYOUT;
    }

    private static final long _ABI_placeholder3$OFFSET = 304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t _ABI_placeholder3
     * }
     */
    public static final long _ABI_placeholder3$offset() {
        return _ABI_placeholder3$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t _ABI_placeholder3
     * }
     */
    public static long _ABI_placeholder3(MemorySegment struct) {
        return struct.get(_ABI_placeholder3$LAYOUT, _ABI_placeholder3$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t _ABI_placeholder3
     * }
     */
    public static void _ABI_placeholder3(MemorySegment struct, long fieldValue) {
        struct.set(_ABI_placeholder3$LAYOUT, _ABI_placeholder3$OFFSET, fieldValue);
    }

    private static final OfLong sz$LAYOUT = (OfLong)$LAYOUT.select(groupElement("sz"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t sz
     * }
     */
    public static final OfLong sz$layout() {
        return sz$LAYOUT;
    }

    private static final long sz$OFFSET = 312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t sz
     * }
     */
    public static final long sz$offset() {
        return sz$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t sz
     * }
     */
    public static long sz(MemorySegment struct) {
        return struct.get(sz$LAYOUT, sz$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t sz
     * }
     */
    public static void sz(MemorySegment struct, long fieldValue) {
        struct.set(sz$LAYOUT, sz$OFFSET, fieldValue);
    }

    private static final GroupLayout context$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("context"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct ibv_context context
     * }
     */
    public static final GroupLayout context$layout() {
        return context$LAYOUT;
    }

    private static final long context$OFFSET = 320;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct ibv_context context
     * }
     */
    public static final long context$offset() {
        return context$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct ibv_context context
     * }
     */
    public static MemorySegment context(MemorySegment struct) {
        return struct.asSlice(context$OFFSET, context$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct ibv_context context
     * }
     */
    public static void context(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, context$OFFSET, context$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

