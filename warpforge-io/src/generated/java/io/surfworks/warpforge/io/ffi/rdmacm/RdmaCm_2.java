// Generated by jextract

package io.surfworks.warpforge.io.ffi.rdmacm;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class RdmaCm_2 {

    RdmaCm_2() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("rdmacm"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int _NETINET_IN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _NETINET_IN_H 1
     * }
     */
    public static int _NETINET_IN_H() {
        return _NETINET_IN_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)35L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 35
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int _BITS_STDINT_UINTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_UINTN_H 1
     * }
     */
    public static int _BITS_STDINT_UINTN_H() {
        return _BITS_STDINT_UINTN_H;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int _SYS_SOCKET_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SOCKET_H 1
     * }
     */
    public static int _SYS_SOCKET_H() {
        return _SYS_SOCKET_H;
    }
    private static final int __iovec_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __iovec_defined 1
     * }
     */
    public static int __iovec_defined() {
        return __iovec_defined;
    }
    private static final int _SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_TYPES_H 1
     * }
     */
    public static int _SYS_TYPES_H() {
        return _SYS_TYPES_H;
    }
    private static final int __clock_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clock_t_defined 1
     * }
     */
    public static int __clock_t_defined() {
        return __clock_t_defined;
    }
    private static final int __clockid_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clockid_t_defined 1
     * }
     */
    public static int __clockid_t_defined() {
        return __clockid_t_defined;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int __BIT_TYPES_DEFINED__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __BIT_TYPES_DEFINED__ 1
     * }
     */
    public static int __BIT_TYPES_DEFINED__() {
        return __BIT_TYPES_DEFINED__;
    }
    private static final int _ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ENDIAN_H 1
     * }
     */
    public static int _ENDIAN_H() {
        return _ENDIAN_H;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_BYTESWAP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_BYTESWAP_H 1
     * }
     */
    public static int _BITS_BYTESWAP_H() {
        return _BITS_BYTESWAP_H;
    }
    private static final int _BITS_UINTN_IDENTITY_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_UINTN_IDENTITY_H 1
     * }
     */
    public static int _BITS_UINTN_IDENTITY_H() {
        return _BITS_UINTN_IDENTITY_H;
    }
    private static final int _SYS_SELECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SELECT_H 1
     * }
     */
    public static int _SYS_SELECT_H() {
        return _SYS_SELECT_H;
    }
    private static final int __sigset_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __sigset_t_defined 1
     * }
     */
    public static int __sigset_t_defined() {
        return __sigset_t_defined;
    }
    private static final int __timeval_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timeval_defined 1
     * }
     */
    public static int __timeval_defined() {
        return __timeval_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_PTHREADTYPES_COMMON_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_COMMON_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return _BITS_PTHREADTYPES_COMMON_H;
    }
    private static final int _THREAD_SHARED_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_SHARED_TYPES_H 1
     * }
     */
    public static int _THREAD_SHARED_TYPES_H() {
        return _THREAD_SHARED_TYPES_H;
    }
    private static final int _BITS_PTHREADTYPES_ARCH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_ARCH_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return _BITS_PTHREADTYPES_ARCH_H;
    }
    private static final int __SIZEOF_PTHREAD_MUTEX_T = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEX_T 40
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return __SIZEOF_PTHREAD_MUTEX_T;
    }
    private static final int __SIZEOF_PTHREAD_ATTR_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_ATTR_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return __SIZEOF_PTHREAD_ATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCK_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCK_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return __SIZEOF_PTHREAD_RWLOCK_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIER_T = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIER_T 32
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return __SIZEOF_PTHREAD_BARRIER_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEXATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEXATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return __SIZEOF_PTHREAD_MUTEXATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_COND_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_COND_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_COND_T() {
        return __SIZEOF_PTHREAD_COND_T;
    }
    private static final int __SIZEOF_PTHREAD_CONDATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_CONDATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return __SIZEOF_PTHREAD_CONDATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCKATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return __SIZEOF_PTHREAD_RWLOCKATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIERATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIERATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return __SIZEOF_PTHREAD_BARRIERATTR_T;
    }
    private static final int _THREAD_MUTEX_INTERNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_MUTEX_INTERNAL_H 1
     * }
     */
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return _THREAD_MUTEX_INTERNAL_H;
    }
    private static final int __PTHREAD_MUTEX_HAVE_PREV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_HAVE_PREV 1
     * }
     */
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return __PTHREAD_MUTEX_HAVE_PREV;
    }
    private static final int __have_pthread_attr_t = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __have_pthread_attr_t 1
     * }
     */
    public static int __have_pthread_attr_t() {
        return __have_pthread_attr_t;
    }
    private static final int PF_UNSPEC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PF_UNSPEC 0
     * }
     */
    public static int PF_UNSPEC() {
        return PF_UNSPEC;
    }
    private static final int PF_LOCAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PF_LOCAL 1
     * }
     */
    public static int PF_LOCAL() {
        return PF_LOCAL;
    }
    private static final int PF_INET = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PF_INET 2
     * }
     */
    public static int PF_INET() {
        return PF_INET;
    }
    private static final int PF_AX25 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PF_AX25 3
     * }
     */
    public static int PF_AX25() {
        return PF_AX25;
    }
    private static final int PF_IPX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PF_IPX 4
     * }
     */
    public static int PF_IPX() {
        return PF_IPX;
    }
    private static final int PF_APPLETALK = (int)5L;
    /**
     * {@snippet lang=c :
     * #define PF_APPLETALK 5
     * }
     */
    public static int PF_APPLETALK() {
        return PF_APPLETALK;
    }
    private static final int PF_NETROM = (int)6L;
    /**
     * {@snippet lang=c :
     * #define PF_NETROM 6
     * }
     */
    public static int PF_NETROM() {
        return PF_NETROM;
    }
    private static final int PF_BRIDGE = (int)7L;
    /**
     * {@snippet lang=c :
     * #define PF_BRIDGE 7
     * }
     */
    public static int PF_BRIDGE() {
        return PF_BRIDGE;
    }
    private static final int PF_ATMPVC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PF_ATMPVC 8
     * }
     */
    public static int PF_ATMPVC() {
        return PF_ATMPVC;
    }
    private static final int PF_X25 = (int)9L;
    /**
     * {@snippet lang=c :
     * #define PF_X25 9
     * }
     */
    public static int PF_X25() {
        return PF_X25;
    }
    private static final int PF_INET6 = (int)10L;
    /**
     * {@snippet lang=c :
     * #define PF_INET6 10
     * }
     */
    public static int PF_INET6() {
        return PF_INET6;
    }
    private static final int PF_ROSE = (int)11L;
    /**
     * {@snippet lang=c :
     * #define PF_ROSE 11
     * }
     */
    public static int PF_ROSE() {
        return PF_ROSE;
    }
    private static final int PF_DECnet = (int)12L;
    /**
     * {@snippet lang=c :
     * #define PF_DECnet 12
     * }
     */
    public static int PF_DECnet() {
        return PF_DECnet;
    }
    private static final int PF_NETBEUI = (int)13L;
    /**
     * {@snippet lang=c :
     * #define PF_NETBEUI 13
     * }
     */
    public static int PF_NETBEUI() {
        return PF_NETBEUI;
    }
    private static final int PF_SECURITY = (int)14L;
    /**
     * {@snippet lang=c :
     * #define PF_SECURITY 14
     * }
     */
    public static int PF_SECURITY() {
        return PF_SECURITY;
    }
    private static final int PF_KEY = (int)15L;
    /**
     * {@snippet lang=c :
     * #define PF_KEY 15
     * }
     */
    public static int PF_KEY() {
        return PF_KEY;
    }
    private static final int PF_NETLINK = (int)16L;
    /**
     * {@snippet lang=c :
     * #define PF_NETLINK 16
     * }
     */
    public static int PF_NETLINK() {
        return PF_NETLINK;
    }
    private static final int PF_PACKET = (int)17L;
    /**
     * {@snippet lang=c :
     * #define PF_PACKET 17
     * }
     */
    public static int PF_PACKET() {
        return PF_PACKET;
    }
    private static final int PF_ASH = (int)18L;
    /**
     * {@snippet lang=c :
     * #define PF_ASH 18
     * }
     */
    public static int PF_ASH() {
        return PF_ASH;
    }
    private static final int PF_ECONET = (int)19L;
    /**
     * {@snippet lang=c :
     * #define PF_ECONET 19
     * }
     */
    public static int PF_ECONET() {
        return PF_ECONET;
    }
    private static final int PF_ATMSVC = (int)20L;
    /**
     * {@snippet lang=c :
     * #define PF_ATMSVC 20
     * }
     */
    public static int PF_ATMSVC() {
        return PF_ATMSVC;
    }
    private static final int PF_RDS = (int)21L;
    /**
     * {@snippet lang=c :
     * #define PF_RDS 21
     * }
     */
    public static int PF_RDS() {
        return PF_RDS;
    }
    private static final int PF_SNA = (int)22L;
    /**
     * {@snippet lang=c :
     * #define PF_SNA 22
     * }
     */
    public static int PF_SNA() {
        return PF_SNA;
    }
    private static final int PF_IRDA = (int)23L;
    /**
     * {@snippet lang=c :
     * #define PF_IRDA 23
     * }
     */
    public static int PF_IRDA() {
        return PF_IRDA;
    }
    private static final int PF_PPPOX = (int)24L;
    /**
     * {@snippet lang=c :
     * #define PF_PPPOX 24
     * }
     */
    public static int PF_PPPOX() {
        return PF_PPPOX;
    }
    private static final int PF_WANPIPE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define PF_WANPIPE 25
     * }
     */
    public static int PF_WANPIPE() {
        return PF_WANPIPE;
    }
    private static final int PF_LLC = (int)26L;
    /**
     * {@snippet lang=c :
     * #define PF_LLC 26
     * }
     */
    public static int PF_LLC() {
        return PF_LLC;
    }
    private static final int PF_IB = (int)27L;
    /**
     * {@snippet lang=c :
     * #define PF_IB 27
     * }
     */
    public static int PF_IB() {
        return PF_IB;
    }
    private static final int PF_MPLS = (int)28L;
    /**
     * {@snippet lang=c :
     * #define PF_MPLS 28
     * }
     */
    public static int PF_MPLS() {
        return PF_MPLS;
    }
    private static final int PF_CAN = (int)29L;
    /**
     * {@snippet lang=c :
     * #define PF_CAN 29
     * }
     */
    public static int PF_CAN() {
        return PF_CAN;
    }
    private static final int PF_TIPC = (int)30L;
    /**
     * {@snippet lang=c :
     * #define PF_TIPC 30
     * }
     */
    public static int PF_TIPC() {
        return PF_TIPC;
    }
    private static final int PF_BLUETOOTH = (int)31L;
    /**
     * {@snippet lang=c :
     * #define PF_BLUETOOTH 31
     * }
     */
    public static int PF_BLUETOOTH() {
        return PF_BLUETOOTH;
    }
    private static final int PF_IUCV = (int)32L;
    /**
     * {@snippet lang=c :
     * #define PF_IUCV 32
     * }
     */
    public static int PF_IUCV() {
        return PF_IUCV;
    }
    private static final int PF_RXRPC = (int)33L;
    /**
     * {@snippet lang=c :
     * #define PF_RXRPC 33
     * }
     */
    public static int PF_RXRPC() {
        return PF_RXRPC;
    }
    private static final int PF_ISDN = (int)34L;
    /**
     * {@snippet lang=c :
     * #define PF_ISDN 34
     * }
     */
    public static int PF_ISDN() {
        return PF_ISDN;
    }
    private static final int PF_PHONET = (int)35L;
    /**
     * {@snippet lang=c :
     * #define PF_PHONET 35
     * }
     */
    public static int PF_PHONET() {
        return PF_PHONET;
    }
    private static final int PF_IEEE802154 = (int)36L;
    /**
     * {@snippet lang=c :
     * #define PF_IEEE802154 36
     * }
     */
    public static int PF_IEEE802154() {
        return PF_IEEE802154;
    }
    private static final int PF_CAIF = (int)37L;
    /**
     * {@snippet lang=c :
     * #define PF_CAIF 37
     * }
     */
    public static int PF_CAIF() {
        return PF_CAIF;
    }
    private static final int PF_ALG = (int)38L;
    /**
     * {@snippet lang=c :
     * #define PF_ALG 38
     * }
     */
    public static int PF_ALG() {
        return PF_ALG;
    }
    private static final int PF_NFC = (int)39L;
    /**
     * {@snippet lang=c :
     * #define PF_NFC 39
     * }
     */
    public static int PF_NFC() {
        return PF_NFC;
    }
    private static final int PF_VSOCK = (int)40L;
    /**
     * {@snippet lang=c :
     * #define PF_VSOCK 40
     * }
     */
    public static int PF_VSOCK() {
        return PF_VSOCK;
    }
    private static final int PF_KCM = (int)41L;
    /**
     * {@snippet lang=c :
     * #define PF_KCM 41
     * }
     */
    public static int PF_KCM() {
        return PF_KCM;
    }
    private static final int PF_QIPCRTR = (int)42L;
    /**
     * {@snippet lang=c :
     * #define PF_QIPCRTR 42
     * }
     */
    public static int PF_QIPCRTR() {
        return PF_QIPCRTR;
    }
    private static final int PF_SMC = (int)43L;
    /**
     * {@snippet lang=c :
     * #define PF_SMC 43
     * }
     */
    public static int PF_SMC() {
        return PF_SMC;
    }
    private static final int PF_XDP = (int)44L;
    /**
     * {@snippet lang=c :
     * #define PF_XDP 44
     * }
     */
    public static int PF_XDP() {
        return PF_XDP;
    }
    private static final int PF_MCTP = (int)45L;
    /**
     * {@snippet lang=c :
     * #define PF_MCTP 45
     * }
     */
    public static int PF_MCTP() {
        return PF_MCTP;
    }
    private static final int PF_MAX = (int)46L;
    /**
     * {@snippet lang=c :
     * #define PF_MAX 46
     * }
     */
    public static int PF_MAX() {
        return PF_MAX;
    }
    private static final int SOL_RAW = (int)255L;
    /**
     * {@snippet lang=c :
     * #define SOL_RAW 255
     * }
     */
    public static int SOL_RAW() {
        return SOL_RAW;
    }
    private static final int SOL_DECNET = (int)261L;
    /**
     * {@snippet lang=c :
     * #define SOL_DECNET 261
     * }
     */
    public static int SOL_DECNET() {
        return SOL_DECNET;
    }
    private static final int SOL_X25 = (int)262L;
    /**
     * {@snippet lang=c :
     * #define SOL_X25 262
     * }
     */
    public static int SOL_X25() {
        return SOL_X25;
    }
    private static final int SOL_PACKET = (int)263L;
    /**
     * {@snippet lang=c :
     * #define SOL_PACKET 263
     * }
     */
    public static int SOL_PACKET() {
        return SOL_PACKET;
    }
    private static final int SOL_ATM = (int)264L;
    /**
     * {@snippet lang=c :
     * #define SOL_ATM 264
     * }
     */
    public static int SOL_ATM() {
        return SOL_ATM;
    }
    private static final int SOL_AAL = (int)265L;
    /**
     * {@snippet lang=c :
     * #define SOL_AAL 265
     * }
     */
    public static int SOL_AAL() {
        return SOL_AAL;
    }
    private static final int SOL_IRDA = (int)266L;
    /**
     * {@snippet lang=c :
     * #define SOL_IRDA 266
     * }
     */
    public static int SOL_IRDA() {
        return SOL_IRDA;
    }
    private static final int SOL_NETBEUI = (int)267L;
    /**
     * {@snippet lang=c :
     * #define SOL_NETBEUI 267
     * }
     */
    public static int SOL_NETBEUI() {
        return SOL_NETBEUI;
    }
    private static final int SOL_LLC = (int)268L;
    /**
     * {@snippet lang=c :
     * #define SOL_LLC 268
     * }
     */
    public static int SOL_LLC() {
        return SOL_LLC;
    }
    private static final int SOL_DCCP = (int)269L;
    /**
     * {@snippet lang=c :
     * #define SOL_DCCP 269
     * }
     */
    public static int SOL_DCCP() {
        return SOL_DCCP;
    }
    private static final int SOL_NETLINK = (int)270L;
    /**
     * {@snippet lang=c :
     * #define SOL_NETLINK 270
     * }
     */
    public static int SOL_NETLINK() {
        return SOL_NETLINK;
    }
    private static final int SOL_TIPC = (int)271L;
    /**
     * {@snippet lang=c :
     * #define SOL_TIPC 271
     * }
     */
    public static int SOL_TIPC() {
        return SOL_TIPC;
    }
    private static final int SOL_RXRPC = (int)272L;
    /**
     * {@snippet lang=c :
     * #define SOL_RXRPC 272
     * }
     */
    public static int SOL_RXRPC() {
        return SOL_RXRPC;
    }
    private static final int SOL_PPPOL2TP = (int)273L;
    /**
     * {@snippet lang=c :
     * #define SOL_PPPOL2TP 273
     * }
     */
    public static int SOL_PPPOL2TP() {
        return SOL_PPPOL2TP;
    }
    private static final int SOL_BLUETOOTH = (int)274L;
    /**
     * {@snippet lang=c :
     * #define SOL_BLUETOOTH 274
     * }
     */
    public static int SOL_BLUETOOTH() {
        return SOL_BLUETOOTH;
    }
    private static final int SOL_PNPIPE = (int)275L;
    /**
     * {@snippet lang=c :
     * #define SOL_PNPIPE 275
     * }
     */
    public static int SOL_PNPIPE() {
        return SOL_PNPIPE;
    }
    private static final int SOL_RDS = (int)276L;
    /**
     * {@snippet lang=c :
     * #define SOL_RDS 276
     * }
     */
    public static int SOL_RDS() {
        return SOL_RDS;
    }
    private static final int SOL_IUCV = (int)277L;
    /**
     * {@snippet lang=c :
     * #define SOL_IUCV 277
     * }
     */
    public static int SOL_IUCV() {
        return SOL_IUCV;
    }
    private static final int SOL_CAIF = (int)278L;
    /**
     * {@snippet lang=c :
     * #define SOL_CAIF 278
     * }
     */
    public static int SOL_CAIF() {
        return SOL_CAIF;
    }
    private static final int SOL_ALG = (int)279L;
    /**
     * {@snippet lang=c :
     * #define SOL_ALG 279
     * }
     */
    public static int SOL_ALG() {
        return SOL_ALG;
    }
    private static final int SOL_NFC = (int)280L;
    /**
     * {@snippet lang=c :
     * #define SOL_NFC 280
     * }
     */
    public static int SOL_NFC() {
        return SOL_NFC;
    }
    private static final int SOL_KCM = (int)281L;
    /**
     * {@snippet lang=c :
     * #define SOL_KCM 281
     * }
     */
    public static int SOL_KCM() {
        return SOL_KCM;
    }
    private static final int SOL_TLS = (int)282L;
    /**
     * {@snippet lang=c :
     * #define SOL_TLS 282
     * }
     */
    public static int SOL_TLS() {
        return SOL_TLS;
    }
    private static final int SOL_XDP = (int)283L;
    /**
     * {@snippet lang=c :
     * #define SOL_XDP 283
     * }
     */
    public static int SOL_XDP() {
        return SOL_XDP;
    }
    private static final int SOMAXCONN = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define SOMAXCONN 4096
     * }
     */
    public static int SOMAXCONN() {
        return SOMAXCONN;
    }
    private static final int _BITS_SOCKADDR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_SOCKADDR_H 1
     * }
     */
    public static int _BITS_SOCKADDR_H() {
        return _BITS_SOCKADDR_H;
    }
    private static final int _SS_SIZE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _SS_SIZE 128
     * }
     */
    public static int _SS_SIZE() {
        return _SS_SIZE;
    }
    private static final int __BITS_PER_LONG = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __BITS_PER_LONG 64
     * }
     */
    public static int __BITS_PER_LONG() {
        return __BITS_PER_LONG;
    }
    private static final int FIOSETOWN = (int)35073L;
    /**
     * {@snippet lang=c :
     * #define FIOSETOWN 35073
     * }
     */
    public static int FIOSETOWN() {
        return FIOSETOWN;
    }
    private static final int SIOCSPGRP = (int)35074L;
    /**
     * {@snippet lang=c :
     * #define SIOCSPGRP 35074
     * }
     */
    public static int SIOCSPGRP() {
        return SIOCSPGRP;
    }
    private static final int FIOGETOWN = (int)35075L;
    /**
     * {@snippet lang=c :
     * #define FIOGETOWN 35075
     * }
     */
    public static int FIOGETOWN() {
        return FIOGETOWN;
    }
    private static final int SIOCGPGRP = (int)35076L;
    /**
     * {@snippet lang=c :
     * #define SIOCGPGRP 35076
     * }
     */
    public static int SIOCGPGRP() {
        return SIOCGPGRP;
    }
    private static final int SIOCATMARK = (int)35077L;
    /**
     * {@snippet lang=c :
     * #define SIOCATMARK 35077
     * }
     */
    public static int SIOCATMARK() {
        return SIOCATMARK;
    }
    private static final int SIOCGSTAMP_OLD = (int)35078L;
    /**
     * {@snippet lang=c :
     * #define SIOCGSTAMP_OLD 35078
     * }
     */
    public static int SIOCGSTAMP_OLD() {
        return SIOCGSTAMP_OLD;
    }
    private static final int SIOCGSTAMPNS_OLD = (int)35079L;
    /**
     * {@snippet lang=c :
     * #define SIOCGSTAMPNS_OLD 35079
     * }
     */
    public static int SIOCGSTAMPNS_OLD() {
        return SIOCGSTAMPNS_OLD;
    }
    private static final int SOL_SOCKET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SOL_SOCKET 1
     * }
     */
    public static int SOL_SOCKET() {
        return SOL_SOCKET;
    }
    private static final int SO_DEBUG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SO_DEBUG 1
     * }
     */
    public static int SO_DEBUG() {
        return SO_DEBUG;
    }
    private static final int SO_REUSEADDR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SO_REUSEADDR 2
     * }
     */
    public static int SO_REUSEADDR() {
        return SO_REUSEADDR;
    }
    private static final int SO_TYPE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SO_TYPE 3
     * }
     */
    public static int SO_TYPE() {
        return SO_TYPE;
    }
    private static final int SO_ERROR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SO_ERROR 4
     * }
     */
    public static int SO_ERROR() {
        return SO_ERROR;
    }
    private static final int SO_DONTROUTE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SO_DONTROUTE 5
     * }
     */
    public static int SO_DONTROUTE() {
        return SO_DONTROUTE;
    }
    private static final int SO_BROADCAST = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SO_BROADCAST 6
     * }
     */
    public static int SO_BROADCAST() {
        return SO_BROADCAST;
    }
    private static final int SO_SNDBUF = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDBUF 7
     * }
     */
    public static int SO_SNDBUF() {
        return SO_SNDBUF;
    }
    private static final int SO_RCVBUF = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVBUF 8
     * }
     */
    public static int SO_RCVBUF() {
        return SO_RCVBUF;
    }
    private static final int SO_SNDBUFFORCE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDBUFFORCE 32
     * }
     */
    public static int SO_SNDBUFFORCE() {
        return SO_SNDBUFFORCE;
    }
    private static final int SO_RCVBUFFORCE = (int)33L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVBUFFORCE 33
     * }
     */
    public static int SO_RCVBUFFORCE() {
        return SO_RCVBUFFORCE;
    }
    private static final int SO_KEEPALIVE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define SO_KEEPALIVE 9
     * }
     */
    public static int SO_KEEPALIVE() {
        return SO_KEEPALIVE;
    }
    private static final int SO_OOBINLINE = (int)10L;
    /**
     * {@snippet lang=c :
     * #define SO_OOBINLINE 10
     * }
     */
    public static int SO_OOBINLINE() {
        return SO_OOBINLINE;
    }
    private static final int SO_NO_CHECK = (int)11L;
    /**
     * {@snippet lang=c :
     * #define SO_NO_CHECK 11
     * }
     */
    public static int SO_NO_CHECK() {
        return SO_NO_CHECK;
    }
    private static final int SO_PRIORITY = (int)12L;
    /**
     * {@snippet lang=c :
     * #define SO_PRIORITY 12
     * }
     */
    public static int SO_PRIORITY() {
        return SO_PRIORITY;
    }
    private static final int SO_LINGER = (int)13L;
    /**
     * {@snippet lang=c :
     * #define SO_LINGER 13
     * }
     */
    public static int SO_LINGER() {
        return SO_LINGER;
    }
    private static final int SO_BSDCOMPAT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define SO_BSDCOMPAT 14
     * }
     */
    public static int SO_BSDCOMPAT() {
        return SO_BSDCOMPAT;
    }
    private static final int SO_REUSEPORT = (int)15L;
    /**
     * {@snippet lang=c :
     * #define SO_REUSEPORT 15
     * }
     */
    public static int SO_REUSEPORT() {
        return SO_REUSEPORT;
    }
    private static final int SO_PASSCRED = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SO_PASSCRED 16
     * }
     */
    public static int SO_PASSCRED() {
        return SO_PASSCRED;
    }
    private static final int SO_PEERCRED = (int)17L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERCRED 17
     * }
     */
    public static int SO_PEERCRED() {
        return SO_PEERCRED;
    }
    private static final int SO_RCVLOWAT = (int)18L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVLOWAT 18
     * }
     */
    public static int SO_RCVLOWAT() {
        return SO_RCVLOWAT;
    }
    private static final int SO_SNDLOWAT = (int)19L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDLOWAT 19
     * }
     */
    public static int SO_SNDLOWAT() {
        return SO_SNDLOWAT;
    }
    private static final int SO_RCVTIMEO_OLD = (int)20L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVTIMEO_OLD 20
     * }
     */
    public static int SO_RCVTIMEO_OLD() {
        return SO_RCVTIMEO_OLD;
    }
    private static final int SO_SNDTIMEO_OLD = (int)21L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDTIMEO_OLD 21
     * }
     */
    public static int SO_SNDTIMEO_OLD() {
        return SO_SNDTIMEO_OLD;
    }
    private static final int SO_SECURITY_AUTHENTICATION = (int)22L;
    /**
     * {@snippet lang=c :
     * #define SO_SECURITY_AUTHENTICATION 22
     * }
     */
    public static int SO_SECURITY_AUTHENTICATION() {
        return SO_SECURITY_AUTHENTICATION;
    }
    private static final int SO_SECURITY_ENCRYPTION_TRANSPORT = (int)23L;
    /**
     * {@snippet lang=c :
     * #define SO_SECURITY_ENCRYPTION_TRANSPORT 23
     * }
     */
    public static int SO_SECURITY_ENCRYPTION_TRANSPORT() {
        return SO_SECURITY_ENCRYPTION_TRANSPORT;
    }
    private static final int SO_SECURITY_ENCRYPTION_NETWORK = (int)24L;
    /**
     * {@snippet lang=c :
     * #define SO_SECURITY_ENCRYPTION_NETWORK 24
     * }
     */
    public static int SO_SECURITY_ENCRYPTION_NETWORK() {
        return SO_SECURITY_ENCRYPTION_NETWORK;
    }
    private static final int SO_BINDTODEVICE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define SO_BINDTODEVICE 25
     * }
     */
    public static int SO_BINDTODEVICE() {
        return SO_BINDTODEVICE;
    }
    private static final int SO_ATTACH_FILTER = (int)26L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_FILTER 26
     * }
     */
    public static int SO_ATTACH_FILTER() {
        return SO_ATTACH_FILTER;
    }
    private static final int SO_DETACH_FILTER = (int)27L;
    /**
     * {@snippet lang=c :
     * #define SO_DETACH_FILTER 27
     * }
     */
    public static int SO_DETACH_FILTER() {
        return SO_DETACH_FILTER;
    }
    private static final int SO_PEERNAME = (int)28L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERNAME 28
     * }
     */
    public static int SO_PEERNAME() {
        return SO_PEERNAME;
    }
    private static final int SO_ACCEPTCONN = (int)30L;
    /**
     * {@snippet lang=c :
     * #define SO_ACCEPTCONN 30
     * }
     */
    public static int SO_ACCEPTCONN() {
        return SO_ACCEPTCONN;
    }
    private static final int SO_PEERSEC = (int)31L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERSEC 31
     * }
     */
    public static int SO_PEERSEC() {
        return SO_PEERSEC;
    }
    private static final int SO_PASSSEC = (int)34L;
    /**
     * {@snippet lang=c :
     * #define SO_PASSSEC 34
     * }
     */
    public static int SO_PASSSEC() {
        return SO_PASSSEC;
    }
    private static final int SO_MARK = (int)36L;
    /**
     * {@snippet lang=c :
     * #define SO_MARK 36
     * }
     */
    public static int SO_MARK() {
        return SO_MARK;
    }
    private static final int SO_PROTOCOL = (int)38L;
    /**
     * {@snippet lang=c :
     * #define SO_PROTOCOL 38
     * }
     */
    public static int SO_PROTOCOL() {
        return SO_PROTOCOL;
    }
    private static final int SO_DOMAIN = (int)39L;
    /**
     * {@snippet lang=c :
     * #define SO_DOMAIN 39
     * }
     */
    public static int SO_DOMAIN() {
        return SO_DOMAIN;
    }
    private static final int SO_RXQ_OVFL = (int)40L;
    /**
     * {@snippet lang=c :
     * #define SO_RXQ_OVFL 40
     * }
     */
    public static int SO_RXQ_OVFL() {
        return SO_RXQ_OVFL;
    }
    private static final int SO_WIFI_STATUS = (int)41L;
    /**
     * {@snippet lang=c :
     * #define SO_WIFI_STATUS 41
     * }
     */
    public static int SO_WIFI_STATUS() {
        return SO_WIFI_STATUS;
    }
    private static final int SO_PEEK_OFF = (int)42L;
    /**
     * {@snippet lang=c :
     * #define SO_PEEK_OFF 42
     * }
     */
    public static int SO_PEEK_OFF() {
        return SO_PEEK_OFF;
    }
    private static final int SO_NOFCS = (int)43L;
    /**
     * {@snippet lang=c :
     * #define SO_NOFCS 43
     * }
     */
    public static int SO_NOFCS() {
        return SO_NOFCS;
    }
    private static final int SO_LOCK_FILTER = (int)44L;
    /**
     * {@snippet lang=c :
     * #define SO_LOCK_FILTER 44
     * }
     */
    public static int SO_LOCK_FILTER() {
        return SO_LOCK_FILTER;
    }
    private static final int SO_SELECT_ERR_QUEUE = (int)45L;
    /**
     * {@snippet lang=c :
     * #define SO_SELECT_ERR_QUEUE 45
     * }
     */
    public static int SO_SELECT_ERR_QUEUE() {
        return SO_SELECT_ERR_QUEUE;
    }
    private static final int SO_BUSY_POLL = (int)46L;
    /**
     * {@snippet lang=c :
     * #define SO_BUSY_POLL 46
     * }
     */
    public static int SO_BUSY_POLL() {
        return SO_BUSY_POLL;
    }
    private static final int SO_MAX_PACING_RATE = (int)47L;
    /**
     * {@snippet lang=c :
     * #define SO_MAX_PACING_RATE 47
     * }
     */
    public static int SO_MAX_PACING_RATE() {
        return SO_MAX_PACING_RATE;
    }
    private static final int SO_BPF_EXTENSIONS = (int)48L;
    /**
     * {@snippet lang=c :
     * #define SO_BPF_EXTENSIONS 48
     * }
     */
    public static int SO_BPF_EXTENSIONS() {
        return SO_BPF_EXTENSIONS;
    }
    private static final int SO_INCOMING_CPU = (int)49L;
    /**
     * {@snippet lang=c :
     * #define SO_INCOMING_CPU 49
     * }
     */
    public static int SO_INCOMING_CPU() {
        return SO_INCOMING_CPU;
    }
    private static final int SO_ATTACH_BPF = (int)50L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_BPF 50
     * }
     */
    public static int SO_ATTACH_BPF() {
        return SO_ATTACH_BPF;
    }
    private static final int SO_ATTACH_REUSEPORT_CBPF = (int)51L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_REUSEPORT_CBPF 51
     * }
     */
    public static int SO_ATTACH_REUSEPORT_CBPF() {
        return SO_ATTACH_REUSEPORT_CBPF;
    }
    private static final int SO_ATTACH_REUSEPORT_EBPF = (int)52L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_REUSEPORT_EBPF 52
     * }
     */
    public static int SO_ATTACH_REUSEPORT_EBPF() {
        return SO_ATTACH_REUSEPORT_EBPF;
    }
    private static final int SO_CNX_ADVICE = (int)53L;
    /**
     * {@snippet lang=c :
     * #define SO_CNX_ADVICE 53
     * }
     */
    public static int SO_CNX_ADVICE() {
        return SO_CNX_ADVICE;
    }
    private static final int SCM_TIMESTAMPING_OPT_STATS = (int)54L;
    /**
     * {@snippet lang=c :
     * #define SCM_TIMESTAMPING_OPT_STATS 54
     * }
     */
    public static int SCM_TIMESTAMPING_OPT_STATS() {
        return SCM_TIMESTAMPING_OPT_STATS;
    }
    private static final int SO_MEMINFO = (int)55L;
    /**
     * {@snippet lang=c :
     * #define SO_MEMINFO 55
     * }
     */
    public static int SO_MEMINFO() {
        return SO_MEMINFO;
    }
    private static final int SO_INCOMING_NAPI_ID = (int)56L;
    /**
     * {@snippet lang=c :
     * #define SO_INCOMING_NAPI_ID 56
     * }
     */
    public static int SO_INCOMING_NAPI_ID() {
        return SO_INCOMING_NAPI_ID;
    }
    private static final int SO_COOKIE = (int)57L;
    /**
     * {@snippet lang=c :
     * #define SO_COOKIE 57
     * }
     */
    public static int SO_COOKIE() {
        return SO_COOKIE;
    }
    private static final int SCM_TIMESTAMPING_PKTINFO = (int)58L;
    /**
     * {@snippet lang=c :
     * #define SCM_TIMESTAMPING_PKTINFO 58
     * }
     */
    public static int SCM_TIMESTAMPING_PKTINFO() {
        return SCM_TIMESTAMPING_PKTINFO;
    }
    private static final int SO_PEERGROUPS = (int)59L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERGROUPS 59
     * }
     */
    public static int SO_PEERGROUPS() {
        return SO_PEERGROUPS;
    }
    private static final int SO_ZEROCOPY = (int)60L;
    /**
     * {@snippet lang=c :
     * #define SO_ZEROCOPY 60
     * }
     */
    public static int SO_ZEROCOPY() {
        return SO_ZEROCOPY;
    }
    private static final int SO_TXTIME = (int)61L;
    /**
     * {@snippet lang=c :
     * #define SO_TXTIME 61
     * }
     */
    public static int SO_TXTIME() {
        return SO_TXTIME;
    }
    private static final int SO_BINDTOIFINDEX = (int)62L;
    /**
     * {@snippet lang=c :
     * #define SO_BINDTOIFINDEX 62
     * }
     */
    public static int SO_BINDTOIFINDEX() {
        return SO_BINDTOIFINDEX;
    }
    private static final int SO_TIMESTAMP_OLD = (int)29L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMP_OLD 29
     * }
     */
    public static int SO_TIMESTAMP_OLD() {
        return SO_TIMESTAMP_OLD;
    }
    private static final int SO_TIMESTAMPNS_OLD = (int)35L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPNS_OLD 35
     * }
     */
    public static int SO_TIMESTAMPNS_OLD() {
        return SO_TIMESTAMPNS_OLD;
    }
    private static final int SO_TIMESTAMPING_OLD = (int)37L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPING_OLD 37
     * }
     */
    public static int SO_TIMESTAMPING_OLD() {
        return SO_TIMESTAMPING_OLD;
    }
    private static final int SO_TIMESTAMP_NEW = (int)63L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMP_NEW 63
     * }
     */
    public static int SO_TIMESTAMP_NEW() {
        return SO_TIMESTAMP_NEW;
    }
    private static final int SO_TIMESTAMPNS_NEW = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPNS_NEW 64
     * }
     */
    public static int SO_TIMESTAMPNS_NEW() {
        return SO_TIMESTAMPNS_NEW;
    }
    private static final int SO_TIMESTAMPING_NEW = (int)65L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPING_NEW 65
     * }
     */
    public static int SO_TIMESTAMPING_NEW() {
        return SO_TIMESTAMPING_NEW;
    }
    private static final int SO_RCVTIMEO_NEW = (int)66L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVTIMEO_NEW 66
     * }
     */
    public static int SO_RCVTIMEO_NEW() {
        return SO_RCVTIMEO_NEW;
    }
    private static final int SO_SNDTIMEO_NEW = (int)67L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDTIMEO_NEW 67
     * }
     */
    public static int SO_SNDTIMEO_NEW() {
        return SO_SNDTIMEO_NEW;
    }
    private static final int SO_DETACH_REUSEPORT_BPF = (int)68L;
    /**
     * {@snippet lang=c :
     * #define SO_DETACH_REUSEPORT_BPF 68
     * }
     */
    public static int SO_DETACH_REUSEPORT_BPF() {
        return SO_DETACH_REUSEPORT_BPF;
    }
    private static final int SO_PREFER_BUSY_POLL = (int)69L;
    /**
     * {@snippet lang=c :
     * #define SO_PREFER_BUSY_POLL 69
     * }
     */
    public static int SO_PREFER_BUSY_POLL() {
        return SO_PREFER_BUSY_POLL;
    }
    private static final int SO_BUSY_POLL_BUDGET = (int)70L;
    /**
     * {@snippet lang=c :
     * #define SO_BUSY_POLL_BUDGET 70
     * }
     */
    public static int SO_BUSY_POLL_BUDGET() {
        return SO_BUSY_POLL_BUDGET;
    }
    private static final int SO_NETNS_COOKIE = (int)71L;
    /**
     * {@snippet lang=c :
     * #define SO_NETNS_COOKIE 71
     * }
     */
    public static int SO_NETNS_COOKIE() {
        return SO_NETNS_COOKIE;
    }
    private static final int SO_BUF_LOCK = (int)72L;
    /**
     * {@snippet lang=c :
     * #define SO_BUF_LOCK 72
     * }
     */
    public static int SO_BUF_LOCK() {
        return SO_BUF_LOCK;
    }
    private static final int __osockaddr_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __osockaddr_defined 1
     * }
     */
    public static int __osockaddr_defined() {
        return __osockaddr_defined;
    }
    private static final int __USE_KERNEL_IPV6_DEFS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_KERNEL_IPV6_DEFS 0
     * }
     */
    public static int __USE_KERNEL_IPV6_DEFS() {
        return __USE_KERNEL_IPV6_DEFS;
    }
    private static final int IP_OPTIONS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IP_OPTIONS 4
     * }
     */
    public static int IP_OPTIONS() {
        return IP_OPTIONS;
    }
    private static final int IP_HDRINCL = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IP_HDRINCL 3
     * }
     */
    public static int IP_HDRINCL() {
        return IP_HDRINCL;
    }
    private static final int IP_TOS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IP_TOS 1
     * }
     */
    public static int IP_TOS() {
        return IP_TOS;
    }
    private static final int IP_TTL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IP_TTL 2
     * }
     */
    public static int IP_TTL() {
        return IP_TTL;
    }
    private static final int IP_RECVOPTS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define IP_RECVOPTS 6
     * }
     */
    public static int IP_RECVOPTS() {
        return IP_RECVOPTS;
    }
    private static final int IP_RETOPTS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define IP_RETOPTS 7
     * }
     */
    public static int IP_RETOPTS() {
        return IP_RETOPTS;
    }
    private static final int IP_MULTICAST_IF = (int)32L;
    /**
     * {@snippet lang=c :
     * #define IP_MULTICAST_IF 32
     * }
     */
    public static int IP_MULTICAST_IF() {
        return IP_MULTICAST_IF;
    }
    private static final int IP_MULTICAST_TTL = (int)33L;
    /**
     * {@snippet lang=c :
     * #define IP_MULTICAST_TTL 33
     * }
     */
    public static int IP_MULTICAST_TTL() {
        return IP_MULTICAST_TTL;
    }
    private static final int IP_MULTICAST_LOOP = (int)34L;
    /**
     * {@snippet lang=c :
     * #define IP_MULTICAST_LOOP 34
     * }
     */
    public static int IP_MULTICAST_LOOP() {
        return IP_MULTICAST_LOOP;
    }
    private static final int IP_ADD_MEMBERSHIP = (int)35L;
    /**
     * {@snippet lang=c :
     * #define IP_ADD_MEMBERSHIP 35
     * }
     */
    public static int IP_ADD_MEMBERSHIP() {
        return IP_ADD_MEMBERSHIP;
    }
    private static final int IP_DROP_MEMBERSHIP = (int)36L;
    /**
     * {@snippet lang=c :
     * #define IP_DROP_MEMBERSHIP 36
     * }
     */
    public static int IP_DROP_MEMBERSHIP() {
        return IP_DROP_MEMBERSHIP;
    }
    private static final int IP_UNBLOCK_SOURCE = (int)37L;
    /**
     * {@snippet lang=c :
     * #define IP_UNBLOCK_SOURCE 37
     * }
     */
    public static int IP_UNBLOCK_SOURCE() {
        return IP_UNBLOCK_SOURCE;
    }
    private static final int IP_BLOCK_SOURCE = (int)38L;
    /**
     * {@snippet lang=c :
     * #define IP_BLOCK_SOURCE 38
     * }
     */
    public static int IP_BLOCK_SOURCE() {
        return IP_BLOCK_SOURCE;
    }
    private static final int IP_ADD_SOURCE_MEMBERSHIP = (int)39L;
    /**
     * {@snippet lang=c :
     * #define IP_ADD_SOURCE_MEMBERSHIP 39
     * }
     */
    public static int IP_ADD_SOURCE_MEMBERSHIP() {
        return IP_ADD_SOURCE_MEMBERSHIP;
    }
    private static final int IP_DROP_SOURCE_MEMBERSHIP = (int)40L;
    /**
     * {@snippet lang=c :
     * #define IP_DROP_SOURCE_MEMBERSHIP 40
     * }
     */
    public static int IP_DROP_SOURCE_MEMBERSHIP() {
        return IP_DROP_SOURCE_MEMBERSHIP;
    }
    private static final int IP_MSFILTER = (int)41L;
    /**
     * {@snippet lang=c :
     * #define IP_MSFILTER 41
     * }
     */
    public static int IP_MSFILTER() {
        return IP_MSFILTER;
    }
    private static final int MCAST_JOIN_GROUP = (int)42L;
    /**
     * {@snippet lang=c :
     * #define MCAST_JOIN_GROUP 42
     * }
     */
    public static int MCAST_JOIN_GROUP() {
        return MCAST_JOIN_GROUP;
    }
    private static final int MCAST_BLOCK_SOURCE = (int)43L;
    /**
     * {@snippet lang=c :
     * #define MCAST_BLOCK_SOURCE 43
     * }
     */
    public static int MCAST_BLOCK_SOURCE() {
        return MCAST_BLOCK_SOURCE;
    }
    private static final int MCAST_UNBLOCK_SOURCE = (int)44L;
    /**
     * {@snippet lang=c :
     * #define MCAST_UNBLOCK_SOURCE 44
     * }
     */
    public static int MCAST_UNBLOCK_SOURCE() {
        return MCAST_UNBLOCK_SOURCE;
    }
    private static final int MCAST_LEAVE_GROUP = (int)45L;
    /**
     * {@snippet lang=c :
     * #define MCAST_LEAVE_GROUP 45
     * }
     */
    public static int MCAST_LEAVE_GROUP() {
        return MCAST_LEAVE_GROUP;
    }
    private static final int MCAST_JOIN_SOURCE_GROUP = (int)46L;
    /**
     * {@snippet lang=c :
     * #define MCAST_JOIN_SOURCE_GROUP 46
     * }
     */
    public static int MCAST_JOIN_SOURCE_GROUP() {
        return MCAST_JOIN_SOURCE_GROUP;
    }
    private static final int MCAST_LEAVE_SOURCE_GROUP = (int)47L;
    /**
     * {@snippet lang=c :
     * #define MCAST_LEAVE_SOURCE_GROUP 47
     * }
     */
    public static int MCAST_LEAVE_SOURCE_GROUP() {
        return MCAST_LEAVE_SOURCE_GROUP;
    }
    private static final int MCAST_MSFILTER = (int)48L;
    /**
     * {@snippet lang=c :
     * #define MCAST_MSFILTER 48
     * }
     */
    public static int MCAST_MSFILTER() {
        return MCAST_MSFILTER;
    }
    private static final int IP_MULTICAST_ALL = (int)49L;
    /**
     * {@snippet lang=c :
     * #define IP_MULTICAST_ALL 49
     * }
     */
    public static int IP_MULTICAST_ALL() {
        return IP_MULTICAST_ALL;
    }
    private static final int IP_UNICAST_IF = (int)50L;
    /**
     * {@snippet lang=c :
     * #define IP_UNICAST_IF 50
     * }
     */
    public static int IP_UNICAST_IF() {
        return IP_UNICAST_IF;
    }
    private static final int MCAST_EXCLUDE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MCAST_EXCLUDE 0
     * }
     */
    public static int MCAST_EXCLUDE() {
        return MCAST_EXCLUDE;
    }
    private static final int MCAST_INCLUDE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MCAST_INCLUDE 1
     * }
     */
    public static int MCAST_INCLUDE() {
        return MCAST_INCLUDE;
    }
    private static final int IP_ROUTER_ALERT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IP_ROUTER_ALERT 5
     * }
     */
    public static int IP_ROUTER_ALERT() {
        return IP_ROUTER_ALERT;
    }
    private static final int IP_PKTINFO = (int)8L;
    /**
     * {@snippet lang=c :
     * #define IP_PKTINFO 8
     * }
     */
    public static int IP_PKTINFO() {
        return IP_PKTINFO;
    }
    private static final int IP_PKTOPTIONS = (int)9L;
    /**
     * {@snippet lang=c :
     * #define IP_PKTOPTIONS 9
     * }
     */
    public static int IP_PKTOPTIONS() {
        return IP_PKTOPTIONS;
    }
    private static final int IP_PMTUDISC = (int)10L;
    /**
     * {@snippet lang=c :
     * #define IP_PMTUDISC 10
     * }
     */
    public static int IP_PMTUDISC() {
        return IP_PMTUDISC;
    }
    private static final int IP_MTU_DISCOVER = (int)10L;
    /**
     * {@snippet lang=c :
     * #define IP_MTU_DISCOVER 10
     * }
     */
    public static int IP_MTU_DISCOVER() {
        return IP_MTU_DISCOVER;
    }
    private static final int IP_RECVERR = (int)11L;
    /**
     * {@snippet lang=c :
     * #define IP_RECVERR 11
     * }
     */
    public static int IP_RECVERR() {
        return IP_RECVERR;
    }
    private static final int IP_RECVTTL = (int)12L;
    /**
     * {@snippet lang=c :
     * #define IP_RECVTTL 12
     * }
     */
    public static int IP_RECVTTL() {
        return IP_RECVTTL;
    }
    private static final int IP_RECVTOS = (int)13L;
    /**
     * {@snippet lang=c :
     * #define IP_RECVTOS 13
     * }
     */
    public static int IP_RECVTOS() {
        return IP_RECVTOS;
    }
    private static final int IP_MTU = (int)14L;
    /**
     * {@snippet lang=c :
     * #define IP_MTU 14
     * }
     */
    public static int IP_MTU() {
        return IP_MTU;
    }
    private static final int IP_FREEBIND = (int)15L;
    /**
     * {@snippet lang=c :
     * #define IP_FREEBIND 15
     * }
     */
    public static int IP_FREEBIND() {
        return IP_FREEBIND;
    }
    private static final int IP_IPSEC_POLICY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define IP_IPSEC_POLICY 16
     * }
     */
    public static int IP_IPSEC_POLICY() {
        return IP_IPSEC_POLICY;
    }
    private static final int IP_XFRM_POLICY = (int)17L;
    /**
     * {@snippet lang=c :
     * #define IP_XFRM_POLICY 17
     * }
     */
    public static int IP_XFRM_POLICY() {
        return IP_XFRM_POLICY;
    }
    private static final int IP_PASSSEC = (int)18L;
    /**
     * {@snippet lang=c :
     * #define IP_PASSSEC 18
     * }
     */
    public static int IP_PASSSEC() {
        return IP_PASSSEC;
    }
    private static final int IP_TRANSPARENT = (int)19L;
    /**
     * {@snippet lang=c :
     * #define IP_TRANSPARENT 19
     * }
     */
    public static int IP_TRANSPARENT() {
        return IP_TRANSPARENT;
    }
    private static final int IP_ORIGDSTADDR = (int)20L;
    /**
     * {@snippet lang=c :
     * #define IP_ORIGDSTADDR 20
     * }
     */
    public static int IP_ORIGDSTADDR() {
        return IP_ORIGDSTADDR;
    }
    private static final int IP_MINTTL = (int)21L;
    /**
     * {@snippet lang=c :
     * #define IP_MINTTL 21
     * }
     */
    public static int IP_MINTTL() {
        return IP_MINTTL;
    }
    private static final int IP_NODEFRAG = (int)22L;
    /**
     * {@snippet lang=c :
     * #define IP_NODEFRAG 22
     * }
     */
    public static int IP_NODEFRAG() {
        return IP_NODEFRAG;
    }
    private static final int IP_CHECKSUM = (int)23L;
    /**
     * {@snippet lang=c :
     * #define IP_CHECKSUM 23
     * }
     */
    public static int IP_CHECKSUM() {
        return IP_CHECKSUM;
    }
    private static final int IP_BIND_ADDRESS_NO_PORT = (int)24L;
    /**
     * {@snippet lang=c :
     * #define IP_BIND_ADDRESS_NO_PORT 24
     * }
     */
    public static int IP_BIND_ADDRESS_NO_PORT() {
        return IP_BIND_ADDRESS_NO_PORT;
    }
    private static final int IP_RECVFRAGSIZE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define IP_RECVFRAGSIZE 25
     * }
     */
    public static int IP_RECVFRAGSIZE() {
        return IP_RECVFRAGSIZE;
    }
    private static final int IP_RECVERR_RFC4884 = (int)26L;
    /**
     * {@snippet lang=c :
     * #define IP_RECVERR_RFC4884 26
     * }
     */
    public static int IP_RECVERR_RFC4884() {
        return IP_RECVERR_RFC4884;
    }
    private static final int IP_PMTUDISC_DONT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IP_PMTUDISC_DONT 0
     * }
     */
    public static int IP_PMTUDISC_DONT() {
        return IP_PMTUDISC_DONT;
    }
    private static final int IP_PMTUDISC_WANT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IP_PMTUDISC_WANT 1
     * }
     */
    public static int IP_PMTUDISC_WANT() {
        return IP_PMTUDISC_WANT;
    }
    private static final int IP_PMTUDISC_DO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IP_PMTUDISC_DO 2
     * }
     */
    public static int IP_PMTUDISC_DO() {
        return IP_PMTUDISC_DO;
    }
    private static final int IP_PMTUDISC_PROBE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IP_PMTUDISC_PROBE 3
     * }
     */
    public static int IP_PMTUDISC_PROBE() {
        return IP_PMTUDISC_PROBE;
    }
    private static final int IP_PMTUDISC_INTERFACE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IP_PMTUDISC_INTERFACE 4
     * }
     */
    public static int IP_PMTUDISC_INTERFACE() {
        return IP_PMTUDISC_INTERFACE;
    }
    private static final int IP_PMTUDISC_OMIT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IP_PMTUDISC_OMIT 5
     * }
     */
    public static int IP_PMTUDISC_OMIT() {
        return IP_PMTUDISC_OMIT;
    }
    private static final int SOL_IP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SOL_IP 0
     * }
     */
    public static int SOL_IP() {
        return SOL_IP;
    }
    private static final int IP_DEFAULT_MULTICAST_TTL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IP_DEFAULT_MULTICAST_TTL 1
     * }
     */
    public static int IP_DEFAULT_MULTICAST_TTL() {
        return IP_DEFAULT_MULTICAST_TTL;
    }
    private static final int IP_DEFAULT_MULTICAST_LOOP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IP_DEFAULT_MULTICAST_LOOP 1
     * }
     */
    public static int IP_DEFAULT_MULTICAST_LOOP() {
        return IP_DEFAULT_MULTICAST_LOOP;
    }
    private static final int IP_MAX_MEMBERSHIPS = (int)20L;
    /**
     * {@snippet lang=c :
     * #define IP_MAX_MEMBERSHIPS 20
     * }
     */
    public static int IP_MAX_MEMBERSHIPS() {
        return IP_MAX_MEMBERSHIPS;
    }
    private static final int IPV6_ADDRFORM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IPV6_ADDRFORM 1
     * }
     */
    public static int IPV6_ADDRFORM() {
        return IPV6_ADDRFORM;
    }
    private static final int IPV6_2292PKTINFO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IPV6_2292PKTINFO 2
     * }
     */
    public static int IPV6_2292PKTINFO() {
        return IPV6_2292PKTINFO;
    }
    private static final int IPV6_2292HOPOPTS = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IPV6_2292HOPOPTS 3
     * }
     */
    public static int IPV6_2292HOPOPTS() {
        return IPV6_2292HOPOPTS;
    }
    private static final int IPV6_2292DSTOPTS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IPV6_2292DSTOPTS 4
     * }
     */
    public static int IPV6_2292DSTOPTS() {
        return IPV6_2292DSTOPTS;
    }
    private static final int IPV6_2292RTHDR = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IPV6_2292RTHDR 5
     * }
     */
    public static int IPV6_2292RTHDR() {
        return IPV6_2292RTHDR;
    }
    private static final int IPV6_2292PKTOPTIONS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define IPV6_2292PKTOPTIONS 6
     * }
     */
    public static int IPV6_2292PKTOPTIONS() {
        return IPV6_2292PKTOPTIONS;
    }
    private static final int IPV6_CHECKSUM = (int)7L;
    /**
     * {@snippet lang=c :
     * #define IPV6_CHECKSUM 7
     * }
     */
    public static int IPV6_CHECKSUM() {
        return IPV6_CHECKSUM;
    }
    private static final int IPV6_2292HOPLIMIT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define IPV6_2292HOPLIMIT 8
     * }
     */
    public static int IPV6_2292HOPLIMIT() {
        return IPV6_2292HOPLIMIT;
    }
    private static final int IPV6_NEXTHOP = (int)9L;
    /**
     * {@snippet lang=c :
     * #define IPV6_NEXTHOP 9
     * }
     */
    public static int IPV6_NEXTHOP() {
        return IPV6_NEXTHOP;
    }
    private static final int IPV6_AUTHHDR = (int)10L;
    /**
     * {@snippet lang=c :
     * #define IPV6_AUTHHDR 10
     * }
     */
    public static int IPV6_AUTHHDR() {
        return IPV6_AUTHHDR;
    }
    private static final int IPV6_UNICAST_HOPS = (int)16L;
    /**
     * {@snippet lang=c :
     * #define IPV6_UNICAST_HOPS 16
     * }
     */
    public static int IPV6_UNICAST_HOPS() {
        return IPV6_UNICAST_HOPS;
    }
    private static final int IPV6_MULTICAST_IF = (int)17L;
    /**
     * {@snippet lang=c :
     * #define IPV6_MULTICAST_IF 17
     * }
     */
    public static int IPV6_MULTICAST_IF() {
        return IPV6_MULTICAST_IF;
    }
    private static final int IPV6_MULTICAST_HOPS = (int)18L;
    /**
     * {@snippet lang=c :
     * #define IPV6_MULTICAST_HOPS 18
     * }
     */
    public static int IPV6_MULTICAST_HOPS() {
        return IPV6_MULTICAST_HOPS;
    }
    private static final int IPV6_MULTICAST_LOOP = (int)19L;
    /**
     * {@snippet lang=c :
     * #define IPV6_MULTICAST_LOOP 19
     * }
     */
    public static int IPV6_MULTICAST_LOOP() {
        return IPV6_MULTICAST_LOOP;
    }
    private static final int IPV6_JOIN_GROUP = (int)20L;
    /**
     * {@snippet lang=c :
     * #define IPV6_JOIN_GROUP 20
     * }
     */
    public static int IPV6_JOIN_GROUP() {
        return IPV6_JOIN_GROUP;
    }
    private static final int IPV6_LEAVE_GROUP = (int)21L;
    /**
     * {@snippet lang=c :
     * #define IPV6_LEAVE_GROUP 21
     * }
     */
    public static int IPV6_LEAVE_GROUP() {
        return IPV6_LEAVE_GROUP;
    }
    private static final int IPV6_ROUTER_ALERT = (int)22L;
    /**
     * {@snippet lang=c :
     * #define IPV6_ROUTER_ALERT 22
     * }
     */
    public static int IPV6_ROUTER_ALERT() {
        return IPV6_ROUTER_ALERT;
    }
    private static final int IPV6_MTU_DISCOVER = (int)23L;
    /**
     * {@snippet lang=c :
     * #define IPV6_MTU_DISCOVER 23
     * }
     */
    public static int IPV6_MTU_DISCOVER() {
        return IPV6_MTU_DISCOVER;
    }
    private static final int IPV6_MTU = (int)24L;
    /**
     * {@snippet lang=c :
     * #define IPV6_MTU 24
     * }
     */
    public static int IPV6_MTU() {
        return IPV6_MTU;
    }
    private static final int IPV6_RECVERR = (int)25L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVERR 25
     * }
     */
    public static int IPV6_RECVERR() {
        return IPV6_RECVERR;
    }
    private static final int IPV6_V6ONLY = (int)26L;
    /**
     * {@snippet lang=c :
     * #define IPV6_V6ONLY 26
     * }
     */
    public static int IPV6_V6ONLY() {
        return IPV6_V6ONLY;
    }
    private static final int IPV6_JOIN_ANYCAST = (int)27L;
    /**
     * {@snippet lang=c :
     * #define IPV6_JOIN_ANYCAST 27
     * }
     */
    public static int IPV6_JOIN_ANYCAST() {
        return IPV6_JOIN_ANYCAST;
    }
    private static final int IPV6_LEAVE_ANYCAST = (int)28L;
    /**
     * {@snippet lang=c :
     * #define IPV6_LEAVE_ANYCAST 28
     * }
     */
    public static int IPV6_LEAVE_ANYCAST() {
        return IPV6_LEAVE_ANYCAST;
    }
    private static final int IPV6_MULTICAST_ALL = (int)29L;
    /**
     * {@snippet lang=c :
     * #define IPV6_MULTICAST_ALL 29
     * }
     */
    public static int IPV6_MULTICAST_ALL() {
        return IPV6_MULTICAST_ALL;
    }
    private static final int IPV6_ROUTER_ALERT_ISOLATE = (int)30L;
    /**
     * {@snippet lang=c :
     * #define IPV6_ROUTER_ALERT_ISOLATE 30
     * }
     */
    public static int IPV6_ROUTER_ALERT_ISOLATE() {
        return IPV6_ROUTER_ALERT_ISOLATE;
    }
    private static final int IPV6_RECVERR_RFC4884 = (int)31L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVERR_RFC4884 31
     * }
     */
    public static int IPV6_RECVERR_RFC4884() {
        return IPV6_RECVERR_RFC4884;
    }
    private static final int IPV6_IPSEC_POLICY = (int)34L;
    /**
     * {@snippet lang=c :
     * #define IPV6_IPSEC_POLICY 34
     * }
     */
    public static int IPV6_IPSEC_POLICY() {
        return IPV6_IPSEC_POLICY;
    }
    private static final int IPV6_XFRM_POLICY = (int)35L;
    /**
     * {@snippet lang=c :
     * #define IPV6_XFRM_POLICY 35
     * }
     */
    public static int IPV6_XFRM_POLICY() {
        return IPV6_XFRM_POLICY;
    }
    private static final int IPV6_HDRINCL = (int)36L;
    /**
     * {@snippet lang=c :
     * #define IPV6_HDRINCL 36
     * }
     */
    public static int IPV6_HDRINCL() {
        return IPV6_HDRINCL;
    }
    private static final int IPV6_RECVPKTINFO = (int)49L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVPKTINFO 49
     * }
     */
    public static int IPV6_RECVPKTINFO() {
        return IPV6_RECVPKTINFO;
    }
    private static final int IPV6_PKTINFO = (int)50L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PKTINFO 50
     * }
     */
    public static int IPV6_PKTINFO() {
        return IPV6_PKTINFO;
    }
    private static final int IPV6_RECVHOPLIMIT = (int)51L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVHOPLIMIT 51
     * }
     */
    public static int IPV6_RECVHOPLIMIT() {
        return IPV6_RECVHOPLIMIT;
    }
    private static final int IPV6_HOPLIMIT = (int)52L;
    /**
     * {@snippet lang=c :
     * #define IPV6_HOPLIMIT 52
     * }
     */
    public static int IPV6_HOPLIMIT() {
        return IPV6_HOPLIMIT;
    }
    private static final int IPV6_RECVHOPOPTS = (int)53L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVHOPOPTS 53
     * }
     */
    public static int IPV6_RECVHOPOPTS() {
        return IPV6_RECVHOPOPTS;
    }
    private static final int IPV6_HOPOPTS = (int)54L;
    /**
     * {@snippet lang=c :
     * #define IPV6_HOPOPTS 54
     * }
     */
    public static int IPV6_HOPOPTS() {
        return IPV6_HOPOPTS;
    }
    private static final int IPV6_RTHDRDSTOPTS = (int)55L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RTHDRDSTOPTS 55
     * }
     */
    public static int IPV6_RTHDRDSTOPTS() {
        return IPV6_RTHDRDSTOPTS;
    }
    private static final int IPV6_RECVRTHDR = (int)56L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVRTHDR 56
     * }
     */
    public static int IPV6_RECVRTHDR() {
        return IPV6_RECVRTHDR;
    }
    private static final int IPV6_RTHDR = (int)57L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RTHDR 57
     * }
     */
    public static int IPV6_RTHDR() {
        return IPV6_RTHDR;
    }
    private static final int IPV6_RECVDSTOPTS = (int)58L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVDSTOPTS 58
     * }
     */
    public static int IPV6_RECVDSTOPTS() {
        return IPV6_RECVDSTOPTS;
    }
    private static final int IPV6_DSTOPTS = (int)59L;
    /**
     * {@snippet lang=c :
     * #define IPV6_DSTOPTS 59
     * }
     */
    public static int IPV6_DSTOPTS() {
        return IPV6_DSTOPTS;
    }
    private static final int IPV6_RECVPATHMTU = (int)60L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVPATHMTU 60
     * }
     */
    public static int IPV6_RECVPATHMTU() {
        return IPV6_RECVPATHMTU;
    }
    private static final int IPV6_PATHMTU = (int)61L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PATHMTU 61
     * }
     */
    public static int IPV6_PATHMTU() {
        return IPV6_PATHMTU;
    }
    private static final int IPV6_DONTFRAG = (int)62L;
    /**
     * {@snippet lang=c :
     * #define IPV6_DONTFRAG 62
     * }
     */
    public static int IPV6_DONTFRAG() {
        return IPV6_DONTFRAG;
    }
    private static final int IPV6_RECVTCLASS = (int)66L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVTCLASS 66
     * }
     */
    public static int IPV6_RECVTCLASS() {
        return IPV6_RECVTCLASS;
    }
    private static final int IPV6_TCLASS = (int)67L;
    /**
     * {@snippet lang=c :
     * #define IPV6_TCLASS 67
     * }
     */
    public static int IPV6_TCLASS() {
        return IPV6_TCLASS;
    }
    private static final int IPV6_AUTOFLOWLABEL = (int)70L;
    /**
     * {@snippet lang=c :
     * #define IPV6_AUTOFLOWLABEL 70
     * }
     */
    public static int IPV6_AUTOFLOWLABEL() {
        return IPV6_AUTOFLOWLABEL;
    }
    private static final int IPV6_ADDR_PREFERENCES = (int)72L;
    /**
     * {@snippet lang=c :
     * #define IPV6_ADDR_PREFERENCES 72
     * }
     */
    public static int IPV6_ADDR_PREFERENCES() {
        return IPV6_ADDR_PREFERENCES;
    }
    private static final int IPV6_MINHOPCOUNT = (int)73L;
    /**
     * {@snippet lang=c :
     * #define IPV6_MINHOPCOUNT 73
     * }
     */
    public static int IPV6_MINHOPCOUNT() {
        return IPV6_MINHOPCOUNT;
    }
    private static final int IPV6_ORIGDSTADDR = (int)74L;
    /**
     * {@snippet lang=c :
     * #define IPV6_ORIGDSTADDR 74
     * }
     */
    public static int IPV6_ORIGDSTADDR() {
        return IPV6_ORIGDSTADDR;
    }
    private static final int IPV6_TRANSPARENT = (int)75L;
    /**
     * {@snippet lang=c :
     * #define IPV6_TRANSPARENT 75
     * }
     */
    public static int IPV6_TRANSPARENT() {
        return IPV6_TRANSPARENT;
    }
    private static final int IPV6_UNICAST_IF = (int)76L;
    /**
     * {@snippet lang=c :
     * #define IPV6_UNICAST_IF 76
     * }
     */
    public static int IPV6_UNICAST_IF() {
        return IPV6_UNICAST_IF;
    }
    private static final int IPV6_RECVFRAGSIZE = (int)77L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVFRAGSIZE 77
     * }
     */
    public static int IPV6_RECVFRAGSIZE() {
        return IPV6_RECVFRAGSIZE;
    }
    private static final int IPV6_FREEBIND = (int)78L;
    /**
     * {@snippet lang=c :
     * #define IPV6_FREEBIND 78
     * }
     */
    public static int IPV6_FREEBIND() {
        return IPV6_FREEBIND;
    }
    private static final int IPV6_PMTUDISC_DONT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PMTUDISC_DONT 0
     * }
     */
    public static int IPV6_PMTUDISC_DONT() {
        return IPV6_PMTUDISC_DONT;
    }
    private static final int IPV6_PMTUDISC_WANT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PMTUDISC_WANT 1
     * }
     */
    public static int IPV6_PMTUDISC_WANT() {
        return IPV6_PMTUDISC_WANT;
    }
    private static final int IPV6_PMTUDISC_DO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PMTUDISC_DO 2
     * }
     */
    public static int IPV6_PMTUDISC_DO() {
        return IPV6_PMTUDISC_DO;
    }
    private static final int IPV6_PMTUDISC_PROBE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PMTUDISC_PROBE 3
     * }
     */
    public static int IPV6_PMTUDISC_PROBE() {
        return IPV6_PMTUDISC_PROBE;
    }
    private static final int IPV6_PMTUDISC_INTERFACE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PMTUDISC_INTERFACE 4
     * }
     */
    public static int IPV6_PMTUDISC_INTERFACE() {
        return IPV6_PMTUDISC_INTERFACE;
    }
    private static final int IPV6_PMTUDISC_OMIT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PMTUDISC_OMIT 5
     * }
     */
    public static int IPV6_PMTUDISC_OMIT() {
        return IPV6_PMTUDISC_OMIT;
    }
    private static final int SOL_IPV6 = (int)41L;
    /**
     * {@snippet lang=c :
     * #define SOL_IPV6 41
     * }
     */
    public static int SOL_IPV6() {
        return SOL_IPV6;
    }
    private static final int SOL_ICMPV6 = (int)58L;
    /**
     * {@snippet lang=c :
     * #define SOL_ICMPV6 58
     * }
     */
    public static int SOL_ICMPV6() {
        return SOL_ICMPV6;
    }
    private static final int IPV6_RTHDR_LOOSE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RTHDR_LOOSE 0
     * }
     */
    public static int IPV6_RTHDR_LOOSE() {
        return IPV6_RTHDR_LOOSE;
    }
    private static final int IPV6_RTHDR_STRICT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RTHDR_STRICT 1
     * }
     */
    public static int IPV6_RTHDR_STRICT() {
        return IPV6_RTHDR_STRICT;
    }
    private static final int IPV6_RTHDR_TYPE_0 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RTHDR_TYPE_0 0
     * }
     */
    public static int IPV6_RTHDR_TYPE_0() {
        return IPV6_RTHDR_TYPE_0;
    }
    private static final int IN_CLASSA_NSHIFT = (int)24L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSA_NSHIFT 24
     * }
     */
    public static int IN_CLASSA_NSHIFT() {
        return IN_CLASSA_NSHIFT;
    }
    private static final int IN_CLASSA_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSA_MAX 128
     * }
     */
    public static int IN_CLASSA_MAX() {
        return IN_CLASSA_MAX;
    }
    private static final int IN_CLASSB_NSHIFT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSB_NSHIFT 16
     * }
     */
    public static int IN_CLASSB_NSHIFT() {
        return IN_CLASSB_NSHIFT;
    }
    private static final int IN_CLASSB_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSB_MAX 65536
     * }
     */
    public static int IN_CLASSB_MAX() {
        return IN_CLASSB_MAX;
    }
    private static final int IN_CLASSC_NSHIFT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSC_NSHIFT 8
     * }
     */
    public static int IN_CLASSC_NSHIFT() {
        return IN_CLASSC_NSHIFT;
    }
    private static final int IN_LOOPBACKNET = (int)127L;
    /**
     * {@snippet lang=c :
     * #define IN_LOOPBACKNET 127
     * }
     */
    public static int IN_LOOPBACKNET() {
        return IN_LOOPBACKNET;
    }
    private static final int INET_ADDRSTRLEN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define INET_ADDRSTRLEN 16
     * }
     */
    public static int INET_ADDRSTRLEN() {
        return INET_ADDRSTRLEN;
    }
    private static final int INET6_ADDRSTRLEN = (int)46L;
    /**
     * {@snippet lang=c :
     * #define INET6_ADDRSTRLEN 46
     * }
     */
    public static int INET6_ADDRSTRLEN() {
        return INET6_ADDRSTRLEN;
    }
    private static final int _STDINT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDINT_H 1
     * }
     */
    public static int _STDINT_H() {
        return _STDINT_H;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int _BITS_WCHAR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_WCHAR_H 1
     * }
     */
    public static int _BITS_WCHAR_H() {
        return _BITS_WCHAR_H;
    }
    private static final int _PTHREAD_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_H 1
     * }
     */
    public static int _PTHREAD_H() {
        return _PTHREAD_H;
    }
    private static final int _SCHED_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SCHED_H 1
     * }
     */
    public static int _SCHED_H() {
        return _SCHED_H;
    }
    private static final int _BITS_SCHED_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_SCHED_H 1
     * }
     */
    public static int _BITS_SCHED_H() {
        return _BITS_SCHED_H;
    }
    private static final int SCHED_OTHER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SCHED_OTHER 0
     * }
     */
    public static int SCHED_OTHER() {
        return SCHED_OTHER;
    }
    private static final int SCHED_FIFO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SCHED_FIFO 1
     * }
     */
    public static int SCHED_FIFO() {
        return SCHED_FIFO;
    }
    private static final int SCHED_RR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SCHED_RR 2
     * }
     */
    public static int SCHED_RR() {
        return SCHED_RR;
    }
    private static final int _BITS_TYPES_STRUCT_SCHED_PARAM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_STRUCT_SCHED_PARAM 1
     * }
     */
    public static int _BITS_TYPES_STRUCT_SCHED_PARAM() {
        return _BITS_TYPES_STRUCT_SCHED_PARAM;
    }
    private static final int _BITS_CPU_SET_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_CPU_SET_H 1
     * }
     */
    public static int _BITS_CPU_SET_H() {
        return _BITS_CPU_SET_H;
    }
    private static final int __CPU_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __CPU_SETSIZE 1024
     * }
     */
    public static int __CPU_SETSIZE() {
        return __CPU_SETSIZE;
    }
    private static final int _TIME_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _TIME_H 1
     * }
     */
    public static int _TIME_H() {
        return _TIME_H;
    }
    private static final int _BITS_TIME_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME_H 1
     * }
     */
    public static int _BITS_TIME_H() {
        return _BITS_TIME_H;
    }
    private static final int CLOCK_REALTIME = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME 0
     * }
     */
    public static int CLOCK_REALTIME() {
        return CLOCK_REALTIME;
    }
    private static final int CLOCK_MONOTONIC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC 1
     * }
     */
    public static int CLOCK_MONOTONIC() {
        return CLOCK_MONOTONIC;
    }
    private static final int CLOCK_PROCESS_CPUTIME_ID = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_PROCESS_CPUTIME_ID 2
     * }
     */
    public static int CLOCK_PROCESS_CPUTIME_ID() {
        return CLOCK_PROCESS_CPUTIME_ID;
    }
    private static final int CLOCK_THREAD_CPUTIME_ID = (int)3L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_THREAD_CPUTIME_ID 3
     * }
     */
    public static int CLOCK_THREAD_CPUTIME_ID() {
        return CLOCK_THREAD_CPUTIME_ID;
    }
    private static final int CLOCK_MONOTONIC_RAW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_RAW 4
     * }
     */
    public static int CLOCK_MONOTONIC_RAW() {
        return CLOCK_MONOTONIC_RAW;
    }
    private static final int CLOCK_REALTIME_COARSE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME_COARSE 5
     * }
     */
    public static int CLOCK_REALTIME_COARSE() {
        return CLOCK_REALTIME_COARSE;
    }
    private static final int CLOCK_MONOTONIC_COARSE = (int)6L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_COARSE 6
     * }
     */
    public static int CLOCK_MONOTONIC_COARSE() {
        return CLOCK_MONOTONIC_COARSE;
    }
    private static final int CLOCK_BOOTTIME = (int)7L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_BOOTTIME 7
     * }
     */
    public static int CLOCK_BOOTTIME() {
        return CLOCK_BOOTTIME;
    }
    private static final int CLOCK_REALTIME_ALARM = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME_ALARM 8
     * }
     */
    public static int CLOCK_REALTIME_ALARM() {
        return CLOCK_REALTIME_ALARM;
    }
    private static final int CLOCK_BOOTTIME_ALARM = (int)9L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_BOOTTIME_ALARM 9
     * }
     */
    public static int CLOCK_BOOTTIME_ALARM() {
        return CLOCK_BOOTTIME_ALARM;
    }
    private static final int CLOCK_TAI = (int)11L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_TAI 11
     * }
     */
    public static int CLOCK_TAI() {
        return CLOCK_TAI;
    }
    private static final int TIMER_ABSTIME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIMER_ABSTIME 1
     * }
     */
    public static int TIMER_ABSTIME() {
        return TIMER_ABSTIME;
    }
    private static final int __struct_tm_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_tm_defined 1
     * }
     */
    public static int __struct_tm_defined() {
        return __struct_tm_defined;
    }
    private static final int __itimerspec_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __itimerspec_defined 1
     * }
     */
    public static int __itimerspec_defined() {
        return __itimerspec_defined;
    }
    private static final int _BITS_TYPES_LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES_LOCALE_T_H() {
        return _BITS_TYPES_LOCALE_T_H;
    }
    private static final int _BITS_TYPES___LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES___LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES___LOCALE_T_H() {
        return _BITS_TYPES___LOCALE_T_H;
    }
    private static final int TIME_UTC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIME_UTC 1
     * }
     */
    public static int TIME_UTC() {
        return TIME_UTC;
    }
    private static final int _BITS_SETJMP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_SETJMP_H 1
     * }
     */
    public static int _BITS_SETJMP_H() {
        return _BITS_SETJMP_H;
    }
    private static final int __jmp_buf_tag_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __jmp_buf_tag_defined 1
     * }
     */
    public static int __jmp_buf_tag_defined() {
        return __jmp_buf_tag_defined;
    }
    private static final int PTHREAD_STACK_MIN = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_STACK_MIN 16384
     * }
     */
    public static int PTHREAD_STACK_MIN() {
        return PTHREAD_STACK_MIN;
    }
    private static final int PTHREAD_ONCE_INIT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_ONCE_INIT 0
     * }
     */
    public static int PTHREAD_ONCE_INIT() {
        return PTHREAD_ONCE_INIT;
    }
    private static final int _ERRNO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ERRNO_H 1
     * }
     */
    public static int _ERRNO_H() {
        return _ERRNO_H;
    }
    private static final int _BITS_ERRNO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ERRNO_H 1
     * }
     */
    public static int _BITS_ERRNO_H() {
        return _BITS_ERRNO_H;
    }
    private static final int EPERM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EPERM 1
     * }
     */
    public static int EPERM() {
        return EPERM;
    }
    private static final int ENOENT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ENOENT 2
     * }
     */
    public static int ENOENT() {
        return ENOENT;
    }
    private static final int ESRCH = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ESRCH 3
     * }
     */
    public static int ESRCH() {
        return ESRCH;
    }
    private static final int EINTR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EINTR 4
     * }
     */
    public static int EINTR() {
        return EINTR;
    }
    private static final int EIO = (int)5L;
    /**
     * {@snippet lang=c :
     * #define EIO 5
     * }
     */
    public static int EIO() {
        return EIO;
    }
    private static final int ENXIO = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ENXIO 6
     * }
     */
    public static int ENXIO() {
        return ENXIO;
    }
    private static final int E2BIG = (int)7L;
    /**
     * {@snippet lang=c :
     * #define E2BIG 7
     * }
     */
    public static int E2BIG() {
        return E2BIG;
    }
    private static final int ENOEXEC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ENOEXEC 8
     * }
     */
    public static int ENOEXEC() {
        return ENOEXEC;
    }
    private static final int EBADF = (int)9L;
    /**
     * {@snippet lang=c :
     * #define EBADF 9
     * }
     */
    public static int EBADF() {
        return EBADF;
    }
    private static final int ECHILD = (int)10L;
    /**
     * {@snippet lang=c :
     * #define ECHILD 10
     * }
     */
    public static int ECHILD() {
        return ECHILD;
    }
    private static final int EAGAIN = (int)11L;
    /**
     * {@snippet lang=c :
     * #define EAGAIN 11
     * }
     */
    public static int EAGAIN() {
        return EAGAIN;
    }
    private static final int ENOMEM = (int)12L;
    /**
     * {@snippet lang=c :
     * #define ENOMEM 12
     * }
     */
    public static int ENOMEM() {
        return ENOMEM;
    }
    private static final int EACCES = (int)13L;
    /**
     * {@snippet lang=c :
     * #define EACCES 13
     * }
     */
    public static int EACCES() {
        return EACCES;
    }
    private static final int EFAULT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define EFAULT 14
     * }
     */
    public static int EFAULT() {
        return EFAULT;
    }
    private static final int ENOTBLK = (int)15L;
    /**
     * {@snippet lang=c :
     * #define ENOTBLK 15
     * }
     */
    public static int ENOTBLK() {
        return ENOTBLK;
    }
    private static final int EBUSY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EBUSY 16
     * }
     */
    public static int EBUSY() {
        return EBUSY;
    }
    private static final int EEXIST = (int)17L;
    /**
     * {@snippet lang=c :
     * #define EEXIST 17
     * }
     */
    public static int EEXIST() {
        return EEXIST;
    }
    private static final int EXDEV = (int)18L;
    /**
     * {@snippet lang=c :
     * #define EXDEV 18
     * }
     */
    public static int EXDEV() {
        return EXDEV;
    }
    private static final int ENODEV = (int)19L;
    /**
     * {@snippet lang=c :
     * #define ENODEV 19
     * }
     */
    public static int ENODEV() {
        return ENODEV;
    }
    private static final int ENOTDIR = (int)20L;
    /**
     * {@snippet lang=c :
     * #define ENOTDIR 20
     * }
     */
    public static int ENOTDIR() {
        return ENOTDIR;
    }
    private static final int EISDIR = (int)21L;
    /**
     * {@snippet lang=c :
     * #define EISDIR 21
     * }
     */
    public static int EISDIR() {
        return EISDIR;
    }
    private static final int EINVAL = (int)22L;
    /**
     * {@snippet lang=c :
     * #define EINVAL 22
     * }
     */
    public static int EINVAL() {
        return EINVAL;
    }
    private static final int ENFILE = (int)23L;
    /**
     * {@snippet lang=c :
     * #define ENFILE 23
     * }
     */
    public static int ENFILE() {
        return ENFILE;
    }
    private static final int EMFILE = (int)24L;
    /**
     * {@snippet lang=c :
     * #define EMFILE 24
     * }
     */
    public static int EMFILE() {
        return EMFILE;
    }
    private static final int ENOTTY = (int)25L;
    /**
     * {@snippet lang=c :
     * #define ENOTTY 25
     * }
     */
    public static int ENOTTY() {
        return ENOTTY;
    }
    private static final int ETXTBSY = (int)26L;
    /**
     * {@snippet lang=c :
     * #define ETXTBSY 26
     * }
     */
    public static int ETXTBSY() {
        return ETXTBSY;
    }
    private static final int EFBIG = (int)27L;
    /**
     * {@snippet lang=c :
     * #define EFBIG 27
     * }
     */
    public static int EFBIG() {
        return EFBIG;
    }
    private static final int ENOSPC = (int)28L;
    /**
     * {@snippet lang=c :
     * #define ENOSPC 28
     * }
     */
    public static int ENOSPC() {
        return ENOSPC;
    }
    private static final int ESPIPE = (int)29L;
    /**
     * {@snippet lang=c :
     * #define ESPIPE 29
     * }
     */
    public static int ESPIPE() {
        return ESPIPE;
    }
    private static final int EROFS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define EROFS 30
     * }
     */
    public static int EROFS() {
        return EROFS;
    }
    private static final int EMLINK = (int)31L;
    /**
     * {@snippet lang=c :
     * #define EMLINK 31
     * }
     */
    public static int EMLINK() {
        return EMLINK;
    }
    private static final int EPIPE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EPIPE 32
     * }
     */
    public static int EPIPE() {
        return EPIPE;
    }
    private static final int EDOM = (int)33L;
    /**
     * {@snippet lang=c :
     * #define EDOM 33
     * }
     */
    public static int EDOM() {
        return EDOM;
    }
    private static final int ERANGE = (int)34L;
    /**
     * {@snippet lang=c :
     * #define ERANGE 34
     * }
     */
    public static int ERANGE() {
        return ERANGE;
    }
    private static final int EDEADLK = (int)35L;
    /**
     * {@snippet lang=c :
     * #define EDEADLK 35
     * }
     */
    public static int EDEADLK() {
        return EDEADLK;
    }
    private static final int ENAMETOOLONG = (int)36L;
    /**
     * {@snippet lang=c :
     * #define ENAMETOOLONG 36
     * }
     */
    public static int ENAMETOOLONG() {
        return ENAMETOOLONG;
    }
    private static final int ENOLCK = (int)37L;
    /**
     * {@snippet lang=c :
     * #define ENOLCK 37
     * }
     */
    public static int ENOLCK() {
        return ENOLCK;
    }
    private static final int ENOSYS = (int)38L;
    /**
     * {@snippet lang=c :
     * #define ENOSYS 38
     * }
     */
    public static int ENOSYS() {
        return ENOSYS;
    }
    private static final int ENOTEMPTY = (int)39L;
    /**
     * {@snippet lang=c :
     * #define ENOTEMPTY 39
     * }
     */
    public static int ENOTEMPTY() {
        return ENOTEMPTY;
    }
    private static final int ELOOP = (int)40L;
    /**
     * {@snippet lang=c :
     * #define ELOOP 40
     * }
     */
    public static int ELOOP() {
        return ELOOP;
    }
    private static final int ENOMSG = (int)42L;
    /**
     * {@snippet lang=c :
     * #define ENOMSG 42
     * }
     */
    public static int ENOMSG() {
        return ENOMSG;
    }
    private static final int EIDRM = (int)43L;
    /**
     * {@snippet lang=c :
     * #define EIDRM 43
     * }
     */
    public static int EIDRM() {
        return EIDRM;
    }
    private static final int ECHRNG = (int)44L;
    /**
     * {@snippet lang=c :
     * #define ECHRNG 44
     * }
     */
    public static int ECHRNG() {
        return ECHRNG;
    }
    private static final int EL2NSYNC = (int)45L;
    /**
     * {@snippet lang=c :
     * #define EL2NSYNC 45
     * }
     */
    public static int EL2NSYNC() {
        return EL2NSYNC;
    }
    private static final int EL3HLT = (int)46L;
    /**
     * {@snippet lang=c :
     * #define EL3HLT 46
     * }
     */
    public static int EL3HLT() {
        return EL3HLT;
    }
    private static final int EL3RST = (int)47L;
    /**
     * {@snippet lang=c :
     * #define EL3RST 47
     * }
     */
    public static int EL3RST() {
        return EL3RST;
    }
    private static final int ELNRNG = (int)48L;
    /**
     * {@snippet lang=c :
     * #define ELNRNG 48
     * }
     */
    public static int ELNRNG() {
        return ELNRNG;
    }
    private static final int EUNATCH = (int)49L;
    /**
     * {@snippet lang=c :
     * #define EUNATCH 49
     * }
     */
    public static int EUNATCH() {
        return EUNATCH;
    }
    private static final int ENOCSI = (int)50L;
    /**
     * {@snippet lang=c :
     * #define ENOCSI 50
     * }
     */
    public static int ENOCSI() {
        return ENOCSI;
    }
    private static final int EL2HLT = (int)51L;
    /**
     * {@snippet lang=c :
     * #define EL2HLT 51
     * }
     */
    public static int EL2HLT() {
        return EL2HLT;
    }
    private static final int EBADE = (int)52L;
    /**
     * {@snippet lang=c :
     * #define EBADE 52
     * }
     */
    public static int EBADE() {
        return EBADE;
    }
    private static final int EBADR = (int)53L;
    /**
     * {@snippet lang=c :
     * #define EBADR 53
     * }
     */
    public static int EBADR() {
        return EBADR;
    }
    private static final int EXFULL = (int)54L;
    /**
     * {@snippet lang=c :
     * #define EXFULL 54
     * }
     */
    public static int EXFULL() {
        return EXFULL;
    }
    private static final int ENOANO = (int)55L;
    /**
     * {@snippet lang=c :
     * #define ENOANO 55
     * }
     */
    public static int ENOANO() {
        return ENOANO;
    }
    private static final int EBADRQC = (int)56L;
    /**
     * {@snippet lang=c :
     * #define EBADRQC 56
     * }
     */
    public static int EBADRQC() {
        return EBADRQC;
    }
    private static final int EBADSLT = (int)57L;
    /**
     * {@snippet lang=c :
     * #define EBADSLT 57
     * }
     */
    public static int EBADSLT() {
        return EBADSLT;
    }
    private static final int EBFONT = (int)59L;
    /**
     * {@snippet lang=c :
     * #define EBFONT 59
     * }
     */
    public static int EBFONT() {
        return EBFONT;
    }
    private static final int ENOSTR = (int)60L;
    /**
     * {@snippet lang=c :
     * #define ENOSTR 60
     * }
     */
    public static int ENOSTR() {
        return ENOSTR;
    }
    private static final int ENODATA = (int)61L;
    /**
     * {@snippet lang=c :
     * #define ENODATA 61
     * }
     */
    public static int ENODATA() {
        return ENODATA;
    }
    private static final int ETIME = (int)62L;
    /**
     * {@snippet lang=c :
     * #define ETIME 62
     * }
     */
    public static int ETIME() {
        return ETIME;
    }
    private static final int ENOSR = (int)63L;
    /**
     * {@snippet lang=c :
     * #define ENOSR 63
     * }
     */
    public static int ENOSR() {
        return ENOSR;
    }
    private static final int ENONET = (int)64L;
    /**
     * {@snippet lang=c :
     * #define ENONET 64
     * }
     */
    public static int ENONET() {
        return ENONET;
    }
    private static final int ENOPKG = (int)65L;
    /**
     * {@snippet lang=c :
     * #define ENOPKG 65
     * }
     */
    public static int ENOPKG() {
        return ENOPKG;
    }
    private static final int EREMOTE = (int)66L;
    /**
     * {@snippet lang=c :
     * #define EREMOTE 66
     * }
     */
    public static int EREMOTE() {
        return EREMOTE;
    }
    private static final int ENOLINK = (int)67L;
    /**
     * {@snippet lang=c :
     * #define ENOLINK 67
     * }
     */
    public static int ENOLINK() {
        return ENOLINK;
    }
    private static final int EADV = (int)68L;
    /**
     * {@snippet lang=c :
     * #define EADV 68
     * }
     */
    public static int EADV() {
        return EADV;
    }
    private static final int ESRMNT = (int)69L;
    /**
     * {@snippet lang=c :
     * #define ESRMNT 69
     * }
     */
    public static int ESRMNT() {
        return ESRMNT;
    }
    private static final int ECOMM = (int)70L;
    /**
     * {@snippet lang=c :
     * #define ECOMM 70
     * }
     */
    public static int ECOMM() {
        return ECOMM;
    }
    private static final int EPROTO = (int)71L;
    /**
     * {@snippet lang=c :
     * #define EPROTO 71
     * }
     */
    public static int EPROTO() {
        return EPROTO;
    }
    private static final int EMULTIHOP = (int)72L;
    /**
     * {@snippet lang=c :
     * #define EMULTIHOP 72
     * }
     */
    public static int EMULTIHOP() {
        return EMULTIHOP;
    }
    private static final int EDOTDOT = (int)73L;
    /**
     * {@snippet lang=c :
     * #define EDOTDOT 73
     * }
     */
    public static int EDOTDOT() {
        return EDOTDOT;
    }
    private static final int EBADMSG = (int)74L;
    /**
     * {@snippet lang=c :
     * #define EBADMSG 74
     * }
     */
    public static int EBADMSG() {
        return EBADMSG;
    }
    private static final int EOVERFLOW = (int)75L;
    /**
     * {@snippet lang=c :
     * #define EOVERFLOW 75
     * }
     */
    public static int EOVERFLOW() {
        return EOVERFLOW;
    }
    private static final int ENOTUNIQ = (int)76L;
    /**
     * {@snippet lang=c :
     * #define ENOTUNIQ 76
     * }
     */
    public static int ENOTUNIQ() {
        return ENOTUNIQ;
    }
    private static final int EBADFD = (int)77L;
    /**
     * {@snippet lang=c :
     * #define EBADFD 77
     * }
     */
    public static int EBADFD() {
        return EBADFD;
    }
    private static final int EREMCHG = (int)78L;
    /**
     * {@snippet lang=c :
     * #define EREMCHG 78
     * }
     */
    public static int EREMCHG() {
        return EREMCHG;
    }
    private static final int ELIBACC = (int)79L;
    /**
     * {@snippet lang=c :
     * #define ELIBACC 79
     * }
     */
    public static int ELIBACC() {
        return ELIBACC;
    }
    private static final int ELIBBAD = (int)80L;
    /**
     * {@snippet lang=c :
     * #define ELIBBAD 80
     * }
     */
    public static int ELIBBAD() {
        return ELIBBAD;
    }
    private static final int ELIBSCN = (int)81L;
    /**
     * {@snippet lang=c :
     * #define ELIBSCN 81
     * }
     */
    public static int ELIBSCN() {
        return ELIBSCN;
    }
    private static final int ELIBMAX = (int)82L;
    /**
     * {@snippet lang=c :
     * #define ELIBMAX 82
     * }
     */
    public static int ELIBMAX() {
        return ELIBMAX;
    }
    private static final int ELIBEXEC = (int)83L;
    /**
     * {@snippet lang=c :
     * #define ELIBEXEC 83
     * }
     */
    public static int ELIBEXEC() {
        return ELIBEXEC;
    }
    private static final int EILSEQ = (int)84L;
    /**
     * {@snippet lang=c :
     * #define EILSEQ 84
     * }
     */
    public static int EILSEQ() {
        return EILSEQ;
    }
    private static final int ERESTART = (int)85L;
    /**
     * {@snippet lang=c :
     * #define ERESTART 85
     * }
     */
    public static int ERESTART() {
        return ERESTART;
    }
    private static final int ESTRPIPE = (int)86L;
    /**
     * {@snippet lang=c :
     * #define ESTRPIPE 86
     * }
     */
    public static int ESTRPIPE() {
        return ESTRPIPE;
    }
    private static final int EUSERS = (int)87L;
    /**
     * {@snippet lang=c :
     * #define EUSERS 87
     * }
     */
    public static int EUSERS() {
        return EUSERS;
    }
    private static final int ENOTSOCK = (int)88L;
    /**
     * {@snippet lang=c :
     * #define ENOTSOCK 88
     * }
     */
    public static int ENOTSOCK() {
        return ENOTSOCK;
    }
    private static final int EDESTADDRREQ = (int)89L;
    /**
     * {@snippet lang=c :
     * #define EDESTADDRREQ 89
     * }
     */
    public static int EDESTADDRREQ() {
        return EDESTADDRREQ;
    }
    private static final int EMSGSIZE = (int)90L;
    /**
     * {@snippet lang=c :
     * #define EMSGSIZE 90
     * }
     */
    public static int EMSGSIZE() {
        return EMSGSIZE;
    }
    private static final int EPROTOTYPE = (int)91L;
    /**
     * {@snippet lang=c :
     * #define EPROTOTYPE 91
     * }
     */
    public static int EPROTOTYPE() {
        return EPROTOTYPE;
    }
    private static final int ENOPROTOOPT = (int)92L;
    /**
     * {@snippet lang=c :
     * #define ENOPROTOOPT 92
     * }
     */
    public static int ENOPROTOOPT() {
        return ENOPROTOOPT;
    }
    private static final int EPROTONOSUPPORT = (int)93L;
    /**
     * {@snippet lang=c :
     * #define EPROTONOSUPPORT 93
     * }
     */
    public static int EPROTONOSUPPORT() {
        return EPROTONOSUPPORT;
    }
    private static final int ESOCKTNOSUPPORT = (int)94L;
    /**
     * {@snippet lang=c :
     * #define ESOCKTNOSUPPORT 94
     * }
     */
    public static int ESOCKTNOSUPPORT() {
        return ESOCKTNOSUPPORT;
    }
    private static final int EOPNOTSUPP = (int)95L;
    /**
     * {@snippet lang=c :
     * #define EOPNOTSUPP 95
     * }
     */
    public static int EOPNOTSUPP() {
        return EOPNOTSUPP;
    }
    private static final int EPFNOSUPPORT = (int)96L;
    /**
     * {@snippet lang=c :
     * #define EPFNOSUPPORT 96
     * }
     */
    public static int EPFNOSUPPORT() {
        return EPFNOSUPPORT;
    }
    private static final int EAFNOSUPPORT = (int)97L;
    /**
     * {@snippet lang=c :
     * #define EAFNOSUPPORT 97
     * }
     */
    public static int EAFNOSUPPORT() {
        return EAFNOSUPPORT;
    }
    private static final int EADDRINUSE = (int)98L;
    /**
     * {@snippet lang=c :
     * #define EADDRINUSE 98
     * }
     */
    public static int EADDRINUSE() {
        return EADDRINUSE;
    }
    private static final int EADDRNOTAVAIL = (int)99L;
    /**
     * {@snippet lang=c :
     * #define EADDRNOTAVAIL 99
     * }
     */
    public static int EADDRNOTAVAIL() {
        return EADDRNOTAVAIL;
    }
    private static final int ENETDOWN = (int)100L;
    /**
     * {@snippet lang=c :
     * #define ENETDOWN 100
     * }
     */
    public static int ENETDOWN() {
        return ENETDOWN;
    }
    private static final int ENETUNREACH = (int)101L;
    /**
     * {@snippet lang=c :
     * #define ENETUNREACH 101
     * }
     */
    public static int ENETUNREACH() {
        return ENETUNREACH;
    }
    private static final int ENETRESET = (int)102L;
    /**
     * {@snippet lang=c :
     * #define ENETRESET 102
     * }
     */
    public static int ENETRESET() {
        return ENETRESET;
    }
    private static final int ECONNABORTED = (int)103L;
    /**
     * {@snippet lang=c :
     * #define ECONNABORTED 103
     * }
     */
    public static int ECONNABORTED() {
        return ECONNABORTED;
    }
    private static final int ECONNRESET = (int)104L;
    /**
     * {@snippet lang=c :
     * #define ECONNRESET 104
     * }
     */
    public static int ECONNRESET() {
        return ECONNRESET;
    }
    private static final int ENOBUFS = (int)105L;
    /**
     * {@snippet lang=c :
     * #define ENOBUFS 105
     * }
     */
    public static int ENOBUFS() {
        return ENOBUFS;
    }
    private static final int EISCONN = (int)106L;
    /**
     * {@snippet lang=c :
     * #define EISCONN 106
     * }
     */
    public static int EISCONN() {
        return EISCONN;
    }
    private static final int ENOTCONN = (int)107L;
    /**
     * {@snippet lang=c :
     * #define ENOTCONN 107
     * }
     */
    public static int ENOTCONN() {
        return ENOTCONN;
    }
    private static final int ESHUTDOWN = (int)108L;
    /**
     * {@snippet lang=c :
     * #define ESHUTDOWN 108
     * }
     */
    public static int ESHUTDOWN() {
        return ESHUTDOWN;
    }
    private static final int ETOOMANYREFS = (int)109L;
    /**
     * {@snippet lang=c :
     * #define ETOOMANYREFS 109
     * }
     */
    public static int ETOOMANYREFS() {
        return ETOOMANYREFS;
    }
    private static final int ETIMEDOUT = (int)110L;
    /**
     * {@snippet lang=c :
     * #define ETIMEDOUT 110
     * }
     */
    public static int ETIMEDOUT() {
        return ETIMEDOUT;
    }
    private static final int ECONNREFUSED = (int)111L;
    /**
     * {@snippet lang=c :
     * #define ECONNREFUSED 111
     * }
     */
    public static int ECONNREFUSED() {
        return ECONNREFUSED;
    }
    private static final int EHOSTDOWN = (int)112L;
    /**
     * {@snippet lang=c :
     * #define EHOSTDOWN 112
     * }
     */
    public static int EHOSTDOWN() {
        return EHOSTDOWN;
    }
    private static final int EHOSTUNREACH = (int)113L;
    /**
     * {@snippet lang=c :
     * #define EHOSTUNREACH 113
     * }
     */
    public static int EHOSTUNREACH() {
        return EHOSTUNREACH;
    }
    private static final int EALREADY = (int)114L;
    /**
     * {@snippet lang=c :
     * #define EALREADY 114
     * }
     */
    public static int EALREADY() {
        return EALREADY;
    }
    private static final int EINPROGRESS = (int)115L;
    /**
     * {@snippet lang=c :
     * #define EINPROGRESS 115
     * }
     */
    public static int EINPROGRESS() {
        return EINPROGRESS;
    }
    private static final int ESTALE = (int)116L;
    /**
     * {@snippet lang=c :
     * #define ESTALE 116
     * }
     */
    public static int ESTALE() {
        return ESTALE;
    }
    private static final int EUCLEAN = (int)117L;
    /**
     * {@snippet lang=c :
     * #define EUCLEAN 117
     * }
     */
    public static int EUCLEAN() {
        return EUCLEAN;
    }
    private static final int ENOTNAM = (int)118L;
    /**
     * {@snippet lang=c :
     * #define ENOTNAM 118
     * }
     */
    public static int ENOTNAM() {
        return ENOTNAM;
    }
    private static final int ENAVAIL = (int)119L;
    /**
     * {@snippet lang=c :
     * #define ENAVAIL 119
     * }
     */
    public static int ENAVAIL() {
        return ENAVAIL;
    }
    private static final int EISNAM = (int)120L;
    /**
     * {@snippet lang=c :
     * #define EISNAM 120
     * }
     */
    public static int EISNAM() {
        return EISNAM;
    }
    private static final int EREMOTEIO = (int)121L;
    /**
     * {@snippet lang=c :
     * #define EREMOTEIO 121
     * }
     */
    public static int EREMOTEIO() {
        return EREMOTEIO;
    }
    private static final int EDQUOT = (int)122L;
    /**
     * {@snippet lang=c :
     * #define EDQUOT 122
     * }
     */
    public static int EDQUOT() {
        return EDQUOT;
    }
    private static final int ENOMEDIUM = (int)123L;
    /**
     * {@snippet lang=c :
     * #define ENOMEDIUM 123
     * }
     */
    public static int ENOMEDIUM() {
        return ENOMEDIUM;
    }
    private static final int EMEDIUMTYPE = (int)124L;
    /**
     * {@snippet lang=c :
     * #define EMEDIUMTYPE 124
     * }
     */
    public static int EMEDIUMTYPE() {
        return EMEDIUMTYPE;
    }
    private static final int ECANCELED = (int)125L;
    /**
     * {@snippet lang=c :
     * #define ECANCELED 125
     * }
     */
    public static int ECANCELED() {
        return ECANCELED;
    }
    private static final int ENOKEY = (int)126L;
    /**
     * {@snippet lang=c :
     * #define ENOKEY 126
     * }
     */
    public static int ENOKEY() {
        return ENOKEY;
    }
    private static final int EKEYEXPIRED = (int)127L;
    /**
     * {@snippet lang=c :
     * #define EKEYEXPIRED 127
     * }
     */
    public static int EKEYEXPIRED() {
        return EKEYEXPIRED;
    }
    private static final int EKEYREVOKED = (int)128L;
    /**
     * {@snippet lang=c :
     * #define EKEYREVOKED 128
     * }
     */
    public static int EKEYREVOKED() {
        return EKEYREVOKED;
    }
    private static final int EKEYREJECTED = (int)129L;
    /**
     * {@snippet lang=c :
     * #define EKEYREJECTED 129
     * }
     */
    public static int EKEYREJECTED() {
        return EKEYREJECTED;
    }
    private static final int EOWNERDEAD = (int)130L;
    /**
     * {@snippet lang=c :
     * #define EOWNERDEAD 130
     * }
     */
    public static int EOWNERDEAD() {
        return EOWNERDEAD;
    }
    private static final int ENOTRECOVERABLE = (int)131L;
    /**
     * {@snippet lang=c :
     * #define ENOTRECOVERABLE 131
     * }
     */
    public static int ENOTRECOVERABLE() {
        return ENOTRECOVERABLE;
    }
    private static final int ERFKILL = (int)132L;
    /**
     * {@snippet lang=c :
     * #define ERFKILL 132
     * }
     */
    public static int ERFKILL() {
        return ERFKILL;
    }
    private static final int EHWPOISON = (int)133L;
    /**
     * {@snippet lang=c :
     * #define EHWPOISON 133
     * }
     */
    public static int EHWPOISON() {
        return EHWPOISON;
    }
    private static final int _STRING_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRING_H 1
     * }
     */
    public static int _STRING_H() {
        return _STRING_H;
    }
    private static final int _STRINGS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRINGS_H 1
     * }
     */
    public static int _STRINGS_H() {
        return _STRINGS_H;
    }
    private static final int IB_USER_VERBS_ABI_VERSION = (int)6L;
    /**
     * {@snippet lang=c :
     * #define IB_USER_VERBS_ABI_VERSION 6
     * }
     */
    public static int IB_USER_VERBS_ABI_VERSION() {
        return IB_USER_VERBS_ABI_VERSION;
    }
    private static final int IB_USER_VERBS_CMD_THRESHOLD = (int)50L;
    /**
     * {@snippet lang=c :
     * #define IB_USER_VERBS_CMD_THRESHOLD 50
     * }
     */
    public static int IB_USER_VERBS_CMD_THRESHOLD() {
        return IB_USER_VERBS_CMD_THRESHOLD;
    }
    private static final int IB_USER_VERBS_CMD_COMMAND_MASK = (int)255L;
    /**
     * {@snippet lang=c :
     * #define IB_USER_VERBS_CMD_COMMAND_MASK 255
     * }
     */
    public static int IB_USER_VERBS_CMD_COMMAND_MASK() {
        return IB_USER_VERBS_CMD_COMMAND_MASK;
    }
    private static final int IB_USER_VERBS_MAX_LOG_IND_TBL_SIZE = (int)13L;
    /**
     * {@snippet lang=c :
     * #define IB_USER_VERBS_MAX_LOG_IND_TBL_SIZE 13
     * }
     */
    public static int IB_USER_VERBS_MAX_LOG_IND_TBL_SIZE() {
        return IB_USER_VERBS_MAX_LOG_IND_TBL_SIZE;
    }
    private static final int IB_DEVICE_NAME_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define IB_DEVICE_NAME_MAX 64
     * }
     */
    public static int IB_DEVICE_NAME_MAX() {
        return IB_DEVICE_NAME_MAX;
    }
    private static final int ETHERNET_LL_SIZE = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ETHERNET_LL_SIZE 6
     * }
     */
    public static int ETHERNET_LL_SIZE() {
        return ETHERNET_LL_SIZE;
    }
    private static final int IBV_PATH_RECORD_REVERSIBLE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define IBV_PATH_RECORD_REVERSIBLE 128
     * }
     */
    public static int IBV_PATH_RECORD_REVERSIBLE() {
        return IBV_PATH_RECORD_REVERSIBLE;
    }
    private static final int RDMA_UDP_QKEY = (int)19088743L;
    /**
     * {@snippet lang=c :
     * #define RDMA_UDP_QKEY 19088743
     * }
     */
    public static int RDMA_UDP_QKEY() {
        return RDMA_UDP_QKEY;
    }
    private static final int RAI_PASSIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RAI_PASSIVE 1
     * }
     */
    public static int RAI_PASSIVE() {
        return RAI_PASSIVE;
    }
    private static final int RAI_NUMERICHOST = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RAI_NUMERICHOST 2
     * }
     */
    public static int RAI_NUMERICHOST() {
        return RAI_NUMERICHOST;
    }
    private static final int RAI_NOROUTE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RAI_NOROUTE 4
     * }
     */
    public static int RAI_NOROUTE() {
        return RAI_NOROUTE;
    }
    private static final int RAI_FAMILY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define RAI_FAMILY 8
     * }
     */
    public static int RAI_FAMILY() {
        return RAI_FAMILY;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = RdmaCm.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = RdmaCm.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = RdmaCm.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = RdmaCm.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = RdmaCm.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = RdmaCm.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = RdmaCm.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = RdmaCm.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = RdmaCm.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = RdmaCm.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = RdmaCm.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = RdmaCm.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = RdmaCm.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = RdmaCm.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = RdmaCm.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = RdmaCm.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = RdmaCm.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = RdmaCm.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = RdmaCm.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = RdmaCm.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = RdmaCm.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = RdmaCm.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = RdmaCm.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = RdmaCm.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __socklen_t socklen_t
     * }
     */
    public static final OfInt socklen_t = RdmaCm.C_INT;
    private static final int SOCK_STREAM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_STREAM = 1
     * }
     */
    public static int SOCK_STREAM() {
        return SOCK_STREAM;
    }
    private static final int SOCK_DGRAM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_DGRAM = 2
     * }
     */
    public static int SOCK_DGRAM() {
        return SOCK_DGRAM;
    }
    private static final int SOCK_RAW = (int)3L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_RAW = 3
     * }
     */
    public static int SOCK_RAW() {
        return SOCK_RAW;
    }
    private static final int SOCK_RDM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_RDM = 4
     * }
     */
    public static int SOCK_RDM() {
        return SOCK_RDM;
    }
    private static final int SOCK_SEQPACKET = (int)5L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_SEQPACKET = 5
     * }
     */
    public static int SOCK_SEQPACKET() {
        return SOCK_SEQPACKET;
    }
    private static final int SOCK_DCCP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_DCCP = 6
     * }
     */
    public static int SOCK_DCCP() {
        return SOCK_DCCP;
    }
    private static final int SOCK_PACKET = (int)10L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_PACKET = 10
     * }
     */
    public static int SOCK_PACKET() {
        return SOCK_PACKET;
    }
    private static final int SOCK_CLOEXEC = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_CLOEXEC = 524288
     * }
     */
    public static int SOCK_CLOEXEC() {
        return SOCK_CLOEXEC;
    }
    private static final int SOCK_NONBLOCK = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_NONBLOCK = 2048
     * }
     */
    public static int SOCK_NONBLOCK() {
        return SOCK_NONBLOCK;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned short sa_family_t
     * }
     */
    public static final OfShort sa_family_t = RdmaCm.C_SHORT;
    private static final int MSG_OOB = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_OOB = 1
     * }
     */
    public static int MSG_OOB() {
        return MSG_OOB;
    }
    private static final int MSG_PEEK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_PEEK = 2
     * }
     */
    public static int MSG_PEEK() {
        return MSG_PEEK;
    }
    private static final int MSG_DONTROUTE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_DONTROUTE = 4
     * }
     */
    public static int MSG_DONTROUTE() {
        return MSG_DONTROUTE;
    }
    private static final int MSG_CTRUNC = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_CTRUNC = 8
     * }
     */
    public static int MSG_CTRUNC() {
        return MSG_CTRUNC;
    }
    private static final int MSG_PROXY = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_PROXY = 16
     * }
     */
    public static int MSG_PROXY() {
        return MSG_PROXY;
    }
    private static final int MSG_TRUNC = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_TRUNC = 32
     * }
     */
    public static int MSG_TRUNC() {
        return MSG_TRUNC;
    }
    private static final int MSG_DONTWAIT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_DONTWAIT = 64
     * }
     */
    public static int MSG_DONTWAIT() {
        return MSG_DONTWAIT;
    }
    private static final int MSG_EOR = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_EOR = 128
     * }
     */
    public static int MSG_EOR() {
        return MSG_EOR;
    }
    private static final int MSG_WAITALL = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_WAITALL = 256
     * }
     */
    public static int MSG_WAITALL() {
        return MSG_WAITALL;
    }
    private static final int MSG_FIN = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_FIN = 512
     * }
     */
    public static int MSG_FIN() {
        return MSG_FIN;
    }
    private static final int MSG_SYN = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_SYN = 1024
     * }
     */
    public static int MSG_SYN() {
        return MSG_SYN;
    }
    private static final int MSG_CONFIRM = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_CONFIRM = 2048
     * }
     */
    public static int MSG_CONFIRM() {
        return MSG_CONFIRM;
    }
    private static final int MSG_RST = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_RST = 4096
     * }
     */
    public static int MSG_RST() {
        return MSG_RST;
    }
    private static final int MSG_ERRQUEUE = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_ERRQUEUE = 8192
     * }
     */
    public static int MSG_ERRQUEUE() {
        return MSG_ERRQUEUE;
    }
    private static final int MSG_NOSIGNAL = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_NOSIGNAL = 16384
     * }
     */
    public static int MSG_NOSIGNAL() {
        return MSG_NOSIGNAL;
    }
    private static final int MSG_MORE = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_MORE = 32768
     * }
     */
    public static int MSG_MORE() {
        return MSG_MORE;
    }
    private static final int MSG_WAITFORONE = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_WAITFORONE = 65536
     * }
     */
    public static int MSG_WAITFORONE() {
        return MSG_WAITFORONE;
    }
    private static final int MSG_BATCH = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_BATCH = 262144
     * }
     */
    public static int MSG_BATCH() {
        return MSG_BATCH;
    }
    private static final int MSG_ZEROCOPY = (int)67108864L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_ZEROCOPY = 67108864
     * }
     */
    public static int MSG_ZEROCOPY() {
        return MSG_ZEROCOPY;
    }
    private static final int MSG_FASTOPEN = (int)536870912L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_FASTOPEN = 536870912
     * }
     */
    public static int MSG_FASTOPEN() {
        return MSG_FASTOPEN;
    }
    private static final int MSG_CMSG_CLOEXEC = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_CMSG_CLOEXEC = 1073741824
     * }
     */
    public static int MSG_CMSG_CLOEXEC() {
        return MSG_CMSG_CLOEXEC;
    }

    private static class __cmsg_nxthdr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("__cmsg_nxthdr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static FunctionDescriptor __cmsg_nxthdr$descriptor() {
        return __cmsg_nxthdr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static MethodHandle __cmsg_nxthdr$handle() {
        return __cmsg_nxthdr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static MemorySegment __cmsg_nxthdr$address() {
        return __cmsg_nxthdr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static MemorySegment __cmsg_nxthdr(MemorySegment __mhdr, MemorySegment __cmsg) {
        var mh$ = __cmsg_nxthdr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cmsg_nxthdr", __mhdr, __cmsg);
            }
            return (MemorySegment)mh$.invokeExact(__mhdr, __cmsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SCM_RIGHTS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCM_RIGHTS = 1
     * }
     */
    public static int SCM_RIGHTS() {
        return SCM_RIGHTS;
    }
    /**
     * {@snippet lang=c :
     * typedef int __kernel_key_t
     * }
     */
    public static final OfInt __kernel_key_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_mqd_t
     * }
     */
    public static final OfInt __kernel_mqd_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_old_uid_t
     * }
     */
    public static final OfShort __kernel_old_uid_t = RdmaCm.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_old_gid_t
     * }
     */
    public static final OfShort __kernel_old_gid_t = RdmaCm.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __kernel_old_dev_t
     * }
     */
    public static final OfLong __kernel_old_dev_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __kernel_long_t
     * }
     */
    public static final OfLong __kernel_long_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __kernel_ulong_t
     * }
     */
    public static final OfLong __kernel_ulong_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_ulong_t __kernel_ino_t
     * }
     */
    public static final OfLong __kernel_ino_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_mode_t
     * }
     */
    public static final OfInt __kernel_mode_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_pid_t
     * }
     */
    public static final OfInt __kernel_pid_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_ipc_pid_t
     * }
     */
    public static final OfInt __kernel_ipc_pid_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_uid_t
     * }
     */
    public static final OfInt __kernel_uid_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_gid_t
     * }
     */
    public static final OfInt __kernel_gid_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_suseconds_t
     * }
     */
    public static final OfLong __kernel_suseconds_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_daddr_t
     * }
     */
    public static final OfInt __kernel_daddr_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_uid32_t
     * }
     */
    public static final OfInt __kernel_uid32_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_gid32_t
     * }
     */
    public static final OfInt __kernel_gid32_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __kernel_ulong_t __kernel_size_t
     * }
     */
    public static final OfLong __kernel_size_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_ssize_t
     * }
     */
    public static final OfLong __kernel_ssize_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_ptrdiff_t
     * }
     */
    public static final OfLong __kernel_ptrdiff_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_off_t
     * }
     */
    public static final OfLong __kernel_off_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __kernel_loff_t
     * }
     */
    public static final OfLong __kernel_loff_t = RdmaCm.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_old_time_t
     * }
     */
    public static final OfLong __kernel_old_time_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_time_t
     * }
     */
    public static final OfLong __kernel_time_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __kernel_time64_t
     * }
     */
    public static final OfLong __kernel_time64_t = RdmaCm.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_clock_t
     * }
     */
    public static final OfLong __kernel_clock_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_timer_t
     * }
     */
    public static final OfInt __kernel_timer_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_clockid_t
     * }
     */
    public static final OfInt __kernel_clockid_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef char *__kernel_caddr_t
     * }
     */
    public static final AddressLayout __kernel_caddr_t = RdmaCm.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_uid16_t
     * }
     */
    public static final OfShort __kernel_uid16_t = RdmaCm.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_gid16_t
     * }
     */
    public static final OfShort __kernel_gid16_t = RdmaCm.C_SHORT;
    private static final int SHUT_RD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHUT_RD = 0
     * }
     */
    public static int SHUT_RD() {
        return SHUT_RD;
    }
    private static final int SHUT_WR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHUT_WR = 1
     * }
     */
    public static int SHUT_WR() {
        return SHUT_WR;
    }
    private static final int SHUT_RDWR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHUT_RDWR = 2
     * }
     */
    public static int SHUT_RDWR() {
        return SHUT_RDWR;
    }

    private static class socket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("socket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static FunctionDescriptor socket$descriptor() {
        return socket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static MethodHandle socket$handle() {
        return socket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static MemorySegment socket$address() {
        return socket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static int socket(int __domain, int __type, int __protocol) {
        var mh$ = socket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socket", __domain, __type, __protocol);
            }
            return (int)mh$.invokeExact(__domain, __type, __protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class socketpair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("socketpair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static FunctionDescriptor socketpair$descriptor() {
        return socketpair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static MethodHandle socketpair$handle() {
        return socketpair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static MemorySegment socketpair$address() {
        return socketpair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static int socketpair(int __domain, int __type, int __protocol, MemorySegment __fds) {
        var mh$ = socketpair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socketpair", __domain, __type, __protocol, __fds);
            }
            return (int)mh$.invokeExact(__domain, __type, __protocol, __fds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("bind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static FunctionDescriptor bind$descriptor() {
        return bind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MethodHandle bind$handle() {
        return bind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MemorySegment bind$address() {
        return bind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static int bind(int __fd, MemorySegment __addr, int __len) {
        var mh$ = bind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bind", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("getsockname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static FunctionDescriptor getsockname$descriptor() {
        return getsockname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MethodHandle getsockname$handle() {
        return getsockname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MemorySegment getsockname$address() {
        return getsockname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static int getsockname(int __fd, MemorySegment __addr, MemorySegment __len) {
        var mh$ = getsockname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockname", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class connect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("connect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static FunctionDescriptor connect$descriptor() {
        return connect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MethodHandle connect$handle() {
        return connect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MemorySegment connect$address() {
        return connect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static int connect(int __fd, MemorySegment __addr, int __len) {
        var mh$ = connect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("connect", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpeername {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("getpeername");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static FunctionDescriptor getpeername$descriptor() {
        return getpeername.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MethodHandle getpeername$handle() {
        return getpeername.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MemorySegment getpeername$address() {
        return getpeername.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static int getpeername(int __fd, MemorySegment __addr, MemorySegment __len) {
        var mh$ = getpeername.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpeername", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class send {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_LONG,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("send");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static FunctionDescriptor send$descriptor() {
        return send.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static MethodHandle send$handle() {
        return send.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static MemorySegment send$address() {
        return send.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static long send(int __fd, MemorySegment __buf, long __n, int __flags) {
        var mh$ = send.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("send", __fd, __buf, __n, __flags);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_LONG,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("recv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static FunctionDescriptor recv$descriptor() {
        return recv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static MethodHandle recv$handle() {
        return recv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static MemorySegment recv$address() {
        return recv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static long recv(int __fd, MemorySegment __buf, long __n, int __flags) {
        var mh$ = recv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recv", __fd, __buf, __n, __flags);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_LONG,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("sendto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static FunctionDescriptor sendto$descriptor() {
        return sendto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static MethodHandle sendto$handle() {
        return sendto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static MemorySegment sendto$address() {
        return sendto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static long sendto(int __fd, MemorySegment __buf, long __n, int __flags, MemorySegment __addr, int __addr_len) {
        var mh$ = sendto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendto", __fd, __buf, __n, __flags, __addr, __addr_len);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags, __addr, __addr_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvfrom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_LONG,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("recvfrom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static FunctionDescriptor recvfrom$descriptor() {
        return recvfrom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MethodHandle recvfrom$handle() {
        return recvfrom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MemorySegment recvfrom$address() {
        return recvfrom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static long recvfrom(int __fd, MemorySegment __buf, long __n, int __flags, MemorySegment __addr, MemorySegment __addr_len) {
        var mh$ = recvfrom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvfrom", __fd, __buf, __n, __flags, __addr, __addr_len);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags, __addr, __addr_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendmsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("sendmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static FunctionDescriptor sendmsg$descriptor() {
        return sendmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static MethodHandle sendmsg$handle() {
        return sendmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static MemorySegment sendmsg$address() {
        return sendmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static long sendmsg(int __fd, MemorySegment __message, int __flags) {
        var mh$ = sendmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendmsg", __fd, __message, __flags);
            }
            return (long)mh$.invokeExact(__fd, __message, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvmsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("recvmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static FunctionDescriptor recvmsg$descriptor() {
        return recvmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static MethodHandle recvmsg$handle() {
        return recvmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static MemorySegment recvmsg$address() {
        return recvmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static long recvmsg(int __fd, MemorySegment __message, int __flags) {
        var mh$ = recvmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvmsg", __fd, __message, __flags);
            }
            return (long)mh$.invokeExact(__fd, __message, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("getsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static FunctionDescriptor getsockopt$descriptor() {
        return getsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static MethodHandle getsockopt$handle() {
        return getsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static MemorySegment getsockopt$address() {
        return getsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static int getsockopt(int __fd, int __level, int __optname, MemorySegment __optval, MemorySegment __optlen) {
        var mh$ = getsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockopt", __fd, __level, __optname, __optval, __optlen);
            }
            return (int)mh$.invokeExact(__fd, __level, __optname, __optval, __optlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("setsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static FunctionDescriptor setsockopt$descriptor() {
        return setsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static MethodHandle setsockopt$handle() {
        return setsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static MemorySegment setsockopt$address() {
        return setsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static int setsockopt(int __fd, int __level, int __optname, MemorySegment __optval, int __optlen) {
        var mh$ = setsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsockopt", __fd, __level, __optname, __optval, __optlen);
            }
            return (int)mh$.invokeExact(__fd, __level, __optname, __optval, __optlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class listen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("listen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static FunctionDescriptor listen$descriptor() {
        return listen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static MethodHandle listen$handle() {
        return listen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static MemorySegment listen$address() {
        return listen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static int listen(int __fd, int __n) {
        var mh$ = listen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("listen", __fd, __n);
            }
            return (int)mh$.invokeExact(__fd, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class accept {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("accept");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static FunctionDescriptor accept$descriptor() {
        return accept.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MethodHandle accept$handle() {
        return accept.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MemorySegment accept$address() {
        return accept.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static int accept(int __fd, MemorySegment __addr, MemorySegment __addr_len) {
        var mh$ = accept.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("accept", __fd, __addr, __addr_len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __addr_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("shutdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static FunctionDescriptor shutdown$descriptor() {
        return shutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static MethodHandle shutdown$handle() {
        return shutdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static MemorySegment shutdown$address() {
        return shutdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static int shutdown(int __fd, int __how) {
        var mh$ = shutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shutdown", __fd, __how);
            }
            return (int)mh$.invokeExact(__fd, __how);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sockatmark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("sockatmark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static FunctionDescriptor sockatmark$descriptor() {
        return sockatmark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static MethodHandle sockatmark$handle() {
        return sockatmark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static MemorySegment sockatmark$address() {
        return sockatmark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static int sockatmark(int __fd) {
        var mh$ = sockatmark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sockatmark", __fd);
            }
            return (int)mh$.invokeExact(__fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isfdtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("isfdtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static FunctionDescriptor isfdtype$descriptor() {
        return isfdtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static MethodHandle isfdtype$handle() {
        return isfdtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static MemorySegment isfdtype$address() {
        return isfdtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static int isfdtype(int __fd, int __fdtype) {
        var mh$ = isfdtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isfdtype", __fd, __fdtype);
            }
            return (int)mh$.invokeExact(__fd, __fdtype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t in_addr_t
     * }
     */
    public static final OfInt in_addr_t = RdmaCm.C_INT;
    private static final int IPPROTO_IP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_IP = 0
     * }
     */
    public static int IPPROTO_IP() {
        return IPPROTO_IP;
    }
    private static final int IPPROTO_ICMP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ICMP = 1
     * }
     */
    public static int IPPROTO_ICMP() {
        return IPPROTO_ICMP;
    }
    private static final int IPPROTO_IGMP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_IGMP = 2
     * }
     */
    public static int IPPROTO_IGMP() {
        return IPPROTO_IGMP;
    }
    private static final int IPPROTO_IPIP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_IPIP = 4
     * }
     */
    public static int IPPROTO_IPIP() {
        return IPPROTO_IPIP;
    }
    private static final int IPPROTO_TCP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_TCP = 6
     * }
     */
    public static int IPPROTO_TCP() {
        return IPPROTO_TCP;
    }
    private static final int IPPROTO_EGP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_EGP = 8
     * }
     */
    public static int IPPROTO_EGP() {
        return IPPROTO_EGP;
    }
    private static final int IPPROTO_PUP = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_PUP = 12
     * }
     */
    public static int IPPROTO_PUP() {
        return IPPROTO_PUP;
    }
    private static final int IPPROTO_UDP = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_UDP = 17
     * }
     */
    public static int IPPROTO_UDP() {
        return IPPROTO_UDP;
    }
    private static final int IPPROTO_IDP = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_IDP = 22
     * }
     */
    public static int IPPROTO_IDP() {
        return IPPROTO_IDP;
    }
    private static final int IPPROTO_TP = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_TP = 29
     * }
     */
    public static int IPPROTO_TP() {
        return IPPROTO_TP;
    }
    private static final int IPPROTO_DCCP = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_DCCP = 33
     * }
     */
    public static int IPPROTO_DCCP() {
        return IPPROTO_DCCP;
    }
    private static final int IPPROTO_IPV6 = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_IPV6 = 41
     * }
     */
    public static int IPPROTO_IPV6() {
        return IPPROTO_IPV6;
    }
    private static final int IPPROTO_RSVP = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_RSVP = 46
     * }
     */
    public static int IPPROTO_RSVP() {
        return IPPROTO_RSVP;
    }
    private static final int IPPROTO_GRE = (int)47L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_GRE = 47
     * }
     */
    public static int IPPROTO_GRE() {
        return IPPROTO_GRE;
    }
    private static final int IPPROTO_ESP = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ESP = 50
     * }
     */
    public static int IPPROTO_ESP() {
        return IPPROTO_ESP;
    }
    private static final int IPPROTO_AH = (int)51L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_AH = 51
     * }
     */
    public static int IPPROTO_AH() {
        return IPPROTO_AH;
    }
    private static final int IPPROTO_MTP = (int)92L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_MTP = 92
     * }
     */
    public static int IPPROTO_MTP() {
        return IPPROTO_MTP;
    }
    private static final int IPPROTO_BEETPH = (int)94L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_BEETPH = 94
     * }
     */
    public static int IPPROTO_BEETPH() {
        return IPPROTO_BEETPH;
    }
    private static final int IPPROTO_ENCAP = (int)98L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ENCAP = 98
     * }
     */
    public static int IPPROTO_ENCAP() {
        return IPPROTO_ENCAP;
    }
    private static final int IPPROTO_PIM = (int)103L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_PIM = 103
     * }
     */
    public static int IPPROTO_PIM() {
        return IPPROTO_PIM;
    }
    private static final int IPPROTO_COMP = (int)108L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_COMP = 108
     * }
     */
    public static int IPPROTO_COMP() {
        return IPPROTO_COMP;
    }
    private static final int IPPROTO_SCTP = (int)132L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_SCTP = 132
     * }
     */
    public static int IPPROTO_SCTP() {
        return IPPROTO_SCTP;
    }
    private static final int IPPROTO_UDPLITE = (int)136L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_UDPLITE = 136
     * }
     */
    public static int IPPROTO_UDPLITE() {
        return IPPROTO_UDPLITE;
    }
    private static final int IPPROTO_MPLS = (int)137L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_MPLS = 137
     * }
     */
    public static int IPPROTO_MPLS() {
        return IPPROTO_MPLS;
    }
    private static final int IPPROTO_ETHERNET = (int)143L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ETHERNET = 143
     * }
     */
    public static int IPPROTO_ETHERNET() {
        return IPPROTO_ETHERNET;
    }
    private static final int IPPROTO_RAW = (int)255L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_RAW = 255
     * }
     */
    public static int IPPROTO_RAW() {
        return IPPROTO_RAW;
    }
    private static final int IPPROTO_MPTCP = (int)262L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_MPTCP = 262
     * }
     */
    public static int IPPROTO_MPTCP() {
        return IPPROTO_MPTCP;
    }
    private static final int IPPROTO_MAX = (int)263L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_MAX = 263
     * }
     */
    public static int IPPROTO_MAX() {
        return IPPROTO_MAX;
    }
    private static final int IPPROTO_HOPOPTS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_HOPOPTS = 0
     * }
     */
    public static int IPPROTO_HOPOPTS() {
        return IPPROTO_HOPOPTS;
    }
    private static final int IPPROTO_ROUTING = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ROUTING = 43
     * }
     */
    public static int IPPROTO_ROUTING() {
        return IPPROTO_ROUTING;
    }
    private static final int IPPROTO_FRAGMENT = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_FRAGMENT = 44
     * }
     */
    public static int IPPROTO_FRAGMENT() {
        return IPPROTO_FRAGMENT;
    }
    private static final int IPPROTO_ICMPV6 = (int)58L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ICMPV6 = 58
     * }
     */
    public static int IPPROTO_ICMPV6() {
        return IPPROTO_ICMPV6;
    }
    private static final int IPPROTO_NONE = (int)59L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_NONE = 59
     * }
     */
    public static int IPPROTO_NONE() {
        return IPPROTO_NONE;
    }
    private static final int IPPROTO_DSTOPTS = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_DSTOPTS = 60
     * }
     */
    public static int IPPROTO_DSTOPTS() {
        return IPPROTO_DSTOPTS;
    }
    private static final int IPPROTO_MH = (int)135L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_MH = 135
     * }
     */
    public static int IPPROTO_MH() {
        return IPPROTO_MH;
    }
    /**
     * {@snippet lang=c :
     * typedef uint16_t in_port_t
     * }
     */
    public static final OfShort in_port_t = RdmaCm.C_SHORT;
    private static final int IPPORT_ECHO = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_ECHO = 7
     * }
     */
    public static int IPPORT_ECHO() {
        return IPPORT_ECHO;
    }
    private static final int IPPORT_DISCARD = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_DISCARD = 9
     * }
     */
    public static int IPPORT_DISCARD() {
        return IPPORT_DISCARD;
    }
    private static final int IPPORT_SYSTAT = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_SYSTAT = 11
     * }
     */
    public static int IPPORT_SYSTAT() {
        return IPPORT_SYSTAT;
    }
    private static final int IPPORT_DAYTIME = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_DAYTIME = 13
     * }
     */
    public static int IPPORT_DAYTIME() {
        return IPPORT_DAYTIME;
    }
    private static final int IPPORT_NETSTAT = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_NETSTAT = 15
     * }
     */
    public static int IPPORT_NETSTAT() {
        return IPPORT_NETSTAT;
    }
    private static final int IPPORT_FTP = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_FTP = 21
     * }
     */
    public static int IPPORT_FTP() {
        return IPPORT_FTP;
    }
    private static final int IPPORT_TELNET = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_TELNET = 23
     * }
     */
    public static int IPPORT_TELNET() {
        return IPPORT_TELNET;
    }
    private static final int IPPORT_SMTP = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_SMTP = 25
     * }
     */
    public static int IPPORT_SMTP() {
        return IPPORT_SMTP;
    }
    private static final int IPPORT_TIMESERVER = (int)37L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_TIMESERVER = 37
     * }
     */
    public static int IPPORT_TIMESERVER() {
        return IPPORT_TIMESERVER;
    }
    private static final int IPPORT_NAMESERVER = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_NAMESERVER = 42
     * }
     */
    public static int IPPORT_NAMESERVER() {
        return IPPORT_NAMESERVER;
    }
    private static final int IPPORT_WHOIS = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_WHOIS = 43
     * }
     */
    public static int IPPORT_WHOIS() {
        return IPPORT_WHOIS;
    }
    private static final int IPPORT_MTP = (int)57L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_MTP = 57
     * }
     */
    public static int IPPORT_MTP() {
        return IPPORT_MTP;
    }
    private static final int IPPORT_TFTP = (int)69L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_TFTP = 69
     * }
     */
    public static int IPPORT_TFTP() {
        return IPPORT_TFTP;
    }
    private static final int IPPORT_RJE = (int)77L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_RJE = 77
     * }
     */
    public static int IPPORT_RJE() {
        return IPPORT_RJE;
    }
    private static final int IPPORT_FINGER = (int)79L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_FINGER = 79
     * }
     */
    public static int IPPORT_FINGER() {
        return IPPORT_FINGER;
    }
    private static final int IPPORT_TTYLINK = (int)87L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_TTYLINK = 87
     * }
     */
    public static int IPPORT_TTYLINK() {
        return IPPORT_TTYLINK;
    }
    private static final int IPPORT_SUPDUP = (int)95L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_SUPDUP = 95
     * }
     */
    public static int IPPORT_SUPDUP() {
        return IPPORT_SUPDUP;
    }
    private static final int IPPORT_EXECSERVER = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_EXECSERVER = 512
     * }
     */
    public static int IPPORT_EXECSERVER() {
        return IPPORT_EXECSERVER;
    }
    private static final int IPPORT_LOGINSERVER = (int)513L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_LOGINSERVER = 513
     * }
     */
    public static int IPPORT_LOGINSERVER() {
        return IPPORT_LOGINSERVER;
    }
    private static final int IPPORT_CMDSERVER = (int)514L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_CMDSERVER = 514
     * }
     */
    public static int IPPORT_CMDSERVER() {
        return IPPORT_CMDSERVER;
    }
    private static final int IPPORT_EFSSERVER = (int)520L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_EFSSERVER = 520
     * }
     */
    public static int IPPORT_EFSSERVER() {
        return IPPORT_EFSSERVER;
    }
    private static final int IPPORT_BIFFUDP = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_BIFFUDP = 512
     * }
     */
    public static int IPPORT_BIFFUDP() {
        return IPPORT_BIFFUDP;
    }
    private static final int IPPORT_WHOSERVER = (int)513L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_WHOSERVER = 513
     * }
     */
    public static int IPPORT_WHOSERVER() {
        return IPPORT_WHOSERVER;
    }
    private static final int IPPORT_ROUTESERVER = (int)520L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_ROUTESERVER = 520
     * }
     */
    public static int IPPORT_ROUTESERVER() {
        return IPPORT_ROUTESERVER;
    }
    private static final int IPPORT_RESERVED = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_RESERVED = 1024
     * }
     */
    public static int IPPORT_RESERVED() {
        return IPPORT_RESERVED;
    }
    private static final int IPPORT_USERRESERVED = (int)5000L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_USERRESERVED = 5000
     * }
     */
    public static int IPPORT_USERRESERVED() {
        return IPPORT_USERRESERVED;
    }

    private static class in6addr_any$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT = RdmaCm.findOrThrow("in6addr_any").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_any
     * }
     */
    public static GroupLayout in6addr_any$layout() {
        return in6addr_any$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_any
     * }
     */
    public static MemorySegment in6addr_any() {
        return in6addr_any$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_any
     * }
     */
    public static void in6addr_any(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, in6addr_any$constants.SEGMENT, 0L, in6addr_any$constants.LAYOUT.byteSize());
    }

    private static class in6addr_loopback$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT = RdmaCm.findOrThrow("in6addr_loopback").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_loopback
     * }
     */
    public static GroupLayout in6addr_loopback$layout() {
        return in6addr_loopback$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_loopback
     * }
     */
    public static MemorySegment in6addr_loopback() {
        return in6addr_loopback$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_loopback
     * }
     */
    public static void in6addr_loopback(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, in6addr_loopback$constants.SEGMENT, 0L, in6addr_loopback$constants.LAYOUT.byteSize());
    }

    private static class ntohl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("ntohl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uint32_t ntohl(uint32_t __netlong)
     * }
     */
    public static FunctionDescriptor ntohl$descriptor() {
        return ntohl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uint32_t ntohl(uint32_t __netlong)
     * }
     */
    public static MethodHandle ntohl$handle() {
        return ntohl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uint32_t ntohl(uint32_t __netlong)
     * }
     */
    public static MemorySegment ntohl$address() {
        return ntohl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uint32_t ntohl(uint32_t __netlong)
     * }
     */
    public static int ntohl(int __netlong) {
        var mh$ = ntohl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ntohl", __netlong);
            }
            return (int)mh$.invokeExact(__netlong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ntohs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_SHORT,
            RdmaCm.C_SHORT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("ntohs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uint16_t ntohs(uint16_t __netshort)
     * }
     */
    public static FunctionDescriptor ntohs$descriptor() {
        return ntohs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uint16_t ntohs(uint16_t __netshort)
     * }
     */
    public static MethodHandle ntohs$handle() {
        return ntohs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uint16_t ntohs(uint16_t __netshort)
     * }
     */
    public static MemorySegment ntohs$address() {
        return ntohs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uint16_t ntohs(uint16_t __netshort)
     * }
     */
    public static short ntohs(short __netshort) {
        var mh$ = ntohs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ntohs", __netshort);
            }
            return (short)mh$.invokeExact(__netshort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class htonl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("htonl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uint32_t htonl(uint32_t __hostlong)
     * }
     */
    public static FunctionDescriptor htonl$descriptor() {
        return htonl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uint32_t htonl(uint32_t __hostlong)
     * }
     */
    public static MethodHandle htonl$handle() {
        return htonl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uint32_t htonl(uint32_t __hostlong)
     * }
     */
    public static MemorySegment htonl$address() {
        return htonl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uint32_t htonl(uint32_t __hostlong)
     * }
     */
    public static int htonl(int __hostlong) {
        var mh$ = htonl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("htonl", __hostlong);
            }
            return (int)mh$.invokeExact(__hostlong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class htons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_SHORT,
            RdmaCm.C_SHORT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("htons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uint16_t htons(uint16_t __hostshort)
     * }
     */
    public static FunctionDescriptor htons$descriptor() {
        return htons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uint16_t htons(uint16_t __hostshort)
     * }
     */
    public static MethodHandle htons$handle() {
        return htons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uint16_t htons(uint16_t __hostshort)
     * }
     */
    public static MemorySegment htons$address() {
        return htons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uint16_t htons(uint16_t __hostshort)
     * }
     */
    public static short htons(short __hostshort) {
        var mh$ = htons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("htons", __hostshort);
            }
            return (short)mh$.invokeExact(__hostshort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bindresvport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("bindresvport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bindresvport(int __sockfd, struct sockaddr_in *__sock_in)
     * }
     */
    public static FunctionDescriptor bindresvport$descriptor() {
        return bindresvport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bindresvport(int __sockfd, struct sockaddr_in *__sock_in)
     * }
     */
    public static MethodHandle bindresvport$handle() {
        return bindresvport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bindresvport(int __sockfd, struct sockaddr_in *__sock_in)
     * }
     */
    public static MemorySegment bindresvport$address() {
        return bindresvport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bindresvport(int __sockfd, struct sockaddr_in *__sock_in)
     * }
     */
    public static int bindresvport(int __sockfd, MemorySegment __sock_in) {
        var mh$ = bindresvport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bindresvport", __sockfd, __sock_in);
            }
            return (int)mh$.invokeExact(__sockfd, __sock_in);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bindresvport6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("bindresvport6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bindresvport6(int __sockfd, struct sockaddr_in6 *__sock_in)
     * }
     */
    public static FunctionDescriptor bindresvport6$descriptor() {
        return bindresvport6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bindresvport6(int __sockfd, struct sockaddr_in6 *__sock_in)
     * }
     */
    public static MethodHandle bindresvport6$handle() {
        return bindresvport6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bindresvport6(int __sockfd, struct sockaddr_in6 *__sock_in)
     * }
     */
    public static MemorySegment bindresvport6$address() {
        return bindresvport6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bindresvport6(int __sockfd, struct sockaddr_in6 *__sock_in)
     * }
     */
    public static int bindresvport6(int __sockfd, MemorySegment __sock_in) {
        var mh$ = bindresvport6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bindresvport6", __sockfd, __sock_in);
            }
            return (int)mh$.invokeExact(__sockfd, __sock_in);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = RdmaCm.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = RdmaCm.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = RdmaCm.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = RdmaCm.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = RdmaCm.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = RdmaCm.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = RdmaCm.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = RdmaCm.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __cpu_mask
     * }
     */
    public static final OfLong __cpu_mask = RdmaCm.C_LONG;

    private static class __sched_cpucount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_LONG,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("__sched_cpucount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static FunctionDescriptor __sched_cpucount$descriptor() {
        return __sched_cpucount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static MethodHandle __sched_cpucount$handle() {
        return __sched_cpucount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static MemorySegment __sched_cpucount$address() {
        return __sched_cpucount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp)
     * }
     */
    public static int __sched_cpucount(long __setsize, MemorySegment __setp) {
        var mh$ = __sched_cpucount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpucount", __setsize, __setp);
            }
            return (int)mh$.invokeExact(__setsize, __setp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sched_cpualloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_POINTER,
            RdmaCm.C_LONG
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("__sched_cpualloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static FunctionDescriptor __sched_cpualloc$descriptor() {
        return __sched_cpualloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MethodHandle __sched_cpualloc$handle() {
        return __sched_cpualloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MemorySegment __sched_cpualloc$address() {
        return __sched_cpualloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cpu_set_t *__sched_cpualloc(size_t __count)
     * }
     */
    public static MemorySegment __sched_cpualloc(long __count) {
        var mh$ = __sched_cpualloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpualloc", __count);
            }
            return (MemorySegment)mh$.invokeExact(__count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sched_cpufree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("__sched_cpufree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static FunctionDescriptor __sched_cpufree$descriptor() {
        return __sched_cpufree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static MethodHandle __sched_cpufree$handle() {
        return __sched_cpufree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static MemorySegment __sched_cpufree$address() {
        return __sched_cpufree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __sched_cpufree(cpu_set_t *__set)
     * }
     */
    public static void __sched_cpufree(MemorySegment __set) {
        var mh$ = __sched_cpufree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sched_cpufree", __set);
            }
            mh$.invokeExact(__set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_setparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("sched_setparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_setparam$descriptor() {
        return sched_setparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_setparam$handle() {
        return sched_setparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_setparam$address() {
        return sched_setparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_setparam(__pid_t __pid, const struct sched_param *__param)
     * }
     */
    public static int sched_setparam(int __pid, MemorySegment __param) {
        var mh$ = sched_setparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_setparam", __pid, __param);
            }
            return (int)mh$.invokeExact(__pid, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_getparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("sched_getparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_getparam$descriptor() {
        return sched_getparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_getparam$handle() {
        return sched_getparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_getparam$address() {
        return sched_getparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_getparam(__pid_t __pid, struct sched_param *__param)
     * }
     */
    public static int sched_getparam(int __pid, MemorySegment __param) {
        var mh$ = sched_getparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_getparam", __pid, __param);
            }
            return (int)mh$.invokeExact(__pid, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_setscheduler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("sched_setscheduler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor sched_setscheduler$descriptor() {
        return sched_setscheduler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static MethodHandle sched_setscheduler$handle() {
        return sched_setscheduler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static MemorySegment sched_setscheduler$address() {
        return sched_setscheduler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param)
     * }
     */
    public static int sched_setscheduler(int __pid, int __policy, MemorySegment __param) {
        var mh$ = sched_setscheduler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_setscheduler", __pid, __policy, __param);
            }
            return (int)mh$.invokeExact(__pid, __policy, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_getscheduler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("sched_getscheduler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static FunctionDescriptor sched_getscheduler$descriptor() {
        return sched_getscheduler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static MethodHandle sched_getscheduler$handle() {
        return sched_getscheduler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static MemorySegment sched_getscheduler$address() {
        return sched_getscheduler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_getscheduler(__pid_t __pid)
     * }
     */
    public static int sched_getscheduler(int __pid) {
        var mh$ = sched_getscheduler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_getscheduler", __pid);
            }
            return (int)mh$.invokeExact(__pid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_yield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT    );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("sched_yield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static FunctionDescriptor sched_yield$descriptor() {
        return sched_yield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MethodHandle sched_yield$handle() {
        return sched_yield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MemorySegment sched_yield$address() {
        return sched_yield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static int sched_yield() {
        var mh$ = sched_yield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_yield");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("sched_get_priority_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static FunctionDescriptor sched_get_priority_max$descriptor() {
        return sched_get_priority_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static MethodHandle sched_get_priority_max$handle() {
        return sched_get_priority_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static MemorySegment sched_get_priority_max$address() {
        return sched_get_priority_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int __algorithm)
     * }
     */
    public static int sched_get_priority_max(int __algorithm) {
        var mh$ = sched_get_priority_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_max", __algorithm);
            }
            return (int)mh$.invokeExact(__algorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("sched_get_priority_min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static FunctionDescriptor sched_get_priority_min$descriptor() {
        return sched_get_priority_min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static MethodHandle sched_get_priority_min$handle() {
        return sched_get_priority_min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static MemorySegment sched_get_priority_min$address() {
        return sched_get_priority_min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int __algorithm)
     * }
     */
    public static int sched_get_priority_min(int __algorithm) {
        var mh$ = sched_get_priority_min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_min", __algorithm);
            }
            return (int)mh$.invokeExact(__algorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_rr_get_interval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("sched_rr_get_interval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static FunctionDescriptor sched_rr_get_interval$descriptor() {
        return sched_rr_get_interval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static MethodHandle sched_rr_get_interval$handle() {
        return sched_rr_get_interval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static MemorySegment sched_rr_get_interval$address() {
        return sched_rr_get_interval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t)
     * }
     */
    public static int sched_rr_get_interval(int __pid, MemorySegment __t) {
        var mh$ = sched_rr_get_interval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_rr_get_interval", __pid, __t);
            }
            return (int)mh$.invokeExact(__pid, __t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = RdmaCm.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = RdmaCm.C_POINTER;

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG    );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static long time(MemorySegment __timer) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", __timer);
            }
            return (long)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_DOUBLE,
            RdmaCm.C_LONG,
            RdmaCm.C_LONG
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static double difftime(long __time1, long __time0) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", __time1, __time0);
            }
            return (double)mh$.invokeExact(__time1, __time0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static long mktime(MemorySegment __tp) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG,
            RdmaCm.C_POINTER,
            RdmaCm.C_LONG,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static long strftime(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", __s, __maxsize, __format, __tp);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG,
            RdmaCm.C_POINTER,
            RdmaCm.C_LONG,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("strftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strftime_l$descriptor() {
        return strftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MethodHandle strftime_l$handle() {
        return strftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MemorySegment strftime_l$address() {
        return strftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static long strftime_l(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp, MemorySegment __loc) {
        var mh$ = strftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime_l", __s, __maxsize, __format, __tp, __loc);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime(MemorySegment __timer) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime(MemorySegment __timer) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime(MemorySegment __tp) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", __tp);
            }
            return (MemorySegment)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime(MemorySegment __timer) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment __tp, MemorySegment __buf) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", __tp, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__tp, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment __timer, MemorySegment __buf) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", __timer, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, RdmaCm.C_POINTER);
        public static final MemorySegment SEGMENT = RdmaCm.findOrThrow("__tzname").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static SequenceLayout __tzname$layout() {
        return __tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static long[] __tzname$dimensions() {
        return __tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname() {
        return __tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, __tzname$constants.SEGMENT, 0L, __tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname(long index0) {
        return (MemorySegment)__tzname$constants.HANDLE.get(__tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(long index0, MemorySegment varValue) {
        __tzname$constants.HANDLE.set(__tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class __daylight$constants {
        public static final OfInt LAYOUT = RdmaCm.C_INT;
        public static final MemorySegment SEGMENT = RdmaCm.findOrThrow("__daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static OfInt __daylight$layout() {
        return __daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static MemorySegment __daylight$segment() {
        return __daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static int __daylight() {
        return __daylight$constants.SEGMENT.get(__daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static void __daylight(int varValue) {
        __daylight$constants.SEGMENT.set(__daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class __timezone$constants {
        public static final OfLong LAYOUT = RdmaCm.C_LONG;
        public static final MemorySegment SEGMENT = RdmaCm.findOrThrow("__timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static OfLong __timezone$layout() {
        return __timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static MemorySegment __timezone$segment() {
        return __timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static long __timezone() {
        return __timezone$constants.SEGMENT.get(__timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static void __timezone(long varValue) {
        __timezone$constants.SEGMENT.set(__timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, RdmaCm.C_POINTER);
        public static final MemorySegment SEGMENT = RdmaCm.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname(long index0) {
        return (MemorySegment)tzname$constants.HANDLE.get(tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(long index0, MemorySegment varValue) {
        tzname$constants.HANDLE.set(tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = RdmaCm.C_INT;
        public static final MemorySegment SEGMENT = RdmaCm.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = RdmaCm.C_LONG;
        public static final MemorySegment SEGMENT = RdmaCm.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static long timegm(MemorySegment __tp) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static long timelocal(MemorySegment __tp) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dysize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("dysize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static FunctionDescriptor dysize$descriptor() {
        return dysize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MethodHandle dysize$handle() {
        return dysize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MemorySegment dysize$address() {
        return dysize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static int dysize(int __year) {
        var mh$ = dysize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dysize", __year);
            }
            return (int)mh$.invokeExact(__year);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static int nanosleep(MemorySegment __requested_time, MemorySegment __remaining) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __requested_time, __remaining);
            }
            return (int)mh$.invokeExact(__requested_time, __remaining);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int)mh$.invokeExact(__clock_id, __res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("clock_nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static FunctionDescriptor clock_nanosleep$descriptor() {
        return clock_nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MethodHandle clock_nanosleep$handle() {
        return clock_nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MemorySegment clock_nanosleep$address() {
        return clock_nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static int clock_nanosleep(int __clock_id, int __flags, MemorySegment __req, MemorySegment __rem) {
        var mh$ = clock_nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_nanosleep", __clock_id, __flags, __req, __rem);
            }
            return (int)mh$.invokeExact(__clock_id, __flags, __req, __rem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getcpuclockid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("clock_getcpuclockid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static FunctionDescriptor clock_getcpuclockid$descriptor() {
        return clock_getcpuclockid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MethodHandle clock_getcpuclockid$handle() {
        return clock_getcpuclockid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MemorySegment clock_getcpuclockid$address() {
        return clock_getcpuclockid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static int clock_getcpuclockid(int __pid, MemorySegment __clock_id) {
        var mh$ = clock_getcpuclockid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getcpuclockid", __pid, __clock_id);
            }
            return (int)mh$.invokeExact(__pid, __clock_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("timer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static FunctionDescriptor timer_create$descriptor() {
        return timer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MethodHandle timer_create$handle() {
        return timer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MemorySegment timer_create$address() {
        return timer_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static int timer_create(int __clock_id, MemorySegment __evp, MemorySegment __timerid) {
        var mh$ = timer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_create", __clock_id, __evp, __timerid);
            }
            return (int)mh$.invokeExact(__clock_id, __evp, __timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("timer_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_delete$descriptor() {
        return timer_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_delete$handle() {
        return timer_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_delete$address() {
        return timer_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static int timer_delete(MemorySegment __timerid) {
        var mh$ = timer_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_delete", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("timer_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static FunctionDescriptor timer_settime$descriptor() {
        return timer_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MethodHandle timer_settime$handle() {
        return timer_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MemorySegment timer_settime$address() {
        return timer_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static int timer_settime(MemorySegment __timerid, int __flags, MemorySegment __value, MemorySegment __ovalue) {
        var mh$ = timer_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_settime", __timerid, __flags, __value, __ovalue);
            }
            return (int)mh$.invokeExact(__timerid, __flags, __value, __ovalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("timer_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static FunctionDescriptor timer_gettime$descriptor() {
        return timer_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MethodHandle timer_gettime$handle() {
        return timer_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MemorySegment timer_gettime$address() {
        return timer_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static int timer_gettime(MemorySegment __timerid, MemorySegment __value) {
        var mh$ = timer_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_gettime", __timerid, __value);
            }
            return (int)mh$.invokeExact(__timerid, __value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_getoverrun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("timer_getoverrun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_getoverrun$descriptor() {
        return timer_getoverrun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_getoverrun$handle() {
        return timer_getoverrun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_getoverrun$address() {
        return timer_getoverrun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static int timer_getoverrun(MemorySegment __timerid) {
        var mh$ = timer_getoverrun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_getoverrun", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static int timespec_get(MemorySegment __ts, int __base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", __ts, __base);
            }
            return (int)mh$.invokeExact(__ts, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PTHREAD_CREATE_JOINABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_CREATE_JOINABLE = 0
     * }
     */
    public static int PTHREAD_CREATE_JOINABLE() {
        return PTHREAD_CREATE_JOINABLE;
    }
    private static final int PTHREAD_CREATE_DETACHED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_CREATE_DETACHED = 1
     * }
     */
    public static int PTHREAD_CREATE_DETACHED() {
        return PTHREAD_CREATE_DETACHED;
    }
    private static final int PTHREAD_MUTEX_TIMED_NP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_TIMED_NP = 0
     * }
     */
    public static int PTHREAD_MUTEX_TIMED_NP() {
        return PTHREAD_MUTEX_TIMED_NP;
    }
    private static final int PTHREAD_MUTEX_RECURSIVE_NP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_RECURSIVE_NP = 1
     * }
     */
    public static int PTHREAD_MUTEX_RECURSIVE_NP() {
        return PTHREAD_MUTEX_RECURSIVE_NP;
    }
    private static final int PTHREAD_MUTEX_ERRORCHECK_NP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_ERRORCHECK_NP = 2
     * }
     */
    public static int PTHREAD_MUTEX_ERRORCHECK_NP() {
        return PTHREAD_MUTEX_ERRORCHECK_NP;
    }
    private static final int PTHREAD_MUTEX_ADAPTIVE_NP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_ADAPTIVE_NP = 3
     * }
     */
    public static int PTHREAD_MUTEX_ADAPTIVE_NP() {
        return PTHREAD_MUTEX_ADAPTIVE_NP;
    }
    private static final int PTHREAD_MUTEX_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_NORMAL = 0
     * }
     */
    public static int PTHREAD_MUTEX_NORMAL() {
        return PTHREAD_MUTEX_NORMAL;
    }
    private static final int PTHREAD_MUTEX_RECURSIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_RECURSIVE = 1
     * }
     */
    public static int PTHREAD_MUTEX_RECURSIVE() {
        return PTHREAD_MUTEX_RECURSIVE;
    }
    private static final int PTHREAD_MUTEX_ERRORCHECK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_ERRORCHECK = 2
     * }
     */
    public static int PTHREAD_MUTEX_ERRORCHECK() {
        return PTHREAD_MUTEX_ERRORCHECK;
    }
    private static final int PTHREAD_MUTEX_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_DEFAULT = 0
     * }
     */
    public static int PTHREAD_MUTEX_DEFAULT() {
        return PTHREAD_MUTEX_DEFAULT;
    }
    private static final int PTHREAD_MUTEX_STALLED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_STALLED = 0
     * }
     */
    public static int PTHREAD_MUTEX_STALLED() {
        return PTHREAD_MUTEX_STALLED;
    }
    private static final int PTHREAD_MUTEX_STALLED_NP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_STALLED_NP = 0
     * }
     */
    public static int PTHREAD_MUTEX_STALLED_NP() {
        return PTHREAD_MUTEX_STALLED_NP;
    }
    private static final int PTHREAD_MUTEX_ROBUST = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_ROBUST = 1
     * }
     */
    public static int PTHREAD_MUTEX_ROBUST() {
        return PTHREAD_MUTEX_ROBUST;
    }
    private static final int PTHREAD_MUTEX_ROBUST_NP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_MUTEX_ROBUST_NP = 1
     * }
     */
    public static int PTHREAD_MUTEX_ROBUST_NP() {
        return PTHREAD_MUTEX_ROBUST_NP;
    }
    private static final int PTHREAD_PRIO_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_PRIO_NONE = 0
     * }
     */
    public static int PTHREAD_PRIO_NONE() {
        return PTHREAD_PRIO_NONE;
    }
    private static final int PTHREAD_PRIO_INHERIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_PRIO_INHERIT = 1
     * }
     */
    public static int PTHREAD_PRIO_INHERIT() {
        return PTHREAD_PRIO_INHERIT;
    }
    private static final int PTHREAD_PRIO_PROTECT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_PRIO_PROTECT = 2
     * }
     */
    public static int PTHREAD_PRIO_PROTECT() {
        return PTHREAD_PRIO_PROTECT;
    }
    private static final int PTHREAD_RWLOCK_PREFER_READER_NP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_RWLOCK_PREFER_READER_NP = 0
     * }
     */
    public static int PTHREAD_RWLOCK_PREFER_READER_NP() {
        return PTHREAD_RWLOCK_PREFER_READER_NP;
    }
    private static final int PTHREAD_RWLOCK_PREFER_WRITER_NP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_RWLOCK_PREFER_WRITER_NP = 1
     * }
     */
    public static int PTHREAD_RWLOCK_PREFER_WRITER_NP() {
        return PTHREAD_RWLOCK_PREFER_WRITER_NP;
    }
    private static final int PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2
     * }
     */
    public static int PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP() {
        return PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP;
    }
    private static final int PTHREAD_RWLOCK_DEFAULT_NP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_RWLOCK_DEFAULT_NP = 0
     * }
     */
    public static int PTHREAD_RWLOCK_DEFAULT_NP() {
        return PTHREAD_RWLOCK_DEFAULT_NP;
    }
    private static final int PTHREAD_INHERIT_SCHED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_INHERIT_SCHED = 0
     * }
     */
    public static int PTHREAD_INHERIT_SCHED() {
        return PTHREAD_INHERIT_SCHED;
    }
    private static final int PTHREAD_EXPLICIT_SCHED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_EXPLICIT_SCHED = 1
     * }
     */
    public static int PTHREAD_EXPLICIT_SCHED() {
        return PTHREAD_EXPLICIT_SCHED;
    }
    private static final int PTHREAD_SCOPE_SYSTEM = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_SCOPE_SYSTEM = 0
     * }
     */
    public static int PTHREAD_SCOPE_SYSTEM() {
        return PTHREAD_SCOPE_SYSTEM;
    }
    private static final int PTHREAD_SCOPE_PROCESS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_SCOPE_PROCESS = 1
     * }
     */
    public static int PTHREAD_SCOPE_PROCESS() {
        return PTHREAD_SCOPE_PROCESS;
    }
    private static final int PTHREAD_PROCESS_PRIVATE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_PROCESS_PRIVATE = 0
     * }
     */
    public static int PTHREAD_PROCESS_PRIVATE() {
        return PTHREAD_PROCESS_PRIVATE;
    }
    private static final int PTHREAD_PROCESS_SHARED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_PROCESS_SHARED = 1
     * }
     */
    public static int PTHREAD_PROCESS_SHARED() {
        return PTHREAD_PROCESS_SHARED;
    }
    private static final int PTHREAD_CANCEL_ENABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_CANCEL_ENABLE = 0
     * }
     */
    public static int PTHREAD_CANCEL_ENABLE() {
        return PTHREAD_CANCEL_ENABLE;
    }
    private static final int PTHREAD_CANCEL_DISABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_CANCEL_DISABLE = 1
     * }
     */
    public static int PTHREAD_CANCEL_DISABLE() {
        return PTHREAD_CANCEL_DISABLE;
    }
    private static final int PTHREAD_CANCEL_DEFERRED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_CANCEL_DEFERRED = 0
     * }
     */
    public static int PTHREAD_CANCEL_DEFERRED() {
        return PTHREAD_CANCEL_DEFERRED;
    }
    private static final int PTHREAD_CANCEL_ASYNCHRONOUS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PTHREAD_CANCEL_ASYNCHRONOUS = 1
     * }
     */
    public static int PTHREAD_CANCEL_ASYNCHRONOUS() {
        return PTHREAD_CANCEL_ASYNCHRONOUS;
    }

    private static class pthread_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_create(pthread_t *restrict __newthread, const pthread_attr_t *restrict __attr, void *(*__start_routine)(void *), void *restrict __arg)
     * }
     */
    public static FunctionDescriptor pthread_create$descriptor() {
        return pthread_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_create(pthread_t *restrict __newthread, const pthread_attr_t *restrict __attr, void *(*__start_routine)(void *), void *restrict __arg)
     * }
     */
    public static MethodHandle pthread_create$handle() {
        return pthread_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_create(pthread_t *restrict __newthread, const pthread_attr_t *restrict __attr, void *(*__start_routine)(void *), void *restrict __arg)
     * }
     */
    public static MemorySegment pthread_create$address() {
        return pthread_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_create(pthread_t *restrict __newthread, const pthread_attr_t *restrict __attr, void *(*__start_routine)(void *), void *restrict __arg)
     * }
     */
    public static int pthread_create(MemorySegment __newthread, MemorySegment __attr, MemorySegment __start_routine, MemorySegment __arg) {
        var mh$ = pthread_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_create", __newthread, __attr, __start_routine, __arg);
            }
            return (int)mh$.invokeExact(__newthread, __attr, __start_routine, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void pthread_exit(void *__retval)
     * }
     */
    public static FunctionDescriptor pthread_exit$descriptor() {
        return pthread_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void pthread_exit(void *__retval)
     * }
     */
    public static MethodHandle pthread_exit$handle() {
        return pthread_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void pthread_exit(void *__retval)
     * }
     */
    public static MemorySegment pthread_exit$address() {
        return pthread_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void pthread_exit(void *__retval)
     * }
     */
    public static void pthread_exit(MemorySegment __retval) {
        var mh$ = pthread_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_exit", __retval);
            }
            mh$.invokeExact(__retval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_LONG,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_join(pthread_t __th, void **__thread_return)
     * }
     */
    public static FunctionDescriptor pthread_join$descriptor() {
        return pthread_join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_join(pthread_t __th, void **__thread_return)
     * }
     */
    public static MethodHandle pthread_join$handle() {
        return pthread_join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_join(pthread_t __th, void **__thread_return)
     * }
     */
    public static MemorySegment pthread_join$address() {
        return pthread_join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_join(pthread_t __th, void **__thread_return)
     * }
     */
    public static int pthread_join(long __th, MemorySegment __thread_return) {
        var mh$ = pthread_join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_join", __th, __thread_return);
            }
            return (int)mh$.invokeExact(__th, __thread_return);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_detach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_LONG
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_detach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_detach(pthread_t __th)
     * }
     */
    public static FunctionDescriptor pthread_detach$descriptor() {
        return pthread_detach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_detach(pthread_t __th)
     * }
     */
    public static MethodHandle pthread_detach$handle() {
        return pthread_detach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_detach(pthread_t __th)
     * }
     */
    public static MemorySegment pthread_detach$address() {
        return pthread_detach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_detach(pthread_t __th)
     * }
     */
    public static int pthread_detach(long __th) {
        var mh$ = pthread_detach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_detach", __th);
            }
            return (int)mh$.invokeExact(__th);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_LONG    );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern pthread_t pthread_self()
     * }
     */
    public static FunctionDescriptor pthread_self$descriptor() {
        return pthread_self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern pthread_t pthread_self()
     * }
     */
    public static MethodHandle pthread_self$handle() {
        return pthread_self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern pthread_t pthread_self()
     * }
     */
    public static MemorySegment pthread_self$address() {
        return pthread_self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern pthread_t pthread_self()
     * }
     */
    public static long pthread_self() {
        var mh$ = pthread_self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_self");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_LONG,
            RdmaCm.C_LONG
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_equal(pthread_t __thread1, pthread_t __thread2)
     * }
     */
    public static FunctionDescriptor pthread_equal$descriptor() {
        return pthread_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_equal(pthread_t __thread1, pthread_t __thread2)
     * }
     */
    public static MethodHandle pthread_equal$handle() {
        return pthread_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_equal(pthread_t __thread1, pthread_t __thread2)
     * }
     */
    public static MemorySegment pthread_equal$address() {
        return pthread_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_equal(pthread_t __thread1, pthread_t __thread2)
     * }
     */
    public static int pthread_equal(long __thread1, long __thread2) {
        var mh$ = pthread_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_equal", __thread1, __thread2);
            }
            return (int)mh$.invokeExact(__thread1, __thread2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_init(pthread_attr_t *__attr)
     * }
     */
    public static FunctionDescriptor pthread_attr_init$descriptor() {
        return pthread_attr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_init(pthread_attr_t *__attr)
     * }
     */
    public static MethodHandle pthread_attr_init$handle() {
        return pthread_attr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_init(pthread_attr_t *__attr)
     * }
     */
    public static MemorySegment pthread_attr_init$address() {
        return pthread_attr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_init(pthread_attr_t *__attr)
     * }
     */
    public static int pthread_attr_init(MemorySegment __attr) {
        var mh$ = pthread_attr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_init", __attr);
            }
            return (int)mh$.invokeExact(__attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_destroy(pthread_attr_t *__attr)
     * }
     */
    public static FunctionDescriptor pthread_attr_destroy$descriptor() {
        return pthread_attr_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_destroy(pthread_attr_t *__attr)
     * }
     */
    public static MethodHandle pthread_attr_destroy$handle() {
        return pthread_attr_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_destroy(pthread_attr_t *__attr)
     * }
     */
    public static MemorySegment pthread_attr_destroy$address() {
        return pthread_attr_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_destroy(pthread_attr_t *__attr)
     * }
     */
    public static int pthread_attr_destroy(MemorySegment __attr) {
        var mh$ = pthread_attr_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_destroy", __attr);
            }
            return (int)mh$.invokeExact(__attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getdetachstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_getdetachstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr, int *__detachstate)
     * }
     */
    public static FunctionDescriptor pthread_attr_getdetachstate$descriptor() {
        return pthread_attr_getdetachstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr, int *__detachstate)
     * }
     */
    public static MethodHandle pthread_attr_getdetachstate$handle() {
        return pthread_attr_getdetachstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr, int *__detachstate)
     * }
     */
    public static MemorySegment pthread_attr_getdetachstate$address() {
        return pthread_attr_getdetachstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr, int *__detachstate)
     * }
     */
    public static int pthread_attr_getdetachstate(MemorySegment __attr, MemorySegment __detachstate) {
        var mh$ = pthread_attr_getdetachstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getdetachstate", __attr, __detachstate);
            }
            return (int)mh$.invokeExact(__attr, __detachstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setdetachstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_setdetachstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setdetachstate(pthread_attr_t *__attr, int __detachstate)
     * }
     */
    public static FunctionDescriptor pthread_attr_setdetachstate$descriptor() {
        return pthread_attr_setdetachstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setdetachstate(pthread_attr_t *__attr, int __detachstate)
     * }
     */
    public static MethodHandle pthread_attr_setdetachstate$handle() {
        return pthread_attr_setdetachstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setdetachstate(pthread_attr_t *__attr, int __detachstate)
     * }
     */
    public static MemorySegment pthread_attr_setdetachstate$address() {
        return pthread_attr_setdetachstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setdetachstate(pthread_attr_t *__attr, int __detachstate)
     * }
     */
    public static int pthread_attr_setdetachstate(MemorySegment __attr, int __detachstate) {
        var mh$ = pthread_attr_setdetachstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setdetachstate", __attr, __detachstate);
            }
            return (int)mh$.invokeExact(__attr, __detachstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getguardsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_getguardsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getguardsize(const pthread_attr_t *__attr, size_t *__guardsize)
     * }
     */
    public static FunctionDescriptor pthread_attr_getguardsize$descriptor() {
        return pthread_attr_getguardsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getguardsize(const pthread_attr_t *__attr, size_t *__guardsize)
     * }
     */
    public static MethodHandle pthread_attr_getguardsize$handle() {
        return pthread_attr_getguardsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getguardsize(const pthread_attr_t *__attr, size_t *__guardsize)
     * }
     */
    public static MemorySegment pthread_attr_getguardsize$address() {
        return pthread_attr_getguardsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getguardsize(const pthread_attr_t *__attr, size_t *__guardsize)
     * }
     */
    public static int pthread_attr_getguardsize(MemorySegment __attr, MemorySegment __guardsize) {
        var mh$ = pthread_attr_getguardsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getguardsize", __attr, __guardsize);
            }
            return (int)mh$.invokeExact(__attr, __guardsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setguardsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_LONG
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_setguardsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setguardsize(pthread_attr_t *__attr, size_t __guardsize)
     * }
     */
    public static FunctionDescriptor pthread_attr_setguardsize$descriptor() {
        return pthread_attr_setguardsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setguardsize(pthread_attr_t *__attr, size_t __guardsize)
     * }
     */
    public static MethodHandle pthread_attr_setguardsize$handle() {
        return pthread_attr_setguardsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setguardsize(pthread_attr_t *__attr, size_t __guardsize)
     * }
     */
    public static MemorySegment pthread_attr_setguardsize$address() {
        return pthread_attr_setguardsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setguardsize(pthread_attr_t *__attr, size_t __guardsize)
     * }
     */
    public static int pthread_attr_setguardsize(MemorySegment __attr, long __guardsize) {
        var mh$ = pthread_attr_setguardsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setguardsize", __attr, __guardsize);
            }
            return (int)mh$.invokeExact(__attr, __guardsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_getschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getschedparam(const pthread_attr_t *restrict __attr, struct sched_param *restrict __param)
     * }
     */
    public static FunctionDescriptor pthread_attr_getschedparam$descriptor() {
        return pthread_attr_getschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getschedparam(const pthread_attr_t *restrict __attr, struct sched_param *restrict __param)
     * }
     */
    public static MethodHandle pthread_attr_getschedparam$handle() {
        return pthread_attr_getschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getschedparam(const pthread_attr_t *restrict __attr, struct sched_param *restrict __param)
     * }
     */
    public static MemorySegment pthread_attr_getschedparam$address() {
        return pthread_attr_getschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getschedparam(const pthread_attr_t *restrict __attr, struct sched_param *restrict __param)
     * }
     */
    public static int pthread_attr_getschedparam(MemorySegment __attr, MemorySegment __param) {
        var mh$ = pthread_attr_getschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getschedparam", __attr, __param);
            }
            return (int)mh$.invokeExact(__attr, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_setschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setschedparam(pthread_attr_t *restrict __attr, const struct sched_param *restrict __param)
     * }
     */
    public static FunctionDescriptor pthread_attr_setschedparam$descriptor() {
        return pthread_attr_setschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setschedparam(pthread_attr_t *restrict __attr, const struct sched_param *restrict __param)
     * }
     */
    public static MethodHandle pthread_attr_setschedparam$handle() {
        return pthread_attr_setschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setschedparam(pthread_attr_t *restrict __attr, const struct sched_param *restrict __param)
     * }
     */
    public static MemorySegment pthread_attr_setschedparam$address() {
        return pthread_attr_setschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setschedparam(pthread_attr_t *restrict __attr, const struct sched_param *restrict __param)
     * }
     */
    public static int pthread_attr_setschedparam(MemorySegment __attr, MemorySegment __param) {
        var mh$ = pthread_attr_setschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setschedparam", __attr, __param);
            }
            return (int)mh$.invokeExact(__attr, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getschedpolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_getschedpolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getschedpolicy(const pthread_attr_t *restrict __attr, int *restrict __policy)
     * }
     */
    public static FunctionDescriptor pthread_attr_getschedpolicy$descriptor() {
        return pthread_attr_getschedpolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getschedpolicy(const pthread_attr_t *restrict __attr, int *restrict __policy)
     * }
     */
    public static MethodHandle pthread_attr_getschedpolicy$handle() {
        return pthread_attr_getschedpolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getschedpolicy(const pthread_attr_t *restrict __attr, int *restrict __policy)
     * }
     */
    public static MemorySegment pthread_attr_getschedpolicy$address() {
        return pthread_attr_getschedpolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getschedpolicy(const pthread_attr_t *restrict __attr, int *restrict __policy)
     * }
     */
    public static int pthread_attr_getschedpolicy(MemorySegment __attr, MemorySegment __policy) {
        var mh$ = pthread_attr_getschedpolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getschedpolicy", __attr, __policy);
            }
            return (int)mh$.invokeExact(__attr, __policy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setschedpolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_setschedpolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr, int __policy)
     * }
     */
    public static FunctionDescriptor pthread_attr_setschedpolicy$descriptor() {
        return pthread_attr_setschedpolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr, int __policy)
     * }
     */
    public static MethodHandle pthread_attr_setschedpolicy$handle() {
        return pthread_attr_setschedpolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr, int __policy)
     * }
     */
    public static MemorySegment pthread_attr_setschedpolicy$address() {
        return pthread_attr_setschedpolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr, int __policy)
     * }
     */
    public static int pthread_attr_setschedpolicy(MemorySegment __attr, int __policy) {
        var mh$ = pthread_attr_setschedpolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setschedpolicy", __attr, __policy);
            }
            return (int)mh$.invokeExact(__attr, __policy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getinheritsched {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_getinheritsched");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getinheritsched(const pthread_attr_t *restrict __attr, int *restrict __inherit)
     * }
     */
    public static FunctionDescriptor pthread_attr_getinheritsched$descriptor() {
        return pthread_attr_getinheritsched.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getinheritsched(const pthread_attr_t *restrict __attr, int *restrict __inherit)
     * }
     */
    public static MethodHandle pthread_attr_getinheritsched$handle() {
        return pthread_attr_getinheritsched.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getinheritsched(const pthread_attr_t *restrict __attr, int *restrict __inherit)
     * }
     */
    public static MemorySegment pthread_attr_getinheritsched$address() {
        return pthread_attr_getinheritsched.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getinheritsched(const pthread_attr_t *restrict __attr, int *restrict __inherit)
     * }
     */
    public static int pthread_attr_getinheritsched(MemorySegment __attr, MemorySegment __inherit) {
        var mh$ = pthread_attr_getinheritsched.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getinheritsched", __attr, __inherit);
            }
            return (int)mh$.invokeExact(__attr, __inherit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setinheritsched {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_setinheritsched");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setinheritsched(pthread_attr_t *__attr, int __inherit)
     * }
     */
    public static FunctionDescriptor pthread_attr_setinheritsched$descriptor() {
        return pthread_attr_setinheritsched.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setinheritsched(pthread_attr_t *__attr, int __inherit)
     * }
     */
    public static MethodHandle pthread_attr_setinheritsched$handle() {
        return pthread_attr_setinheritsched.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setinheritsched(pthread_attr_t *__attr, int __inherit)
     * }
     */
    public static MemorySegment pthread_attr_setinheritsched$address() {
        return pthread_attr_setinheritsched.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setinheritsched(pthread_attr_t *__attr, int __inherit)
     * }
     */
    public static int pthread_attr_setinheritsched(MemorySegment __attr, int __inherit) {
        var mh$ = pthread_attr_setinheritsched.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setinheritsched", __attr, __inherit);
            }
            return (int)mh$.invokeExact(__attr, __inherit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getscope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_getscope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getscope(const pthread_attr_t *restrict __attr, int *restrict __scope)
     * }
     */
    public static FunctionDescriptor pthread_attr_getscope$descriptor() {
        return pthread_attr_getscope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getscope(const pthread_attr_t *restrict __attr, int *restrict __scope)
     * }
     */
    public static MethodHandle pthread_attr_getscope$handle() {
        return pthread_attr_getscope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getscope(const pthread_attr_t *restrict __attr, int *restrict __scope)
     * }
     */
    public static MemorySegment pthread_attr_getscope$address() {
        return pthread_attr_getscope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getscope(const pthread_attr_t *restrict __attr, int *restrict __scope)
     * }
     */
    public static int pthread_attr_getscope(MemorySegment __attr, MemorySegment __scope) {
        var mh$ = pthread_attr_getscope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getscope", __attr, __scope);
            }
            return (int)mh$.invokeExact(__attr, __scope);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setscope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_setscope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setscope(pthread_attr_t *__attr, int __scope)
     * }
     */
    public static FunctionDescriptor pthread_attr_setscope$descriptor() {
        return pthread_attr_setscope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setscope(pthread_attr_t *__attr, int __scope)
     * }
     */
    public static MethodHandle pthread_attr_setscope$handle() {
        return pthread_attr_setscope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setscope(pthread_attr_t *__attr, int __scope)
     * }
     */
    public static MemorySegment pthread_attr_setscope$address() {
        return pthread_attr_setscope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setscope(pthread_attr_t *__attr, int __scope)
     * }
     */
    public static int pthread_attr_setscope(MemorySegment __attr, int __scope) {
        var mh$ = pthread_attr_setscope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setscope", __attr, __scope);
            }
            return (int)mh$.invokeExact(__attr, __scope);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getstackaddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_getstackaddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstackaddr(const pthread_attr_t *restrict __attr, void **restrict __stackaddr)
     * }
     */
    public static FunctionDescriptor pthread_attr_getstackaddr$descriptor() {
        return pthread_attr_getstackaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstackaddr(const pthread_attr_t *restrict __attr, void **restrict __stackaddr)
     * }
     */
    public static MethodHandle pthread_attr_getstackaddr$handle() {
        return pthread_attr_getstackaddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstackaddr(const pthread_attr_t *restrict __attr, void **restrict __stackaddr)
     * }
     */
    public static MemorySegment pthread_attr_getstackaddr$address() {
        return pthread_attr_getstackaddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getstackaddr(const pthread_attr_t *restrict __attr, void **restrict __stackaddr)
     * }
     */
    public static int pthread_attr_getstackaddr(MemorySegment __attr, MemorySegment __stackaddr) {
        var mh$ = pthread_attr_getstackaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getstackaddr", __attr, __stackaddr);
            }
            return (int)mh$.invokeExact(__attr, __stackaddr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setstackaddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_setstackaddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstackaddr(pthread_attr_t *__attr, void *__stackaddr)
     * }
     */
    public static FunctionDescriptor pthread_attr_setstackaddr$descriptor() {
        return pthread_attr_setstackaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstackaddr(pthread_attr_t *__attr, void *__stackaddr)
     * }
     */
    public static MethodHandle pthread_attr_setstackaddr$handle() {
        return pthread_attr_setstackaddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstackaddr(pthread_attr_t *__attr, void *__stackaddr)
     * }
     */
    public static MemorySegment pthread_attr_setstackaddr$address() {
        return pthread_attr_setstackaddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setstackaddr(pthread_attr_t *__attr, void *__stackaddr)
     * }
     */
    public static int pthread_attr_setstackaddr(MemorySegment __attr, MemorySegment __stackaddr) {
        var mh$ = pthread_attr_setstackaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setstackaddr", __attr, __stackaddr);
            }
            return (int)mh$.invokeExact(__attr, __stackaddr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getstacksize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_getstacksize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstacksize(const pthread_attr_t *restrict __attr, size_t *restrict __stacksize)
     * }
     */
    public static FunctionDescriptor pthread_attr_getstacksize$descriptor() {
        return pthread_attr_getstacksize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstacksize(const pthread_attr_t *restrict __attr, size_t *restrict __stacksize)
     * }
     */
    public static MethodHandle pthread_attr_getstacksize$handle() {
        return pthread_attr_getstacksize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstacksize(const pthread_attr_t *restrict __attr, size_t *restrict __stacksize)
     * }
     */
    public static MemorySegment pthread_attr_getstacksize$address() {
        return pthread_attr_getstacksize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getstacksize(const pthread_attr_t *restrict __attr, size_t *restrict __stacksize)
     * }
     */
    public static int pthread_attr_getstacksize(MemorySegment __attr, MemorySegment __stacksize) {
        var mh$ = pthread_attr_getstacksize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getstacksize", __attr, __stacksize);
            }
            return (int)mh$.invokeExact(__attr, __stacksize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setstacksize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_LONG
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_setstacksize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstacksize(pthread_attr_t *__attr, size_t __stacksize)
     * }
     */
    public static FunctionDescriptor pthread_attr_setstacksize$descriptor() {
        return pthread_attr_setstacksize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstacksize(pthread_attr_t *__attr, size_t __stacksize)
     * }
     */
    public static MethodHandle pthread_attr_setstacksize$handle() {
        return pthread_attr_setstacksize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstacksize(pthread_attr_t *__attr, size_t __stacksize)
     * }
     */
    public static MemorySegment pthread_attr_setstacksize$address() {
        return pthread_attr_setstacksize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setstacksize(pthread_attr_t *__attr, size_t __stacksize)
     * }
     */
    public static int pthread_attr_setstacksize(MemorySegment __attr, long __stacksize) {
        var mh$ = pthread_attr_setstacksize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setstacksize", __attr, __stacksize);
            }
            return (int)mh$.invokeExact(__attr, __stacksize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_getstack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstack(const pthread_attr_t *restrict __attr, void **restrict __stackaddr, size_t *restrict __stacksize)
     * }
     */
    public static FunctionDescriptor pthread_attr_getstack$descriptor() {
        return pthread_attr_getstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstack(const pthread_attr_t *restrict __attr, void **restrict __stackaddr, size_t *restrict __stacksize)
     * }
     */
    public static MethodHandle pthread_attr_getstack$handle() {
        return pthread_attr_getstack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_getstack(const pthread_attr_t *restrict __attr, void **restrict __stackaddr, size_t *restrict __stacksize)
     * }
     */
    public static MemorySegment pthread_attr_getstack$address() {
        return pthread_attr_getstack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_getstack(const pthread_attr_t *restrict __attr, void **restrict __stackaddr, size_t *restrict __stacksize)
     * }
     */
    public static int pthread_attr_getstack(MemorySegment __attr, MemorySegment __stackaddr, MemorySegment __stacksize) {
        var mh$ = pthread_attr_getstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getstack", __attr, __stackaddr, __stacksize);
            }
            return (int)mh$.invokeExact(__attr, __stackaddr, __stacksize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER,
            RdmaCm.C_LONG
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_attr_setstack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr, size_t __stacksize)
     * }
     */
    public static FunctionDescriptor pthread_attr_setstack$descriptor() {
        return pthread_attr_setstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr, size_t __stacksize)
     * }
     */
    public static MethodHandle pthread_attr_setstack$handle() {
        return pthread_attr_setstack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr, size_t __stacksize)
     * }
     */
    public static MemorySegment pthread_attr_setstack$address() {
        return pthread_attr_setstack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr, size_t __stacksize)
     * }
     */
    public static int pthread_attr_setstack(MemorySegment __attr, MemorySegment __stackaddr, long __stacksize) {
        var mh$ = pthread_attr_setstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setstack", __attr, __stackaddr, __stacksize);
            }
            return (int)mh$.invokeExact(__attr, __stackaddr, __stacksize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_LONG,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_setschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const struct sched_param *__param)
     * }
     */
    public static FunctionDescriptor pthread_setschedparam$descriptor() {
        return pthread_setschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const struct sched_param *__param)
     * }
     */
    public static MethodHandle pthread_setschedparam$handle() {
        return pthread_setschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const struct sched_param *__param)
     * }
     */
    public static MemorySegment pthread_setschedparam$address() {
        return pthread_setschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const struct sched_param *__param)
     * }
     */
    public static int pthread_setschedparam(long __target_thread, int __policy, MemorySegment __param) {
        var mh$ = pthread_setschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setschedparam", __target_thread, __policy, __param);
            }
            return (int)mh$.invokeExact(__target_thread, __policy, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_LONG,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_getschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_getschedparam(pthread_t __target_thread, int *restrict __policy, struct sched_param *restrict __param)
     * }
     */
    public static FunctionDescriptor pthread_getschedparam$descriptor() {
        return pthread_getschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_getschedparam(pthread_t __target_thread, int *restrict __policy, struct sched_param *restrict __param)
     * }
     */
    public static MethodHandle pthread_getschedparam$handle() {
        return pthread_getschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_getschedparam(pthread_t __target_thread, int *restrict __policy, struct sched_param *restrict __param)
     * }
     */
    public static MemorySegment pthread_getschedparam$address() {
        return pthread_getschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_getschedparam(pthread_t __target_thread, int *restrict __policy, struct sched_param *restrict __param)
     * }
     */
    public static int pthread_getschedparam(long __target_thread, MemorySegment __policy, MemorySegment __param) {
        var mh$ = pthread_getschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getschedparam", __target_thread, __policy, __param);
            }
            return (int)mh$.invokeExact(__target_thread, __policy, __param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setschedprio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_LONG,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_setschedprio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_setschedprio(pthread_t __target_thread, int __prio)
     * }
     */
    public static FunctionDescriptor pthread_setschedprio$descriptor() {
        return pthread_setschedprio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_setschedprio(pthread_t __target_thread, int __prio)
     * }
     */
    public static MethodHandle pthread_setschedprio$handle() {
        return pthread_setschedprio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_setschedprio(pthread_t __target_thread, int __prio)
     * }
     */
    public static MemorySegment pthread_setschedprio$address() {
        return pthread_setschedprio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_setschedprio(pthread_t __target_thread, int __prio)
     * }
     */
    public static int pthread_setschedprio(long __target_thread, int __prio) {
        var mh$ = pthread_setschedprio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setschedprio", __target_thread, __prio);
            }
            return (int)mh$.invokeExact(__target_thread, __prio);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_once {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_once");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_once(pthread_once_t *__once_control, void (*__init_routine)(void))
     * }
     */
    public static FunctionDescriptor pthread_once$descriptor() {
        return pthread_once.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_once(pthread_once_t *__once_control, void (*__init_routine)(void))
     * }
     */
    public static MethodHandle pthread_once$handle() {
        return pthread_once.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_once(pthread_once_t *__once_control, void (*__init_routine)(void))
     * }
     */
    public static MemorySegment pthread_once$address() {
        return pthread_once.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_once(pthread_once_t *__once_control, void (*__init_routine)(void))
     * }
     */
    public static int pthread_once(MemorySegment __once_control, MemorySegment __init_routine) {
        var mh$ = pthread_once.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_once", __once_control, __init_routine);
            }
            return (int)mh$.invokeExact(__once_control, __init_routine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setcancelstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_setcancelstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_setcancelstate(int __state, int *__oldstate)
     * }
     */
    public static FunctionDescriptor pthread_setcancelstate$descriptor() {
        return pthread_setcancelstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_setcancelstate(int __state, int *__oldstate)
     * }
     */
    public static MethodHandle pthread_setcancelstate$handle() {
        return pthread_setcancelstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_setcancelstate(int __state, int *__oldstate)
     * }
     */
    public static MemorySegment pthread_setcancelstate$address() {
        return pthread_setcancelstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_setcancelstate(int __state, int *__oldstate)
     * }
     */
    public static int pthread_setcancelstate(int __state, MemorySegment __oldstate) {
        var mh$ = pthread_setcancelstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setcancelstate", __state, __oldstate);
            }
            return (int)mh$.invokeExact(__state, __oldstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setcanceltype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_setcanceltype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_setcanceltype(int __type, int *__oldtype)
     * }
     */
    public static FunctionDescriptor pthread_setcanceltype$descriptor() {
        return pthread_setcanceltype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_setcanceltype(int __type, int *__oldtype)
     * }
     */
    public static MethodHandle pthread_setcanceltype$handle() {
        return pthread_setcanceltype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_setcanceltype(int __type, int *__oldtype)
     * }
     */
    public static MemorySegment pthread_setcanceltype$address() {
        return pthread_setcanceltype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_setcanceltype(int __type, int *__oldtype)
     * }
     */
    public static int pthread_setcanceltype(int __type, MemorySegment __oldtype) {
        var mh$ = pthread_setcanceltype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setcanceltype", __type, __oldtype);
            }
            return (int)mh$.invokeExact(__type, __oldtype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_LONG
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_cancel(pthread_t __th)
     * }
     */
    public static FunctionDescriptor pthread_cancel$descriptor() {
        return pthread_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_cancel(pthread_t __th)
     * }
     */
    public static MethodHandle pthread_cancel$handle() {
        return pthread_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_cancel(pthread_t __th)
     * }
     */
    public static MemorySegment pthread_cancel$address() {
        return pthread_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_cancel(pthread_t __th)
     * }
     */
    public static int pthread_cancel(long __th) {
        var mh$ = pthread_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cancel", __th);
            }
            return (int)mh$.invokeExact(__th);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_testcancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_testcancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void pthread_testcancel()
     * }
     */
    public static FunctionDescriptor pthread_testcancel$descriptor() {
        return pthread_testcancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void pthread_testcancel()
     * }
     */
    public static MethodHandle pthread_testcancel$handle() {
        return pthread_testcancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void pthread_testcancel()
     * }
     */
    public static MemorySegment pthread_testcancel$address() {
        return pthread_testcancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void pthread_testcancel()
     * }
     */
    public static void pthread_testcancel() {
        var mh$ = pthread_testcancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_testcancel");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __pthread_register_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("__pthread_register_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static FunctionDescriptor __pthread_register_cancel$descriptor() {
        return __pthread_register_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static MethodHandle __pthread_register_cancel$handle() {
        return __pthread_register_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static MemorySegment __pthread_register_cancel$address() {
        return __pthread_register_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static void __pthread_register_cancel(MemorySegment __buf) {
        var mh$ = __pthread_register_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__pthread_register_cancel", __buf);
            }
            mh$.invokeExact(__buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __pthread_unregister_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("__pthread_unregister_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static FunctionDescriptor __pthread_unregister_cancel$descriptor() {
        return __pthread_unregister_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static MethodHandle __pthread_unregister_cancel$handle() {
        return __pthread_unregister_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static MemorySegment __pthread_unregister_cancel$address() {
        return __pthread_unregister_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static void __pthread_unregister_cancel(MemorySegment __buf) {
        var mh$ = __pthread_unregister_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__pthread_unregister_cancel", __buf);
            }
            mh$.invokeExact(__buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __pthread_unwind_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("__pthread_unwind_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static FunctionDescriptor __pthread_unwind_next$descriptor() {
        return __pthread_unwind_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static MethodHandle __pthread_unwind_next$handle() {
        return __pthread_unwind_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static MemorySegment __pthread_unwind_next$address() {
        return __pthread_unwind_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf)
     * }
     */
    public static void __pthread_unwind_next(MemorySegment __buf) {
        var mh$ = __pthread_unwind_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__pthread_unwind_next", __buf);
            }
            mh$.invokeExact(__buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sigsetjmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("__sigsetjmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __sigsetjmp(struct __jmp_buf_tag __env[1], int __savemask)
     * }
     */
    public static FunctionDescriptor __sigsetjmp$descriptor() {
        return __sigsetjmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __sigsetjmp(struct __jmp_buf_tag __env[1], int __savemask)
     * }
     */
    public static MethodHandle __sigsetjmp$handle() {
        return __sigsetjmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __sigsetjmp(struct __jmp_buf_tag __env[1], int __savemask)
     * }
     */
    public static MemorySegment __sigsetjmp$address() {
        return __sigsetjmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __sigsetjmp(struct __jmp_buf_tag __env[1], int __savemask)
     * }
     */
    public static int __sigsetjmp(MemorySegment __env, int __savemask) {
        var mh$ = __sigsetjmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sigsetjmp", __env, __savemask);
            }
            return (int)mh$.invokeExact(__env, __savemask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutex_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr)
     * }
     */
    public static FunctionDescriptor pthread_mutex_init$descriptor() {
        return pthread_mutex_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr)
     * }
     */
    public static MethodHandle pthread_mutex_init$handle() {
        return pthread_mutex_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr)
     * }
     */
    public static MemorySegment pthread_mutex_init$address() {
        return pthread_mutex_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr)
     * }
     */
    public static int pthread_mutex_init(MemorySegment __mutex, MemorySegment __mutexattr) {
        var mh$ = pthread_mutex_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_init", __mutex, __mutexattr);
            }
            return (int)mh$.invokeExact(__mutex, __mutexattr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutex_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_destroy(pthread_mutex_t *__mutex)
     * }
     */
    public static FunctionDescriptor pthread_mutex_destroy$descriptor() {
        return pthread_mutex_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_destroy(pthread_mutex_t *__mutex)
     * }
     */
    public static MethodHandle pthread_mutex_destroy$handle() {
        return pthread_mutex_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_destroy(pthread_mutex_t *__mutex)
     * }
     */
    public static MemorySegment pthread_mutex_destroy$address() {
        return pthread_mutex_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_destroy(pthread_mutex_t *__mutex)
     * }
     */
    public static int pthread_mutex_destroy(MemorySegment __mutex) {
        var mh$ = pthread_mutex_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_destroy", __mutex);
            }
            return (int)mh$.invokeExact(__mutex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_trylock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutex_trylock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_trylock(pthread_mutex_t *__mutex)
     * }
     */
    public static FunctionDescriptor pthread_mutex_trylock$descriptor() {
        return pthread_mutex_trylock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_trylock(pthread_mutex_t *__mutex)
     * }
     */
    public static MethodHandle pthread_mutex_trylock$handle() {
        return pthread_mutex_trylock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_trylock(pthread_mutex_t *__mutex)
     * }
     */
    public static MemorySegment pthread_mutex_trylock$address() {
        return pthread_mutex_trylock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_trylock(pthread_mutex_t *__mutex)
     * }
     */
    public static int pthread_mutex_trylock(MemorySegment __mutex) {
        var mh$ = pthread_mutex_trylock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_trylock", __mutex);
            }
            return (int)mh$.invokeExact(__mutex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutex_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_lock(pthread_mutex_t *__mutex)
     * }
     */
    public static FunctionDescriptor pthread_mutex_lock$descriptor() {
        return pthread_mutex_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_lock(pthread_mutex_t *__mutex)
     * }
     */
    public static MethodHandle pthread_mutex_lock$handle() {
        return pthread_mutex_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_lock(pthread_mutex_t *__mutex)
     * }
     */
    public static MemorySegment pthread_mutex_lock$address() {
        return pthread_mutex_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_lock(pthread_mutex_t *__mutex)
     * }
     */
    public static int pthread_mutex_lock(MemorySegment __mutex) {
        var mh$ = pthread_mutex_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_lock", __mutex);
            }
            return (int)mh$.invokeExact(__mutex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_timedlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutex_timedlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_timedlock(pthread_mutex_t *restrict __mutex, const struct timespec *restrict __abstime)
     * }
     */
    public static FunctionDescriptor pthread_mutex_timedlock$descriptor() {
        return pthread_mutex_timedlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_timedlock(pthread_mutex_t *restrict __mutex, const struct timespec *restrict __abstime)
     * }
     */
    public static MethodHandle pthread_mutex_timedlock$handle() {
        return pthread_mutex_timedlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_timedlock(pthread_mutex_t *restrict __mutex, const struct timespec *restrict __abstime)
     * }
     */
    public static MemorySegment pthread_mutex_timedlock$address() {
        return pthread_mutex_timedlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_timedlock(pthread_mutex_t *restrict __mutex, const struct timespec *restrict __abstime)
     * }
     */
    public static int pthread_mutex_timedlock(MemorySegment __mutex, MemorySegment __abstime) {
        var mh$ = pthread_mutex_timedlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_timedlock", __mutex, __abstime);
            }
            return (int)mh$.invokeExact(__mutex, __abstime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutex_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_unlock(pthread_mutex_t *__mutex)
     * }
     */
    public static FunctionDescriptor pthread_mutex_unlock$descriptor() {
        return pthread_mutex_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_unlock(pthread_mutex_t *__mutex)
     * }
     */
    public static MethodHandle pthread_mutex_unlock$handle() {
        return pthread_mutex_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_unlock(pthread_mutex_t *__mutex)
     * }
     */
    public static MemorySegment pthread_mutex_unlock$address() {
        return pthread_mutex_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_unlock(pthread_mutex_t *__mutex)
     * }
     */
    public static int pthread_mutex_unlock(MemorySegment __mutex) {
        var mh$ = pthread_mutex_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_unlock", __mutex);
            }
            return (int)mh$.invokeExact(__mutex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_getprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutex_getprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict __mutex, int *restrict __prioceiling)
     * }
     */
    public static FunctionDescriptor pthread_mutex_getprioceiling$descriptor() {
        return pthread_mutex_getprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict __mutex, int *restrict __prioceiling)
     * }
     */
    public static MethodHandle pthread_mutex_getprioceiling$handle() {
        return pthread_mutex_getprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict __mutex, int *restrict __prioceiling)
     * }
     */
    public static MemorySegment pthread_mutex_getprioceiling$address() {
        return pthread_mutex_getprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict __mutex, int *restrict __prioceiling)
     * }
     */
    public static int pthread_mutex_getprioceiling(MemorySegment __mutex, MemorySegment __prioceiling) {
        var mh$ = pthread_mutex_getprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_getprioceiling", __mutex, __prioceiling);
            }
            return (int)mh$.invokeExact(__mutex, __prioceiling);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_setprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutex_setprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_setprioceiling(pthread_mutex_t *restrict __mutex, int __prioceiling, int *restrict __old_ceiling)
     * }
     */
    public static FunctionDescriptor pthread_mutex_setprioceiling$descriptor() {
        return pthread_mutex_setprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_setprioceiling(pthread_mutex_t *restrict __mutex, int __prioceiling, int *restrict __old_ceiling)
     * }
     */
    public static MethodHandle pthread_mutex_setprioceiling$handle() {
        return pthread_mutex_setprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_setprioceiling(pthread_mutex_t *restrict __mutex, int __prioceiling, int *restrict __old_ceiling)
     * }
     */
    public static MemorySegment pthread_mutex_setprioceiling$address() {
        return pthread_mutex_setprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_setprioceiling(pthread_mutex_t *restrict __mutex, int __prioceiling, int *restrict __old_ceiling)
     * }
     */
    public static int pthread_mutex_setprioceiling(MemorySegment __mutex, int __prioceiling, MemorySegment __old_ceiling) {
        var mh$ = pthread_mutex_setprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_setprioceiling", __mutex, __prioceiling, __old_ceiling);
            }
            return (int)mh$.invokeExact(__mutex, __prioceiling, __old_ceiling);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_consistent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutex_consistent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutex_consistent(pthread_mutex_t *__mutex)
     * }
     */
    public static FunctionDescriptor pthread_mutex_consistent$descriptor() {
        return pthread_mutex_consistent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutex_consistent(pthread_mutex_t *__mutex)
     * }
     */
    public static MethodHandle pthread_mutex_consistent$handle() {
        return pthread_mutex_consistent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutex_consistent(pthread_mutex_t *__mutex)
     * }
     */
    public static MemorySegment pthread_mutex_consistent$address() {
        return pthread_mutex_consistent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutex_consistent(pthread_mutex_t *__mutex)
     * }
     */
    public static int pthread_mutex_consistent(MemorySegment __mutex) {
        var mh$ = pthread_mutex_consistent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_consistent", __mutex);
            }
            return (int)mh$.invokeExact(__mutex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutexattr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_init$descriptor() {
        return pthread_mutexattr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr)
     * }
     */
    public static MethodHandle pthread_mutexattr_init$handle() {
        return pthread_mutexattr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr)
     * }
     */
    public static MemorySegment pthread_mutexattr_init$address() {
        return pthread_mutexattr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr)
     * }
     */
    public static int pthread_mutexattr_init(MemorySegment __attr) {
        var mh$ = pthread_mutexattr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_init", __attr);
            }
            return (int)mh$.invokeExact(__attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutexattr_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_destroy$descriptor() {
        return pthread_mutexattr_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr)
     * }
     */
    public static MethodHandle pthread_mutexattr_destroy$handle() {
        return pthread_mutexattr_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr)
     * }
     */
    public static MemorySegment pthread_mutexattr_destroy$address() {
        return pthread_mutexattr_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr)
     * }
     */
    public static int pthread_mutexattr_destroy(MemorySegment __attr) {
        var mh$ = pthread_mutexattr_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_destroy", __attr);
            }
            return (int)mh$.invokeExact(__attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutexattr_getpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getpshared$descriptor() {
        return pthread_mutexattr_getpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static MethodHandle pthread_mutexattr_getpshared$handle() {
        return pthread_mutexattr_getpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static MemorySegment pthread_mutexattr_getpshared$address() {
        return pthread_mutexattr_getpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict __attr, int *restrict __pshared)
     * }
     */
    public static int pthread_mutexattr_getpshared(MemorySegment __attr, MemorySegment __pshared) {
        var mh$ = pthread_mutexattr_getpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getpshared", __attr, __pshared);
            }
            return (int)mh$.invokeExact(__attr, __pshared);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutexattr_setpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr, int __pshared)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setpshared$descriptor() {
        return pthread_mutexattr_setpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr, int __pshared)
     * }
     */
    public static MethodHandle pthread_mutexattr_setpshared$handle() {
        return pthread_mutexattr_setpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr, int __pshared)
     * }
     */
    public static MemorySegment pthread_mutexattr_setpshared$address() {
        return pthread_mutexattr_setpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr, int __pshared)
     * }
     */
    public static int pthread_mutexattr_setpshared(MemorySegment __attr, int __pshared) {
        var mh$ = pthread_mutexattr_setpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setpshared", __attr, __pshared);
            }
            return (int)mh$.invokeExact(__attr, __pshared);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_gettype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutexattr_gettype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict __attr, int *restrict __kind)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_gettype$descriptor() {
        return pthread_mutexattr_gettype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict __attr, int *restrict __kind)
     * }
     */
    public static MethodHandle pthread_mutexattr_gettype$handle() {
        return pthread_mutexattr_gettype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict __attr, int *restrict __kind)
     * }
     */
    public static MemorySegment pthread_mutexattr_gettype$address() {
        return pthread_mutexattr_gettype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict __attr, int *restrict __kind)
     * }
     */
    public static int pthread_mutexattr_gettype(MemorySegment __attr, MemorySegment __kind) {
        var mh$ = pthread_mutexattr_gettype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_gettype", __attr, __kind);
            }
            return (int)mh$.invokeExact(__attr, __kind);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_settype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutexattr_settype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr, int __kind)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_settype$descriptor() {
        return pthread_mutexattr_settype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr, int __kind)
     * }
     */
    public static MethodHandle pthread_mutexattr_settype$handle() {
        return pthread_mutexattr_settype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr, int __kind)
     * }
     */
    public static MemorySegment pthread_mutexattr_settype$address() {
        return pthread_mutexattr_settype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr, int __kind)
     * }
     */
    public static int pthread_mutexattr_settype(MemorySegment __attr, int __kind) {
        var mh$ = pthread_mutexattr_settype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_settype", __attr, __kind);
            }
            return (int)mh$.invokeExact(__attr, __kind);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getprotocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutexattr_getprotocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict __attr, int *restrict __protocol)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getprotocol$descriptor() {
        return pthread_mutexattr_getprotocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict __attr, int *restrict __protocol)
     * }
     */
    public static MethodHandle pthread_mutexattr_getprotocol$handle() {
        return pthread_mutexattr_getprotocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict __attr, int *restrict __protocol)
     * }
     */
    public static MemorySegment pthread_mutexattr_getprotocol$address() {
        return pthread_mutexattr_getprotocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict __attr, int *restrict __protocol)
     * }
     */
    public static int pthread_mutexattr_getprotocol(MemorySegment __attr, MemorySegment __protocol) {
        var mh$ = pthread_mutexattr_getprotocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getprotocol", __attr, __protocol);
            }
            return (int)mh$.invokeExact(__attr, __protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setprotocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutexattr_setprotocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr, int __protocol)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setprotocol$descriptor() {
        return pthread_mutexattr_setprotocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr, int __protocol)
     * }
     */
    public static MethodHandle pthread_mutexattr_setprotocol$handle() {
        return pthread_mutexattr_setprotocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr, int __protocol)
     * }
     */
    public static MemorySegment pthread_mutexattr_setprotocol$address() {
        return pthread_mutexattr_setprotocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr, int __protocol)
     * }
     */
    public static int pthread_mutexattr_setprotocol(MemorySegment __attr, int __protocol) {
        var mh$ = pthread_mutexattr_setprotocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setprotocol", __attr, __protocol);
            }
            return (int)mh$.invokeExact(__attr, __protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutexattr_getprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict __attr, int *restrict __prioceiling)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getprioceiling$descriptor() {
        return pthread_mutexattr_getprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict __attr, int *restrict __prioceiling)
     * }
     */
    public static MethodHandle pthread_mutexattr_getprioceiling$handle() {
        return pthread_mutexattr_getprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict __attr, int *restrict __prioceiling)
     * }
     */
    public static MemorySegment pthread_mutexattr_getprioceiling$address() {
        return pthread_mutexattr_getprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict __attr, int *restrict __prioceiling)
     * }
     */
    public static int pthread_mutexattr_getprioceiling(MemorySegment __attr, MemorySegment __prioceiling) {
        var mh$ = pthread_mutexattr_getprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getprioceiling", __attr, __prioceiling);
            }
            return (int)mh$.invokeExact(__attr, __prioceiling);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutexattr_setprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr, int __prioceiling)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setprioceiling$descriptor() {
        return pthread_mutexattr_setprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr, int __prioceiling)
     * }
     */
    public static MethodHandle pthread_mutexattr_setprioceiling$handle() {
        return pthread_mutexattr_setprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr, int __prioceiling)
     * }
     */
    public static MemorySegment pthread_mutexattr_setprioceiling$address() {
        return pthread_mutexattr_setprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr, int __prioceiling)
     * }
     */
    public static int pthread_mutexattr_setprioceiling(MemorySegment __attr, int __prioceiling) {
        var mh$ = pthread_mutexattr_setprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setprioceiling", __attr, __prioceiling);
            }
            return (int)mh$.invokeExact(__attr, __prioceiling);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getrobust {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutexattr_getrobust");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr, int *__robustness)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getrobust$descriptor() {
        return pthread_mutexattr_getrobust.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr, int *__robustness)
     * }
     */
    public static MethodHandle pthread_mutexattr_getrobust$handle() {
        return pthread_mutexattr_getrobust.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr, int *__robustness)
     * }
     */
    public static MemorySegment pthread_mutexattr_getrobust$address() {
        return pthread_mutexattr_getrobust.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr, int *__robustness)
     * }
     */
    public static int pthread_mutexattr_getrobust(MemorySegment __attr, MemorySegment __robustness) {
        var mh$ = pthread_mutexattr_getrobust.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getrobust", __attr, __robustness);
            }
            return (int)mh$.invokeExact(__attr, __robustness);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setrobust {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_INT
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_mutexattr_setrobust");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr, int __robustness)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setrobust$descriptor() {
        return pthread_mutexattr_setrobust.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr, int __robustness)
     * }
     */
    public static MethodHandle pthread_mutexattr_setrobust$handle() {
        return pthread_mutexattr_setrobust.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr, int __robustness)
     * }
     */
    public static MemorySegment pthread_mutexattr_setrobust$address() {
        return pthread_mutexattr_setrobust.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr, int __robustness)
     * }
     */
    public static int pthread_mutexattr_setrobust(MemorySegment __attr, int __robustness) {
        var mh$ = pthread_mutexattr_setrobust.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setrobust", __attr, __robustness);
            }
            return (int)mh$.invokeExact(__attr, __robustness);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_rwlock_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_init(pthread_rwlock_t *restrict __rwlock, const pthread_rwlockattr_t *restrict __attr)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_init$descriptor() {
        return pthread_rwlock_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_init(pthread_rwlock_t *restrict __rwlock, const pthread_rwlockattr_t *restrict __attr)
     * }
     */
    public static MethodHandle pthread_rwlock_init$handle() {
        return pthread_rwlock_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_init(pthread_rwlock_t *restrict __rwlock, const pthread_rwlockattr_t *restrict __attr)
     * }
     */
    public static MemorySegment pthread_rwlock_init$address() {
        return pthread_rwlock_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_init(pthread_rwlock_t *restrict __rwlock, const pthread_rwlockattr_t *restrict __attr)
     * }
     */
    public static int pthread_rwlock_init(MemorySegment __rwlock, MemorySegment __attr) {
        var mh$ = pthread_rwlock_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_init", __rwlock, __attr);
            }
            return (int)mh$.invokeExact(__rwlock, __attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_rwlock_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_destroy$descriptor() {
        return pthread_rwlock_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MethodHandle pthread_rwlock_destroy$handle() {
        return pthread_rwlock_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MemorySegment pthread_rwlock_destroy$address() {
        return pthread_rwlock_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock)
     * }
     */
    public static int pthread_rwlock_destroy(MemorySegment __rwlock) {
        var mh$ = pthread_rwlock_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_destroy", __rwlock);
            }
            return (int)mh$.invokeExact(__rwlock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_rdlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_rwlock_rdlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_rdlock$descriptor() {
        return pthread_rwlock_rdlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MethodHandle pthread_rwlock_rdlock$handle() {
        return pthread_rwlock_rdlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MemorySegment pthread_rwlock_rdlock$address() {
        return pthread_rwlock_rdlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static int pthread_rwlock_rdlock(MemorySegment __rwlock) {
        var mh$ = pthread_rwlock_rdlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_rdlock", __rwlock);
            }
            return (int)mh$.invokeExact(__rwlock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_tryrdlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_rwlock_tryrdlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_tryrdlock$descriptor() {
        return pthread_rwlock_tryrdlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MethodHandle pthread_rwlock_tryrdlock$handle() {
        return pthread_rwlock_tryrdlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MemorySegment pthread_rwlock_tryrdlock$address() {
        return pthread_rwlock_tryrdlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static int pthread_rwlock_tryrdlock(MemorySegment __rwlock) {
        var mh$ = pthread_rwlock_tryrdlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_tryrdlock", __rwlock);
            }
            return (int)mh$.invokeExact(__rwlock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_timedrdlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_rwlock_timedrdlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_timedrdlock$descriptor() {
        return pthread_rwlock_timedrdlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static MethodHandle pthread_rwlock_timedrdlock$handle() {
        return pthread_rwlock_timedrdlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static MemorySegment pthread_rwlock_timedrdlock$address() {
        return pthread_rwlock_timedrdlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static int pthread_rwlock_timedrdlock(MemorySegment __rwlock, MemorySegment __abstime) {
        var mh$ = pthread_rwlock_timedrdlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_timedrdlock", __rwlock, __abstime);
            }
            return (int)mh$.invokeExact(__rwlock, __abstime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_wrlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_rwlock_wrlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_wrlock$descriptor() {
        return pthread_rwlock_wrlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MethodHandle pthread_rwlock_wrlock$handle() {
        return pthread_rwlock_wrlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MemorySegment pthread_rwlock_wrlock$address() {
        return pthread_rwlock_wrlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static int pthread_rwlock_wrlock(MemorySegment __rwlock) {
        var mh$ = pthread_rwlock_wrlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_wrlock", __rwlock);
            }
            return (int)mh$.invokeExact(__rwlock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_trywrlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_rwlock_trywrlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_trywrlock$descriptor() {
        return pthread_rwlock_trywrlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MethodHandle pthread_rwlock_trywrlock$handle() {
        return pthread_rwlock_trywrlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MemorySegment pthread_rwlock_trywrlock$address() {
        return pthread_rwlock_trywrlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static int pthread_rwlock_trywrlock(MemorySegment __rwlock) {
        var mh$ = pthread_rwlock_trywrlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_trywrlock", __rwlock);
            }
            return (int)mh$.invokeExact(__rwlock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_timedwrlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_rwlock_timedwrlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_timedwrlock$descriptor() {
        return pthread_rwlock_timedwrlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static MethodHandle pthread_rwlock_timedwrlock$handle() {
        return pthread_rwlock_timedwrlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static MemorySegment pthread_rwlock_timedwrlock$address() {
        return pthread_rwlock_timedwrlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict __rwlock, const struct timespec *restrict __abstime)
     * }
     */
    public static int pthread_rwlock_timedwrlock(MemorySegment __rwlock, MemorySegment __abstime) {
        var mh$ = pthread_rwlock_timedwrlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_timedwrlock", __rwlock, __abstime);
            }
            return (int)mh$.invokeExact(__rwlock, __abstime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RdmaCm.C_INT,
            RdmaCm.C_POINTER
        );

        public static final MemorySegment ADDR = RdmaCm.findOrThrow("pthread_rwlock_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_unlock$descriptor() {
        return pthread_rwlock_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MethodHandle pthread_rwlock_unlock$handle() {
        return pthread_rwlock_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static MemorySegment pthread_rwlock_unlock$address() {
        return pthread_rwlock_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock)
     * }
     */
    public static int pthread_rwlock_unlock(MemorySegment __rwlock) {
        var mh$ = pthread_rwlock_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_unlock", __rwlock);
            }
            return (int)mh$.invokeExact(__rwlock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

