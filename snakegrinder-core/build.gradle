plugins {
  id 'java-library'
}

repositories {
  mavenCentral()
}

// IMPORTANT:
// Keep these artifacts aligned with the *host* GraalVM JDK you run SnakeGrinder with.
// You are running Oracle GraalVM JDK 25.0.1+8.1, so use Graal languages 25.0.1.
// If you upgrade/downgrade GraalVM, update this version to match.
ext {
  graalvmPolyglotVersion = '25.0.1'
}

dependencies {
  api "org.graalvm.polyglot:polyglot:${graalvmPolyglotVersion}"
  // Pulls in the Graal Python (GraalPy) runtime for embedding.
  // If you prefer relying on a locally installed language (gu install python),
  // you can remove this dependency and ensure the host GraalVM has Python installed.
  implementation "org.graalvm.polyglot:python:${graalvmPolyglotVersion}"

  // Test dependencies
  testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.2'
  testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.2'
  testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.2'
  testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.10.2'
}

java {
  toolchain {
    languageVersion = JavaLanguageVersion.of(25)
  }
}

// =============================================================================
// Test Configuration
// =============================================================================
// Integration tests require GraalPy and PyTorch venv from snakegrinder-dist.
// The PYTORCH_VENV environment variable must point to the venv location.

def pytorchVenvPath = System.getenv('PYTORCH_VENV') ?:
    "${rootProject.projectDir}/snakegrinder-dist/.pytorch-venv"
def torchLibPath = "${pytorchVenvPath}/lib/python3.12/site-packages/torch/lib"

// =============================================================================
// Unit Tests (JVM mode, no native image required)
// =============================================================================
// Run with: ./gradlew :snakegrinder-core:test

test {
    useJUnitPlatform {
        excludeTags 'integration'
    }

    // Pass PyTorch venv location to tests
    environment 'PYTORCH_VENV', pytorchVenvPath

    // Set library path for PyTorch native libs
    def osName = System.getProperty('os.name', '').toLowerCase(Locale.ROOT)
    if (osName.contains('mac')) {
        environment 'DYLD_LIBRARY_PATH', torchLibPath
    } else {
        environment 'LD_LIBRARY_PATH', torchLibPath
    }

    // JVM args for GraalVM Polyglot
    jvmArgs += [
        '-Dpolyglot.engine.WarnInterpreterOnly=false'
    ]

    // Test logging
    testLogging {
        events 'passed', 'skipped', 'failed'
        exceptionFormat = 'full'
        showStandardStreams = true
    }
}

// =============================================================================
// Integration Tests (requires native image binary)
// =============================================================================
// Run with: ./gradlew :snakegrinder-core:integrationTest
// Prerequisites: ./gradlew :snakegrinder-dist:assembleDist

// Files for integration test binary detection (captured at configuration time for config cache)
def distBinaryFile = file("${rootProject.projectDir}/snakegrinder-dist/build/dist/bin/snakegrinder-bin")
def appBinaryFile = file("${rootProject.projectDir}/snakegrinder-dist/build/SnakeGrinder.app/Contents/MacOS/snakegrinder")
def nativeBinaryFile = file("${rootProject.projectDir}/snakegrinder-cli/build/native/nativeCompile/snakegrinder")

tasks.register('integrationTest', Test) {
    description = 'Run integration tests that invoke the native image CLI'
    group = 'verification'

    // Use same test sources and classes as main test task
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath

    useJUnitPlatform {
        includeTags 'integration'
    }

    // Pass PyTorch venv location to tests
    environment 'PYTORCH_VENV', pytorchVenvPath

    // Set library path for PyTorch native libs
    def osName = System.getProperty('os.name', '').toLowerCase(Locale.ROOT)
    if (osName.contains('mac')) {
        environment 'DYLD_LIBRARY_PATH', torchLibPath
    } else {
        environment 'LD_LIBRARY_PATH', torchLibPath
    }

    // Test logging
    testLogging {
        events 'passed', 'skipped', 'failed'
        exceptionFormat = 'full'
        showStandardStreams = true
    }

    // Skip if native image doesn't exist
    onlyIf {
        def exists = distBinaryFile.exists() || appBinaryFile.exists() || nativeBinaryFile.exists()
        if (!exists) {
            println "WARN: Skipping integration tests: native image not found"
            println "WARN: Build first: ./gradlew :snakegrinder-dist:assembleDist"
        }
        exists
    }
}

// Make check task run both unit and integration tests
check.dependsOn integrationTest

// =============================================================================
// Fixture Generation (on-demand task to regenerate StableHLO fixtures)
// =============================================================================
// Run with: ./gradlew :snakegrinder-core:generateFixtures
// Prerequisites: ./gradlew :snakegrinder-dist:assembleDist

tasks.register('generateFixtures', Test) {
    description = 'Generate StableHLO MLIR fixtures by tracing PyTorch operations'
    group = 'verification'

    // Use same test sources and classes as main test task
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath

    useJUnitPlatform {
        includeTags 'fixture-generator'
    }

    // Pass PyTorch venv location
    environment 'PYTORCH_VENV', pytorchVenvPath

    // Set library path for PyTorch native libs
    def osName = System.getProperty('os.name', '').toLowerCase(Locale.ROOT)
    if (osName.contains('mac')) {
        environment 'DYLD_LIBRARY_PATH', torchLibPath
    } else {
        environment 'LD_LIBRARY_PATH', torchLibPath
    }

    // Test logging - show all output for fixture generation
    testLogging {
        events 'passed', 'skipped', 'failed'
        exceptionFormat = 'full'
        showStandardStreams = true
    }

    // Skip if native image doesn't exist
    onlyIf {
        def exists = distBinaryFile.exists() || appBinaryFile.exists() || nativeBinaryFile.exists()
        if (!exists) {
            println "WARN: Skipping fixture generation: native image not found"
            println "WARN: Build first: ./gradlew :snakegrinder-dist:assembleDist"
        }
        exists
    }
}

// =============================================================================
// GraalPy PyTorch Build Dependency Detection and Installation
// =============================================================================
// PyTorch must be built from source for GraalPy (no prebuilt wheels available).
// Required: cmake >= 3.18, C++ compiler (Xcode on macOS, g++ on Linux)
// Optional: ninja (significantly speeds up builds)

// Helper to detect the Linux package manager
def detectLinuxPackageManager = {
    def osName = System.getProperty('os.name', '').toLowerCase(Locale.ROOT)
    if (!osName.contains('linux')) return null

    def managers = ['apt-get': 'apt', 'dnf': 'dnf', 'yum': 'yum', 'pacman': 'pacman', 'apk': 'apk']
    for (entry in managers) {
        def check = ['bash', '-c', "command -v ${entry.key}"].execute()
        check.waitFor()
        if (check.exitValue() == 0) return entry.value
    }
    return null
}

// Helper to check a command exists and optionally check version
// Returns a map with 'exists', 'version', and 'versionOk' keys
def checkCommand = { cmd, versionCheck = null ->
    def result = [exists: false, version: null, versionOk: true]
    def check = ['bash', '-c', "command -v ${cmd}"].execute()
    check.waitFor()
    if (check.exitValue() == 0) {
        result.exists = true
        if (versionCheck != null) {
            def versionOut = ['bash', '-c', "${cmd} --version | head -1"].execute().text.trim()
            result.version = versionOut
            result.versionOk = versionCheck(versionOut)
        }
    }
    return result
}

// Check cmake version >= 3.18
def cmakeVersionOk = { versionOut ->
    def match = versionOut =~ /(\d+)\.(\d+)/
    if (match.find()) {
        def major = match.group(1) as int
        def minor = match.group(2) as int
        return major > 3 || (major == 3 && minor >= 18)
    }
    return false
}

// Shared dependency checking logic - returns map with 'satisfied', 'missing', 'warnings'
def checkGraalPyDepsStatus = { verbose ->
    def osName = System.getProperty('os.name', '').toLowerCase(Locale.ROOT)
    def isMacOS = osName.contains('mac')
    def isLinux = osName.contains('linux')

    def result = [satisfied: true, missing: [], warnings: [], isMacOS: isMacOS, isLinux: isLinux, pkgManager: null]

    if (!isMacOS && !isLinux) {
        result.satisfied = false
        result.missing << "Unsupported platform (macOS and Linux only)"
        return result
    }

    result.pkgManager = isLinux ? detectLinuxPackageManager() : null

    if (verbose) {
        println "Platform: ${isMacOS ? 'macOS' : 'Linux'}"
        if (isLinux && result.pkgManager) println "Package manager: ${result.pkgManager}"
        println ""
    }

    // ---- C++ Compiler ----
    if (isMacOS) {
        def xcodeCheck = ['bash', '-c', 'xcode-select -p 2>/dev/null'].execute()
        xcodeCheck.waitFor()
        if (xcodeCheck.exitValue() != 0) {
            result.satisfied = false
            result.missing << "xcode-cli"
        } else if (verbose) {
            println "  [OK] Xcode CLI tools: ${xcodeCheck.text.trim()}"
        }

        def clang = checkCommand('clang++')
        if (!clang.exists) {
            result.satisfied = false
            result.missing << "clang++"
        } else if (verbose) {
            def ver = ['bash', '-c', 'clang++ --version | head -1'].execute().text.trim()
            println "  [OK] clang++: ${ver}"
        }
    } else {
        def gpp = checkCommand('g++')
        if (!gpp.exists) {
            result.satisfied = false
            result.missing << "g++"
        } else if (verbose) {
            def ver = ['bash', '-c', 'g++ --version | head -1'].execute().text.trim()
            println "  [OK] g++: ${ver}"
        }
    }

    // ---- cmake (>= 3.18) ----
    def cmake = checkCommand('cmake', cmakeVersionOk)
    if (!cmake.exists) {
        result.satisfied = false
        result.missing << "cmake"
    } else if (!cmake.versionOk) {
        result.satisfied = false
        result.missing << "cmake-upgrade"
    } else if (verbose) {
        println "  [OK] cmake: ${cmake.version}"
    }

    // ---- ninja (optional) ----
    def ninja = checkCommand('ninja')
    if (!ninja.exists) {
        result.warnings << "ninja not installed (optional, speeds up PyTorch build)"
        result.missing << "ninja"  // Include so install can add it
    } else if (verbose) {
        def ver = ['bash', '-c', 'ninja --version'].execute().text.trim()
        println "  [OK] ninja: ${ver}"
    }

    // ---- make ----
    def make = checkCommand('make')
    if (!make.exists) {
        result.satisfied = false
        result.missing << "make"
    } else if (verbose) {
        println "  [OK] make available"
    }

    return result
}

tasks.register('checkGraalPyDeps') {
    group = 'graalpy'
    description = 'Check GraalPy PyTorch build dependencies (cmake, ninja, C++ compiler)'

    doLast {
        println "Checking GraalPy PyTorch build dependencies..."
        println ""

        def status = checkGraalPyDepsStatus(true)

        println ""
        if (status.satisfied) {
            println "All required dependencies are satisfied!"
            if (!status.warnings.isEmpty()) {
                println ""
                status.warnings.each { println "  [WARN] ${it}" }
            }
        } else {
            def required = status.missing.findAll { it != 'ninja' }
            println "Missing required dependencies: ${required.join(', ')}"
            println ""
            println "Run './gradlew :snakegrinder-core:installGraalPyDeps' to install."
            throw new GradleException("Missing GraalPy PyTorch build dependencies.")
        }
    }
}

tasks.register('installGraalPyDeps') {
    group = 'graalpy'
    description = 'Ensure GraalPy PyTorch build dependencies are installed (idempotent)'

    doLast {
        // First check what's missing
        def status = checkGraalPyDepsStatus(false)

        if (!status.isMacOS && !status.isLinux) {
            throw new GradleException("This task supports macOS and Linux only.")
        }

        // Filter out ninja from required check (it's optional)
        def requiredMissing = status.missing.findAll { it != 'ninja' }
        def ninjaNeeded = status.missing.contains('ninja')

        if (requiredMissing.isEmpty() && !ninjaNeeded) {
            println "All GraalPy PyTorch build dependencies are already installed."
            return
        }

        println "Installing GraalPy PyTorch build dependencies..."
        println ""

        def installed = []

        if (status.isMacOS) {
            // Check Homebrew
            def brewCheck = ['bash', '-c', 'command -v brew'].execute()
            brewCheck.waitFor()
            if (brewCheck.exitValue() != 0) {
                throw new GradleException(
                    "Homebrew is required on macOS. Install it first:\n" +
                    "  /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
                )
            }

            // Xcode CLI tools
            if (status.missing.contains('xcode-cli') || status.missing.contains('clang++')) {
                println "Installing Xcode Command Line Tools..."
                println "  A dialog will appear - please follow the prompts."
                def proc = ['xcode-select', '--install'].execute()
                proc.waitFor()
                installed << "Xcode CLI tools"
            }

            // cmake
            if (status.missing.contains('cmake') || status.missing.contains('cmake-upgrade')) {
                println "Installing cmake via Homebrew..."
                def proc = ['brew', 'install', 'cmake'].execute()
                proc.consumeProcessOutput(System.out, System.err)
                if (proc.waitFor() != 0) {
                    throw new GradleException("Failed to install cmake")
                }
                installed << "cmake"
            }

            // ninja (optional but we install it)
            if (ninjaNeeded) {
                println "Installing ninja via Homebrew..."
                def proc = ['brew', 'install', 'ninja'].execute()
                proc.consumeProcessOutput(System.out, System.err)
                if (proc.waitFor() != 0) {
                    println "  [WARN] Failed to install ninja (optional)"
                } else {
                    installed << "ninja"
                }
            }
        } else {
            // Linux
            def pkgManager = status.pkgManager
            if (pkgManager == null) {
                throw new GradleException("Could not detect package manager. Please install dependencies manually.")
            }

            // Check if we have passwordless sudo access
            def sudoCheck = ['sudo', '-n', 'true'].execute()
            sudoCheck.waitFor()
            def hasSudo = (sudoCheck.exitValue() == 0)

            def packagesToInstall = []

            // g++ / build tools
            if (status.missing.contains('g++') || status.missing.contains('make')) {
                switch (pkgManager) {
                    case 'apt': packagesToInstall << 'build-essential'; break
                    case 'dnf': case 'yum': packagesToInstall << '@development-tools'; break
                    case 'pacman': packagesToInstall << 'base-devel'; break
                    case 'apk': packagesToInstall << 'build-base'; break
                }
            }

            // cmake
            if (status.missing.contains('cmake')) {
                switch (pkgManager) {
                    case 'apt': packagesToInstall << 'cmake'; break
                    case 'dnf': packagesToInstall << 'cmake'; break
                    case 'yum': packagesToInstall << 'cmake3'; break
                    case 'pacman': packagesToInstall << 'cmake'; break
                    case 'apk': packagesToInstall << 'cmake'; break
                }
            }

            // ninja (optional but we install it)
            if (ninjaNeeded) {
                switch (pkgManager) {
                    case 'apt': packagesToInstall << 'ninja-build'; break
                    case 'dnf': case 'yum': packagesToInstall << 'ninja-build'; break
                    case 'pacman': packagesToInstall << 'ninja'; break
                    case 'apk': packagesToInstall << 'ninja'; break
                }
            }

            if (!packagesToInstall.isEmpty()) {
                if (!hasSudo) {
                    // No sudo access - provide manual instructions
                    def installCmd
                    switch (pkgManager) {
                        case 'apt': installCmd = "sudo apt-get install -y ${packagesToInstall.join(' ')}"; break
                        case 'dnf': installCmd = "sudo dnf install -y ${packagesToInstall.join(' ')}"; break
                        case 'yum': installCmd = "sudo yum install -y ${packagesToInstall.join(' ')}"; break
                        case 'pacman': installCmd = "sudo pacman -S --noconfirm ${packagesToInstall.join(' ')}"; break
                        case 'apk': installCmd = "sudo apk add ${packagesToInstall.join(' ')}"; break
                    }
                    throw new GradleException(
                        "Missing dependencies require sudo to install.\n" +
                        "Run this command manually (or add to CI runner setup):\n\n" +
                        "  ${installCmd}\n"
                    )
                }

                def installCmd
                switch (pkgManager) {
                    case 'apt': installCmd = ['sudo', 'apt-get', 'install', '-y'] + packagesToInstall; break
                    case 'dnf': installCmd = ['sudo', 'dnf', 'install', '-y'] + packagesToInstall; break
                    case 'yum': installCmd = ['sudo', 'yum', 'install', '-y'] + packagesToInstall; break
                    case 'pacman': installCmd = ['sudo', 'pacman', '-S', '--noconfirm'] + packagesToInstall; break
                    case 'apk': installCmd = ['sudo', 'apk', 'add'] + packagesToInstall; break
                }

                println "Installing: ${packagesToInstall.join(', ')}"
                println "Running: ${installCmd.join(' ')}"

                def proc = installCmd.execute()
                proc.consumeProcessOutput(System.out, System.err)
                def exitCode = proc.waitFor()

                if (exitCode != 0) {
                    throw new GradleException("Package installation failed with exit code ${exitCode}")
                }
                installed.addAll(packagesToInstall)
            }
        }

        // Verify installation
        println ""
        def verifyStatus = checkGraalPyDepsStatus(false)
        def stillMissing = verifyStatus.missing.findAll { it != 'ninja' }

        if (!stillMissing.isEmpty()) {
            throw new GradleException("Installation completed but some dependencies are still missing: ${stillMissing.join(', ')}")
        }

        if (installed.isEmpty()) {
            println "All dependencies were already installed."
        } else {
            println "Successfully installed: ${installed.join(', ')}"
        }
        println ""
        println "GraalPy PyTorch build dependencies are ready."
    }
}
